{"meta":{"title":"hojun","subtitle":"好少年光芒万丈","description":"好少年光芒万丈","author":"hojun","url":"https://www.hojun.cn"},"pages":[{"title":"","date":"2018-02-22T07:29:34.851Z","updated":"2018-02-05T15:50:10.000Z","comments":true,"path":"index.html","permalink":"https://www.hojun.cn/index.html","excerpt":"","text":"hojunBlog - Just A NoteBook HJ 首页 归档 标签 视频资源 RSS Feed 帮助中心 hojun ·2018-01-24 tesseract-OCR字库练习 tesseract-OCR字库练习 hojun ·2018-01-11 Python玩转冲顶大会 Python玩转冲顶大会 hojun ·2018-01-10 snowfall.jquery.js实现樱花飘落效果 · js snowfall.jquery.js实现樱花飘落效果 hojun ·2018-01-08 python玩转跳一跳 · python python玩转跳一跳 hojun ·2017-12-30 每日签到 每日签到 hojun ·2017-12-25 圣诞快乐！ 圣诞快乐！ hojun ·2017-11-15 Lozad.js学习使用 · js · hexo Lozad懒加载 hojun ·2017-10-23 hexo 使用说明 hexo 使用说明 hojun ·2017-10-22 PHP模拟登陆 · php · 模拟登陆 PHP模拟登陆 hojun ·2017-10-16 excel笔记 excel笔记 123&hellip;5下一页 关于本站&nbsp;&nbsp·&nbsp;&nbsp 帮助中心&nbsp;&nbsp·&nbsp;&nbsp 视频资源&nbsp;&nbsp·&nbsp;&nbsp 友情链接&nbsp;&nbsp·&nbsp;&nbsp 本站点采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议，已建立天 ©2017 基于Hexo搭建 ，主题&nbspJSimple ，感谢github提供免费优质的强力驱动 //太卡了不要了 // var cnzz_protocol = ((\"https:\" == document.location.protocol) ? \" https://\" : \" http://\");document.write(unescape(\"%3Cspan id='cnzz_stat_icon_1262747754'%3E%3C/span%3E%3Cscript src='\" + cnzz_protocol + \"s22.cnzz.com/z_stat.php%3Fid%3D1262747754%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E\")); var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?15e55c3816abfbc912d5cb0d9000a2d4\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); $(function () { SimpleCore.init({ buildingTime: '04/24/2017', current: $('.post-tags').length > 0 ? 'post' : 'archive', customImg: '/images/customImg.png', tipImg: '/images/tipImg.png', }); const observer = lozad(); observer.observe(); //飘雪效果 if($(\"title\").html() == '圣诞快乐！ - hojunBlog'){ $(document).snowfall('clear'); $(document).snowfall({round:true, minSize:1, maxSize:5, flakeCount:100}); } //樱花效果 if($(\"title\").html() == 'snowfall.jquery.js实现樱花飘落效果 - hojunBlog'){ $(document).snowfall('clear'); if (document.body.clientWidth>600) { $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/2.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/4.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); } else { $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/2.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/4.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); } } });"},{"title":"关于此博客搭建","date":"2017-06-18T15:39:18.000Z","updated":"2018-02-05T15:50:10.000Z","comments":true,"path":"help/index.html","permalink":"https://www.hojun.cn/help/index.html","excerpt":"","text":"第一步 环境参照简书这篇文章 20分钟教你使用hexo搭建github博客咳咳，对于小白好像挺烦的样子。需要git账号，本地电脑安装git,node.js,hexo等等。有机会再补上windows教程吧。不过和mac也差不了。 第二步 blog模板在HEXO官网Themes可以自己挑选喜欢的模板。该博客使用的模板为JSimple关于该模板使用注意 1.建议使用作者博客备份，在上面稍加修改地址：https://github.com/shuoit/blog 2.注意模板依赖 比如JSimple的依赖为1234567891011121314&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.2.2&quot;, &quot;hexo-git-backup&quot;: &quot;^0.1.2&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.11&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;0.2.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-json-content&quot;: &quot;^2.2.0&quot;&#125; 修改依赖后记得cmd到博客目录下1npm install","keywords":"博客 blog hexo github"},{"title":"友链","date":"2017-04-26T05:40:53.000Z","updated":"2018-08-27T14:16:13.565Z","comments":false,"path":"links/index.html","permalink":"https://www.hojun.cn/links/index.html","excerpt":"","text":".link-contentqt { padding: 0px !important; width: 100%; } .link-contentqt li { text-align: center; font-size: 12px; width: 100px; height: 100px; margin-bottom: 10px; list-style-type: none; float: left; } .link-contentqt li img { height: auto; max-width: 100%; border-radius: 100%; margin-bottom: 5px; transition: .5s; -webkit-transition: .5s; width: 50px; height: 50px; } .link-contentqt li a:hover img { transform: scale(1.2); } .link-contentqt li span { display: block; height: 32px; line-height: 32px; } .link-contentqt li a:hover span { color: #ffac00; } xia_sir jdshao Dimple infiniteSky Kebin.Wang SimonKing FKomm RioHsc 幻凡ss 李策 猴子星球 Zidone 零一序列 Yiveco YUGE 圈住圈九酱 JerryC 董沅鑫个人网站 友人C 千千 Nice's Blog TRHX 博採眾長 申请友链可以在下方留言告诉博主： 举个黄瓜 网址：https://www.hojun.cn 名称：hojun 描述：一个好奇的博客 头像：https://wx1.sinaimg.cn/large/006bYVyvgy1ftand2qurdj303c03cdfv.jpg new Valine({ el: '#vcomments', appId: \"GyC3NzMvd0hT9Yyd2hYIC0MN-gzGzoHsz\", appKey: \"mgOpfzbkHYqU92CV4IDlAUHQ\", // visitor: true })","keywords":null},{"title":"标签云","date":"2017-04-26T03:30:12.000Z","updated":"2018-02-05T15:50:10.000Z","comments":true,"path":"tags/index.html","permalink":"https://www.hojun.cn/tags/index.html","excerpt":"","text":""},{"title":"关于此博客搭建","date":"2017-06-18T15:39:18.000Z","updated":"2018-02-05T15:50:10.000Z","comments":true,"path":"video/index.html","permalink":"https://www.hojun.cn/video/index.html","excerpt":"","text":"第一步 环境参照简书这篇文章 20分钟教你使用hexo搭建github博客咳咳，对于小白好像挺烦的样子。需要git账号，本地电脑安装git,node.js,hexo等等。有机会再补上windows教程吧。不过和mac也差不了。 第二步 blog模板在HEXO官网Themes可以自己挑选喜欢的模板。该博客使用的模板为JSimple关于该模板使用注意 1.建议使用作者博客备份，在上面稍加修改地址：https://github.com/shuoit/blog 2.注意模板依赖 比如JSimple的依赖为1234567891011121314&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.2.2&quot;, &quot;hexo-git-backup&quot;: &quot;^0.1.2&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.11&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;0.2.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-json-content&quot;: &quot;^2.2.0&quot;&#125; 修改依赖后记得cmd到博客目录下1npm install","keywords":"博客 blog hexo github"},{"title":"关于此博客搭建","date":"2017-06-18T15:39:18.000Z","updated":"2018-02-05T15:50:10.000Z","comments":true,"path":"rss/index.html","permalink":"https://www.hojun.cn/rss/index.html","excerpt":"","text":"第一步 环境参照简书这篇文章 20分钟教你使用hexo搭建github博客咳咳，对于小白好像挺烦的样子。需要git账号，本地电脑安装git,node.js,hexo等等。有机会再补上windows教程吧。不过和mac也差不了。 第二步 blog模板在HEXO官网Themes可以自己挑选喜欢的模板。该博客使用的模板为JSimple关于该模板使用注意 1.建议使用作者博客备份，在上面稍加修改地址：https://github.com/shuoit/blog 2.注意模板依赖 比如JSimple的依赖为1234567891011121314&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.2.2&quot;, &quot;hexo-git-backup&quot;: &quot;^0.1.2&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.11&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;0.2.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-json-content&quot;: &quot;^2.2.0&quot;&#125; 修改依赖后记得cmd到博客目录下1npm install","keywords":"博客 blog hexo github"},{"title":"","date":"2017-06-18T15:39:18.000Z","updated":"2018-08-08T15:02:48.303Z","comments":true,"path":"about/hojun.html","permalink":"https://www.hojun.cn/about/hojun.html","excerpt":"","text":"\"你好，好友or陌生人？欢迎来到的我的个人博客搭建这个博客站的初衷仅是为了写下知识点因为时间总是会记不清楚了或许写的文字能够帮助到更多的人那就用博客记录并分享吧想不想和我一起沐浴在知识的海洋里 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ——by hojun&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 双鱼座/好奇如猫症患者&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\"爱看书也爱远行心情在路上FIND YOURSELF读很多的随记也写下很多的文字/浅浅淡淡似乎还能感受到那是的安稳自由惬意和一种特殊的安静的力量如果还能出发去遇见更多的未知的人和事那我一定不辜负世界的温柔","keywords":"博客 blog hexo github"},{"title":"关于此博客搭建","date":"2017-06-18T15:39:18.000Z","updated":"2018-02-05T15:50:10.000Z","comments":true,"path":"about/index.html","permalink":"https://www.hojun.cn/about/index.html","excerpt":"","text":"第一步 环境参照简书这篇文章 20分钟教你使用hexo搭建github博客咳咳，对于小白好像挺烦的样子。需要git账号，本地电脑安装git,node.js,hexo等等。有机会再补上windows教程吧。不过和mac也差不了。 第二步 blog模板在HEXO官网Themes可以自己挑选喜欢的模板。该博客使用的模板为JSimple关于该模板使用注意 1.建议使用作者博客备份，在上面稍加修改地址：https://github.com/shuoit/blog 2.注意模板依赖 比如JSimple的依赖为1234567891011121314&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.2.2&quot;, &quot;hexo-git-backup&quot;: &quot;^0.1.2&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.11&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;0.2.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-json-content&quot;: &quot;^2.2.0&quot;&#125; 修改依赖后记得cmd到博客目录下1npm install","keywords":"博客 blog hexo github"}],"posts":[{"title":"开学啦","slug":"开学啦","date":"2018-08-31T15:18:09.000Z","updated":"2018-09-01T14:28:23.271Z","comments":true,"path":"2018/08/31/开学啦/","link":"","permalink":"https://www.hojun.cn/2018/08/31/开学啦/","excerpt":"","text":"暑假过完了，又要开学啦~ 已经不是学生的我怀着怎样的心情写的这篇文章呢？ 有些开心，有些怀念，有些伤感。 从小到大，身为一个爱玩的孩纸，假期作业一直都会拖到暑假的最后几天。 我不入地狱谁入地狱233333~ 当然最后都顺利开学了。 特意给同学们弄了个悬浮框233333~ 就是右上角那个。 Back to School，祝你开心 .tanabata-jump { width: 130px; height: 101px; position: fixed; right: 4%; top: 88px; z-index: 1002; animation: yao 2.4s infinite; background: url(/images/schoolopens/schoolopens.png)no-repeat center; background-size: cover; } a { text-decoration: none; } .starting-school { width: 134px; height: 122px; background: url(/images/schoolopens/schoolopens.png)center no-repeat; } .tanabata-jump>i { display: block; position: absolute; width: 9px; height: 9px; top: 0px; right: -12px; cursor: pointer; } @-webkit-keyframes yao { 0% { top: 4%; } 50% { top: 6%; } 100% { top: 4%; } } @-o-keyframes yao { 0% { top: 4%; } 50% { top: 6%; } 100% { top: 4%; } } @-moz-keyframes yao { 0% { top: 4%; } 50% { top: 6%; } 100% { top: 4%; } } @keyframes yao { 0% { top: 4%; } 50% { top: 6%; } 100% { top: 4%; } }","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"网页看板娘-Live2d蕾姆","slug":"网页看板娘-Live2d蕾姆","date":"2018-08-30T15:56:28.000Z","updated":"2018-08-30T15:59:15.697Z","comments":true,"path":"2018/08/30/网页看板娘-Live2d蕾姆/","link":"","permalink":"https://www.hojun.cn/2018/08/30/网页看板娘-Live2d蕾姆/","excerpt":"","text":"博客群里的小伙伴想要蕾姆的live2d看板娘资源，花了些时间做了个demo代码（仅供学习参考）。本期人物：小蕾姆效果如下： 食用方法1.将代码放在服务器环境下，可以是Apache、iis、Nginx。也可以是node服务器。 2.访问代码下的index.html文件即可。（如：https://localhost:5555/demo/index.html） 整合代码将index.html的css、body中的元素插入到你想放的页面即可。（不会可以评论求助） 关注公众号回复demo003获取资源23333","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"live2d","slug":"live2d","permalink":"https://www.hojun.cn/tags/live2d/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"CSS+SVG路径描边特效","slug":"CSS-SVG路径描边特效","date":"2018-08-28T12:39:45.000Z","updated":"2018-08-28T14:20:28.370Z","comments":true,"path":"2018/08/28/CSS-SVG路径描边特效/","link":"","permalink":"https://www.hojun.cn/2018/08/28/CSS-SVG路径描边特效/","excerpt":"","text":"在猫与向日葵大佬那看到了他的Logo特效，效果如下：嘿嘿嘿，挺有意思。直接F12爬其代码。框起来的是元素和对应的css文件。爬好后得到的效果如下：自己实现的效果如下：最后宣传下简友群关注公众号回复demo001获取代码","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"特效","slug":"特效","permalink":"https://www.hojun.cn/tags/特效/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"一台电脑上配置两个Git账号？可能你并不需要","slug":"一台电脑上配置两个Git账号？可能你并不需要","date":"2018-08-28T08:43:20.000Z","updated":"2018-08-28T09:24:07.684Z","comments":true,"path":"2018/08/28/一台电脑上配置两个Git账号？可能你并不需要/","link":"","permalink":"https://www.hojun.cn/2018/08/28/一台电脑上配置两个Git账号？可能你并不需要/","excerpt":"","text":"前言Q:为啥要两个？A:因为整了个小号哈之前脑子一直陷入了死胡同里，一直觉得小号也要配置。然后网络搜索一台电脑配置两个Git账号，解决思路一般如下：(图片来自网络，侵权联系删除)后来想通了，我就一个人一台电脑，小号在网页上建好仓库把大号拉进去，剩下的大号来不就好了。git的初衷就是为了更好的合作，居然忘了233333。 食用方式小号在仓库&gt;设置&gt;成员管理中添加大号为管理员小号的任务就完成了，接下来在自己电脑上随便建个目录(命令行cmd)。12E:\\blog&gt;mkdir hojunClubE:\\blog&gt;cd hojunClog 进入目录后使用git clone命令克隆仓库代码到本地电脑语法：git clone 仓库地址进入本地仓库中，一顿瞎操作我们这里在仓库中删除了一些东西，然后依次执行如下git命令：git statusgit add .git commit -m ‘delete’git push origin提交成功23333~","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.hojun.cn/tags/git/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Coding的SVN服务踩坑记","slug":"Coding的SVN服务踩坑记","date":"2018-08-28T08:36:19.000Z","updated":"2018-08-28T09:23:29.178Z","comments":true,"path":"2018/08/28/Coding的SVN服务踩坑记/","link":"","permalink":"https://www.hojun.cn/2018/08/28/Coding的SVN服务踩坑记/","excerpt":"","text":"前言Q:咳咳，为啥会用到Coding的SVN?A:博主电脑上已经配好一个coding的账号，且是全局的。网上搜索一台电脑上配置两个git账号都是采用非全区的账号的方法。这个coding是博主的第二个coding账号，全局的账号不想动他。于是尝试下Coding的SVN服务。 食用方式在项目的仓库设置&gt;开启SVN服务，蓝后去下载小乌龟TortoiseSVN。不要点击下面这个，这个是服务器端的。一开始不清楚，踩一个坑不要下载这个！！去下载小乌龟tortoisesvn.net/downloads.html安装打开这个，SVN输入地址(Coding上有)输入Coding账号登录后就可以看到仓库内容了。蓝后直接把需要部署的代码移进去 后续想覆盖文件，报错。想删除文件，报错。由于SVN不是很会用，这两个坑踩的我一脸懵逼。让后脑子终于开窍，想到了更好的解决小号coding代码推送的方法。于是弃用SVN了233333~","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"svn","slug":"svn","permalink":"https://www.hojun.cn/tags/svn/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"node更新","slug":"node更新","date":"2018-08-25T14:46:52.000Z","updated":"2018-08-26T05:23:40.585Z","comments":true,"path":"2018/08/25/node更新/","link":"","permalink":"https://www.hojun.cn/2018/08/25/node更新/","excerpt":"","text":"最近准备做个简友们的站点，然后也想实践下自学的vue知识。于是准备使用VuePress+Coding搭建这个站点。来到VuePress官网，发现其要求node版本需要大于8。而电脑上的node版本是6，需要更新下。（cmd输入node-v命令查看node版本）一开始觉得npm应该能更新，所以先使用npm-v，查看npm版本。然后使用它提示的命令将npm更新到最新版。后来发现win下node不能直接更新，需要在去官网上下载安装包重新安装并覆盖原先安装目录才行。使用where node可以查看node的安装路径。下载好后我们安装到原先目录下。安装成功后使用弄得node-v命令查看node版本，已经更新成功! 26日续，在VuePress官方文档发现其对自定义模板的支持不是很好，文档不全。决定从入门到放弃，还是用Hexo吧","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"node","slug":"node","permalink":"https://www.hojun.cn/tags/node/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"miccall主题及html5up站点推荐","slug":"miccall主题及H5站点推荐","date":"2018-08-25T14:37:08.000Z","updated":"2018-08-26T11:57:51.962Z","comments":true,"path":"2018/08/25/miccall主题及H5站点推荐/","link":"","permalink":"https://www.hojun.cn/2018/08/25/miccall主题及H5站点推荐/","excerpt":"","text":"首先向大大家推荐hexo的miccall主题。演示地址：miccall.tech作者：王金铮作者昵称：miccall页面效果如下：整体样式比较符合心中的展示站点，嗯嗯，很不错。 去其github后才知道主题的模板页面来自html5up，发现这个html5网站也不错，推荐给大家。 地址：html5up.net站长：应该是ajlkn英文描述： makes spiffy HTML5 site templates that are：Fully Responsive Built on intelligent HTML5 + CSS3 Super Customizable100% Free under the Creative Commons 中文描述： 制作漂亮的HTML5网站模板：完全响应 基于智能HTML5 + CSS3 超级可定制 知识共享下的 100％免费 页面效果如下：","categories":[{"name":"资源","slug":"资源","permalink":"https://www.hojun.cn/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://www.hojun.cn/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"https://www.hojun.cn/categories/资源/"}]},{"title":"樱花飘落特效","slug":"樱花飘落特效","date":"2018-08-23T11:20:40.000Z","updated":"2018-08-23T12:48:04.754Z","comments":true,"path":"2018/08/23/樱花飘落特效/","link":"","permalink":"https://www.hojun.cn/2018/08/23/樱花飘落特效/","excerpt":"","text":"在百度上搜索樱花飘落特效，发现自己之前的特效文章并没有被搜录，于是又厚着脸皮重新发了一遍，希望这次百度能给我收录咯。该特效是根据snowfall.jquery.js雪花插件修改的，需要依赖jquery。该插件的参数有： flakeCount|number 雪花数量 flakeColor|#RGB 雪花颜色 flakeIndex|??? 不清楚 minSize|number 雪花最小体积 maxSize|number 雪花最大体积 minSpeed|number 雪花最小速度 maxSpeed|number 雪花最大速度 round|boolean true雪花圆形|false方形(笑哭) shadow|boolean true雪花有阴影|false无阴影 image|url 雪花图片 使用demo//css部分 12345678910&lt;style&gt;.snowfall-flakes&#123;animation:sakura 1s linear 0s infinite;&#125;@keyframes sakura&#123;0% &#123;transform:rotate3d(0, 0, 0, 0deg);&#125;25%&#123;transform:rotate3d(1, 1, 0, 60deg);&#125;50%&#123;transform:rotate3d(1, 1, 0, 0deg);&#125;75%&#123;transform:rotate3d(1, 0, 0, 60deg);&#125;100% &#123;transform:rotate3d(1, 0, 0, 0deg);&#125;&#125;&lt;/style&gt; //js部分 12345678910111213141516171819&lt;script type=\"text/javascript\" src=\"/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"/js/snowfall.jquery.js\"&gt;&lt;/script&gt;&lt;script&gt; function sakuraInit() &#123; $(document).snowfall('clear'); if (document.body.clientWidth &gt; 600) &#123; $(document).snowfall(&#123;image:\"/images/sakura/1.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:\"/images/sakura/1.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:\"/images/sakura/2.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:\"/images/sakura/4.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,&#125;); &#125; else &#123; $(document).snowfall(&#123;image:\"/images/sakura/1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:\"/images/sakura/1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:\"/images/sakura/2.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,&#125;); $(document).snowfall(&#123;image:\"/images/sakura/4.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,&#125;); &#125; &#125; window.onload = sakuraInit();&lt;/script&gt; 飘落的时候添加了css的3D翻转效果，使之更加逼真图片是用ps一个一个扣下来的。扣好发现jpg格式不能带透明度，然后又心酸的重新扣png格式的。。。 function sakuraInit() { $(document).snowfall('clear'); if (document.body.clientWidth > 600) { $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/2.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/4.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); } else { $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/2.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/4.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); } } window.onload = sakuraInit();","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"特效","slug":"特效","permalink":"https://www.hojun.cn/tags/特效/"},{"name":"jquery","slug":"jquery","permalink":"https://www.hojun.cn/tags/jquery/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"PS小白-羽化图片使其融入背景色","slug":"PS小白-羽化图片使其融入背景色","date":"2018-08-18T14:57:46.000Z","updated":"2018-08-18T15:02:45.770Z","comments":true,"path":"2018/08/18/PS小白-羽化图片使其融入背景色/","link":"","permalink":"https://www.hojun.cn/2018/08/18/PS小白-羽化图片使其融入背景色/","excerpt":"","text":"最近发现像我这种业余PS人员掌握的PS技巧总是过几天就会忘记，所以特别记录下这篇，以后估计每学到点新技巧都会及时记录吧，吃一见长一智。这篇教程是把图片边缘羽化过渡成背景色，使得整体看起来没有分界线，比较养眼。废话不多说，开始P图。这里随便找了张图，背景色就采用白色举例。来看下边这张图，边缘是偏蓝色的。按照惯例，复制图层，在副本上操作。第二步，点击底部的新建图层，新建一个图层，把背景图隐藏掉（小眼睛点掉），可以看出新建图层默认是透明的。选中透明图层，使用油漆桶工具将其倒成白色。把白色图层移到背景图层下方。选中背景图层，使用矩形工具选择如下：右键&gt;选择反向。右键&gt;羽化。输入羽化值，这个500是博主试出来的，看图片和自己需求而定。按下键盘的删除键(BackSpace)，可以看到边缘没那么蓝了。隐藏掉白色图层预览更直观，可以看到边缘有点半透明的感觉（透明度降低了）。继续按删除。透明效果如下，一直按删除到满意为止。最终效果如下(这里把图形大小的高度调大了)，看不出图片的边缘在哪。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"ps","slug":"ps","permalink":"https://www.hojun.cn/tags/ps/"},{"name":"设计","slug":"设计","permalink":"https://www.hojun.cn/tags/设计/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"熊掌情书","slug":"熊掌情书","date":"2018-08-18T11:21:55.000Z","updated":"2018-08-18T11:28:09.471Z","comments":true,"path":"2018/08/18/熊掌情书/","link":"","permalink":"https://www.hojun.cn/2018/08/18/熊掌情书/","excerpt":"","text":"Hi 亲爱的你， 第一次给你写信，好紧张。 是要有多奇妙的缘分，让我能够在茫茫人海中遇到你。 还记得你遇见我的第一天吗，你那么真诚的告诉我你的名字，寄给我你的照片，在签名栏里写下我们爱的誓言，害羞的递给我第一条内容链接。回想起那天的场景，我还是会甜蜜的偷笑。 再后来，有你陪伴的每一天都是情人节。我开始幻想未来，和你一起的时光。 房子不用多大，但一定要刷上好看的漆，要贴上红红火火的对联。 最好有个小院子，里面养着花花草草，小猫小狗。 我们要有几个活泼可爱的小朋友，每次你回家，我都会在家问候你：“欢迎回家，工作一天辛苦啦～” 最好，我们还能有一个干净明亮的厨房，有温馨的卧室和简单沉稳的客厅～ 为了这样小小的愿望，我还查了查实现攻略，分享给你，希望早日见到我们的新家～一起加油，么么哒～ “好看的漆”提取攻略：主页背景图设置 “红红火火的对联”提取攻略：认证＋文字运营位配置 “花花草草，小猫小狗”提取攻略：视频宣传位＋图片宣传位配置 “活泼可爱的小朋友”提取攻略：粉丝关注功能（进入搜索资源平台－粉丝关注查看） “回家问候”提取攻略：欢迎语设置＋关键词配置 “厨房＋卧室＋客厅”提取攻略：自定义菜单设置＋自定义栏目设置 点击链提取所有攻略：https://ziyuan.baidu.com/college/documentinfo?id=2453 我一辈子走过许多地方的路，行过许多地方的桥，看过许多次数的云，喝过许多种类的酒，却只爱过正在看信的你。世上但凡有一句话，一件事，是关于你的，便皆成为好。 其实还有好多话想和你说，等我的，下一封信 爱你的人","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"快速开发属于自己的APP-FusionApp","slug":"快速开发属于自己的APP-FusionApp","date":"2018-08-13T14:35:06.000Z","updated":"2018-08-13T14:37:51.149Z","comments":true,"path":"2018/08/13/快速开发属于自己的APP-FusionApp/","link":"","permalink":"https://www.hojun.cn/2018/08/13/快速开发属于自己的APP-FusionApp/","excerpt":"","text":"想不想拥有一个自己专属的App？如果你有个个人的网页，那么使用FusionApp+10分钟你就可以拥有自己的App。此文为FusionApp的粗浅入门教程，其他的博主还未深究。 第一步 安装FusionApp百度搜索FusionApp，安装下载。 第二步 创建模板及配置进入FusionApp，点击右下角+号创建模板，进入如下页面：分为 顶栏模板、标签栏模板、底栏模板、纯底栏模板、空白模板。这里选择了顶栏模板（看自己需求）。输入应用名，点击创建。打开 启用启动图选择图片点击框框的几个角，一定要点击角才能调节大小设置启动网页（自己网站的域名），如下点击右上角的按钮预览一下我们的App 设置属性默认顶栏为黑色，部件为白色。顶栏改为白色，顶栏部件改为黑色（字体和图标）点击修改顶栏标题修改后效果如下 设置组件点击设置测滑栏图片设置测滑栏图片效果如下：添加侧滑栏项目（每日签到）选择从图标仓库中选取图标随便找个图标。设置侧边栏项目效果如下： 制作图标点击左侧侧边栏 ，点击图标制作进入图标制作如下，点击设置图标，选择我们自己的图片可以看到我们的图片不能完全改到绿色的背景，点击设置背景设置为白色点击设置到工程，选择我们的App图标设置效果如下 打包安装点击右上角，打包安装打包完成后开始安装应用选择了解风险，继续安装安装成功，打开应用。打开App,启动页面打开效果如下：","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"搞事","slug":"搞事","permalink":"https://www.hojun.cn/tags/搞事/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"粒子上升渐变特效学习","slug":"粒子上升渐变特效学习","date":"2018-08-12T12:20:52.000Z","updated":"2018-08-12T12:43:40.043Z","comments":true,"path":"2018/08/12/粒子上升渐变特效学习/","link":"","permalink":"https://www.hojun.cn/2018/08/12/粒子上升渐变特效学习/","excerpt":"","text":"之前在某个网站发现有个粒子缓缓上升的特效，最近想用的时候发现找不到了找不到了找不到了。求助群里的大佬们，在大佬推荐的网站上找到了一样的特效。于是把特效顺带学习了波。特效demo如下：这里只取了Bubbles的特效。学习过程记录在代码注释中css代码如下123456789101112131415161718192021222324252627&lt;style&gt;.bubbles &gt; .particle &#123; /*初始透明度为0*/ opacity: 0; position: absolute; /*初始颜色为荧光色，透明度为0.7*/ background-color: rgba(128,255,0,0.7); /*使用bubbles动画，持续时间18秒，缓慢进入，无限循环*/ animation: bubbles 18s ease-in infinite; border-radius: 100%;&#125;/*css keyframes 动画*/@keyframes bubbles &#123; 0% &#123; opacity: 0; &#125; 5% &#123; opacity: 1; transform: translate(0, -20%); &#125; /*这里-8000%表示是气泡的8000%*/ 100% &#123; opacity: 0; transform: translate(0, -8000%); &#125;&#125;&lt;/style&gt; html元素如下12&lt;!-- 这里让元素宽度100%（和页面等宽） --&gt;&lt;div style=\"width: 100%; height: 100px; position: relative; bottom: 0px;\" class=\"particletext bubbles\"&gt;Bubbles&lt;/div&gt; js如下12345678910111213141516171819&lt;script type=\"text/javascript\" src=\"/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function bubbles() &#123; $.each($(\".particletext.bubbles\"), function()&#123; var bubblecount = ($(this).width()/50)*10; for(var i = 0; i &lt;= bubblecount; i++) &#123; var size = ($.rnd(40,80)/10); //这里的animation-delay很重要，关系到你的特效是否看上去是连续无断层的，上一步中css是18秒，所以这一步中延迟时间就设置成$.rnd(0,180)/10) $(this).append('&lt;span class=\"particle\" style=\"top:' + $.rnd(20,80) + '%; left:' + $.rnd(0,95) + '%;width:' + size + 'px; height:' + size + 'px;animation-delay: ' + ($.rnd(0,180)/10) + 's;\"&gt;&lt;/span&gt;'); &#125; &#125;); &#125; jQuery.rnd = function(m,n) &#123; m = parseInt(m); n = parseInt(n); return Math.floor( Math.random() * (n - m + 1) ) + m; &#125; bubbles();&lt;/script&gt; 好了，代码就学习到这里，实现原理已经明了啦。最后预览下效果： .bubbles > .particle { opacity: 0; position: absolute; background-color: rgba(128,255,0,0.7); animation: bubbles 18s ease-in infinite; border-radius: 100%; } @keyframes bubbles { 0% { opacity: 0; } 5% { opacity: 1; transform: translate(0, -20%); } 100% { opacity: 0; transform: translate(0, -8000%); } } function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"特效","slug":"特效","permalink":"https://www.hojun.cn/tags/特效/"},{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"喜大奔普~拼音打字练习功能支持手机了！","slug":"喜大奔普-拼音打字练习功能支持手机了！","date":"2018-08-11T09:25:44.000Z","updated":"2018-08-11T15:24:45.537Z","comments":true,"path":"2018/08/11/喜大奔普-拼音打字练习功能支持手机了！/","link":"","permalink":"https://www.hojun.cn/2018/08/11/喜大奔普-拼音打字练习功能支持手机了！/","excerpt":"","text":"8月11日更新考虑到现在大多都是使用手机为主。更新版本手机也能打。更新后的界面如下，增加了打字功能。请点击字。使用手机的朋友，还需要点击左上角的输入框调出手机的打字面板（推荐使用乱（随机）模式练习打字），下图是使用9键拼音打字。也可以使用英文模式打拼音。 关注以下微信公众号获取更多学习内容~","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"搞事","slug":"搞事","permalink":"https://www.hojun.cn/tags/搞事/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"还在找遥控器？小米手机这功能就够了","slug":"还在找遥控器？小米手机这功能就够了","date":"2018-08-10T13:29:34.000Z","updated":"2018-08-11T15:24:47.760Z","comments":true,"path":"2018/08/10/还在找遥控器？小米手机这功能就够了/","link":"","permalink":"https://www.hojun.cn/2018/08/10/还在找遥控器？小米手机这功能就够了/","excerpt":"","text":"是不是从常常需要找电视机遥控器、机顶盒遥控器、空调遥控器等等遥控器呢。不知道放哪去了，一找就是找很久，有时候还真不知道放哪去了，找不到啊！是不是很痛苦。 偶然一次机会发现自己的小米手机有个自带的系统工具 “万能遥控” 如下：单击打开应用页面如下（这里已经添加两个遥控器请无视），点击左上角的加号这里就可以添加需要的遥控器啦，拿电视机来做示范。选择自己家电视机的型号打开电视机，点击是按上面的要求做，建议不要离电视机太远（3米内吧）选择是或者否保存遥控器好了！手机可以当电视遥控器使了，有手机再也不用找遥控器了。需要找手机的请给自己打个电话2333333","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"手机","slug":"手机","permalink":"https://www.hojun.cn/tags/手机/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"PS小白学切图","slug":"PS小白学切图","date":"2018-08-09T14:23:59.000Z","updated":"2018-08-11T15:24:49.292Z","comments":true,"path":"2018/08/09/PS小白学切图/","link":"","permalink":"https://www.hojun.cn/2018/08/09/PS小白学切图/","excerpt":"","text":"使用软件：PS CS6首先，我们先准备一张图（咳咳，这不是打广告）一般都会复制下图层在副本上面操作。然后找到我们的切片工具拿着小刀从一角按住直接对角线拉到另一角拉好后可以鼠标移到框上头调整大小再使用小刀（切片工具）切出第二个框如果这个时候突然想要调整上个切片的大小怎么办？我们可以使用》切片选择工具接着点击上一个切片，就又是可以调整大小的状态了最后我们来导出切片，点击文件，存储为web格式选择仅限图像，所有切片导出的切图如下图所示：完","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"ps","slug":"ps","permalink":"https://www.hojun.cn/tags/ps/"},{"name":"设计","slug":"设计","permalink":"https://www.hojun.cn/tags/设计/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"hexo评论系统之valine快速使用","slug":"hexo评论系统之valine快速使用","date":"2018-08-07T14:48:32.000Z","updated":"2018-08-11T15:24:48.704Z","comments":true,"path":"2018/08/07/hexo评论系统之valine快速使用/","link":"","permalink":"https://www.hojun.cn/2018/08/07/hexo评论系统之valine快速使用/","excerpt":"","text":"前言咳咳，昨天不是立了个每日签到的flag，再计算分值之后，用评论记录的时候，发现加载要很久。一言不合就动手换了它，加入valine评论系统阵营。 Valine来到其官网valine.js.org，(抠了1元钱打赏了作者，还是群里的群友)点击 快速开始嗯，需要注册LeanCloud，注册如下验证邮箱和绑定手机号然后点击创建应用&gt;开发版建好之后点击进入到应用中依次点击设置&gt;应用Key 得到App ID和App Key设置安全域名，可设可不设咯。舍得话要设自己博客域名哦（不要设博主的哦）注册好了，去valine官网找到demo直接插入到自己博客（hexo）评论模板那里123456789101112&lt;% if (config.valine &amp;&amp; page.comments) &#123; %&gt;&lt;script src=\"//cdn1.lncld.net/static/js/3.0.4/av-min.js\"&gt;&lt;/script&gt;&lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt;&lt;div id=\"vcomments\"&gt;&lt;/div&gt;&lt;script&gt; new Valine(&#123; el: '#vcomments', appId: \"&lt;%=config.v_appId %&gt;\", appKey: \"&lt;%=config.v_appKey %&gt;\" &#125;)&lt;/script&gt;&lt;% &#125; %&gt; 然后在配置里配置参数(_config.yml)1234# Valinevaline: truev_appId: xxxxxxv_appKey: xxxxxx OK，发布的时候可能还不能马上评论，等两分钟好啦~嗯。。。。。点下题，换的真的很快，大约半小时不到","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"好少年光芒万丈","slug":"好少年光芒万丈","date":"2018-08-06T05:18:10.000Z","updated":"2018-08-24T15:33:43.128Z","comments":true,"path":"2018/08/06/好少年光芒万丈/","link":"","permalink":"https://www.hojun.cn/2018/08/06/好少年光芒万丈/","excerpt":"","text":".ginput { display: inline-block !important; width: 50% !important; margin: 5px 0 5px 0; } .key{ display: inline-block !important; width: 25% !important; text-align: right; padding-right: 10px; } .toadyCount { margin-top: 10px; text-align: center; } .bubbles > .particle { opacity: 0; position: absolute; background-color: rgba(128,255,0,0.7); animation: bubbles 18s ease-in infinite; border-radius: 100%; } @keyframes bubbles { 0% { opacity: 0; } 5% { opacity: 1; transform: translate(0, -20%); } 100% { opacity: 0; transform: translate(0, -8000%); } } 夜走*5 锻炼*5 早睡*5 发布博文*10 音乐五首*1 动漫一话*2 电影一部*5 悦读30分钟*3 游戏30分钟*1 记单词10个*5 coding30分钟*5 学习视频30分钟*5 总分:0 每日打分后评论记录 ;(function(){ function calcCount(){ var count = 0; var item = ''; $(\".ginput\").each(function(){ if ($(this).val()) { item += $(this).attr('data-item') + '*' + $(this).val() + \"、\"; } count += Number($(this).val()) * Number($(this).attr('data-score')); }) return count + \"--\" + item; } $(\".ginput\").on(\"input propertychange change\",function(event){ $(\".toadyCount\").html('总分：' + calcCount()); }); })() function bubbles() { $.each($(\".particletext.bubbles\"), function(){ var bubblecount = ($(this).width()/50)*10; for(var i = 0; i","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"flag","slug":"flag","permalink":"https://www.hojun.cn/tags/flag/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"电脑开机自动发送邮件通知","slug":"电脑开机自动发送邮件通知","date":"2018-08-05T10:35:53.000Z","updated":"2018-08-11T15:24:46.603Z","comments":true,"path":"2018/08/05/电脑开机自动发送邮件通知/","link":"","permalink":"https://www.hojun.cn/2018/08/05/电脑开机自动发送邮件通知/","excerpt":"","text":"前言来自一位爸爸的需求，由于女儿在家会偷偷玩电脑，就想让hojun帮忙做个电脑开机就马上短信通知他的小程序。短信要钱，邮件免费，当然是选择邮件咯~ 当时就在网络上收索了一波，其中一种解决方案是使用一个小软件加windows的bat批处理命令实现开机自动发送邮件的功能。尝试下载这个软件结果直接被360检测成了病毒，直接给清理掉了。还有一种实现是通过windows的服务来实现的，略微看了一下。由于windows服务还真没接触过，就决定，花一个晚上的时间动手实现一下这个功能。 第一步 开发环境介绍windows电脑VisualStudio（博主用的2015）.Net framework4.0可以在 C:\\Windows\\Microsoft.NET\\Framework\\ 目录看下如下图：(可以发现1-4都有) 第二步 开发windows服务打开vs2015点击新建项目在Visual C#&gt;Windows&gt;经典桌面 下面，这里选择.NET Framework4(因为之前目录下有，我们这里选择有的)，再选择Windows服务。名称使用默认的，位置自己选择。点击确定-&gt;新建后如下图，我们在这个页面 右键&gt;添加安装程序会跳到这个页面，我们可以在控件上面 右键&gt;属性，也可以点击右侧解决方案资源管理器的属性栏更改其属性。这个给它的Account改为LocalSystem这里添加描述、名称，以及启动方式改为Auto开机自动安装配置好后，回到之前页面，点击蓝色字体跳转到代码视图默认给我们三个方法，一个构造方法、开始以及停止开始coding前，我们还要设置下我们的邮箱 第三步 准备邮箱授权码这里以QQ邮箱为例，点击设置&gt;账户&gt;点击开启POP3/SMTP服务，会叫你发送短信验证验证完后得到授权码 第四步 coding生成代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Diagnostics;using System.Linq;using System.Net;using System.Net.Mail;using System.Net.NetworkInformation;using System.ServiceProcess;using System.Text;using System.Threading;namespace AutoSendEmail&#123; public partial class Service1 : ServiceBase &#123; System.Timers.Timer createOrderTimer; public Service1() &#123; InitializeComponent(); &#125; protected override void OnStart(string[] args) &#123; createOrderTimer = new System.Timers.Timer(); createOrderTimer.Elapsed += new System.Timers.ElapsedEventHandler(Page_Load); createOrderTimer.Interval = 20000; createOrderTimer.Enabled = true; createOrderTimer.AutoReset = true; createOrderTimer.Start(); &#125; protected override void OnStop() &#123; &#125; protected void Page_Load(object sender, System.Timers.ElapsedEventArgs args) &#123; Ping ping = new Ping(); PingReply pr = ping.Send(&quot;baidu.com&quot;); if (pr.Status == IPStatus.Success) &#123; //实例化一个发送邮件类。 MailMessage mailMessage = new MailMessage(); //发件人邮箱地址，方法重载不同，可以根据需求自行选择。 mailMessage.From = new MailAddress(&quot;1234567890@qq.com&quot;); //收件人邮箱地址。 mailMessage.To.Add(new MailAddress(&quot;0987654321@qq.com&quot;)); //邮件标题。 mailMessage.Subject = &quot;电脑状态&quot;; //邮件内容。 mailMessage.Body = &quot;开机&quot;; //实例化一个SmtpClient类。 SmtpClient client = new SmtpClient(); //在这里我使用的是qq邮箱，所以是smtp.qq.com，如果你使用的是126邮箱，那么就是smtp.126.com。 client.Host = &quot;smtp.qq.com&quot;; //使用安全加密连接。 client.EnableSsl = true; //不和请求一块发送。 client.UseDefaultCredentials = false; //验证发件人身份(发件人的邮箱，邮箱里的生成授权码); client.Credentials = new NetworkCredential(&quot;1234567890@qq.com&quot;, &quot;xxxxxxxxxxxx&quot;); //发送 client.Send(mailMessage); //Context.Response.Write(&quot;发送成功&quot;); StopWindowsService(&quot;AutoSendEmail&quot;); &#125; &#125; /// &lt;summary&gt; /// 开启服务 /// &lt;/summary&gt; /// &lt;param name=&quot;windowsServiceName&quot;&gt;服务名称&lt;/param&gt; static void StartWindowsService(string windowsServiceName) &#123; using (System.ServiceProcess.ServiceController control = new System.ServiceProcess.ServiceController(windowsServiceName)) &#123; if (control.Status == System.ServiceProcess.ServiceControllerStatus.Stopped) &#123; Console.WriteLine(&quot;服务启动......&quot;); control.Start(); Console.WriteLine(&quot;服务已经启动......&quot;); &#125; else if (control.Status == System.ServiceProcess.ServiceControllerStatus.Running) &#123; Console.WriteLine(&quot;服务已经启动......&quot;); &#125; &#125; &#125; /// &lt;summary&gt; /// 停止服务 /// &lt;/summary&gt; /// &lt;param name=&quot;windowsServiceName&quot;&gt;服务名称&lt;/param&gt; static void StopWindowsService(string windowsServiceName) &#123; using (System.ServiceProcess.ServiceController control = new System.ServiceProcess.ServiceController(windowsServiceName)) &#123; if (control.Status == System.ServiceProcess.ServiceControllerStatus.Running) &#123; Console.WriteLine(&quot;服务停止......&quot;); control.Stop(); Console.WriteLine(&quot;服务已经停止......&quot;); &#125; else if (control.Status == System.ServiceProcess.ServiceControllerStatus.Stopped) &#123; Console.WriteLine(&quot;服务已经停止......&quot;); &#125; &#125; &#125; &#125;&#125; 代码完成后 右键&gt;生成在输出窗口拷贝生成目录在电脑中打开如下：在这个目录下新建两个txt文档，内容如下：安装.txt1234cd C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exe InstallUtil E:\\C#Workspace\\lab\\WindowsService1\\WindowsService1\\bin\\Debug\\WindowsService1.exepause 卸载.txt1234cd C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30319\\InstallUtil.exeInstallUtil.exe /u E:\\C#Workspace\\lab\\WindowsService1\\WindowsService1\\bin\\Debug\\WindowsService1.exepause 然后将其扩展名改为bat右键&gt;以管理员身份运行出现如下提示表示安装成功回到桌面，开始右键&gt;打开控制面板搜索服务，并打开按名称排序，找到我们的AutoSendEmail服务右键启动手机上收到邮件如下卸载的话也是右键&gt;以管理员身份运行 致谢杂记2：VS2013创建Windows服务实现自动发送邮件,作者：wuxiaochaoC#实现发送给QQ邮件,作者：谢尊旭Windows服务实现自动发送邮件通知,云栖社区，来源互联网","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"搞事","slug":"搞事","permalink":"https://www.hojun.cn/tags/搞事/"},{"name":"lab","slug":"lab","permalink":"https://www.hojun.cn/tags/lab/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"人大了，心小了","slug":"人大了，心小了","date":"2018-08-03T14:45:49.000Z","updated":"2018-08-11T15:24:51.237Z","comments":true,"path":"2018/08/03/人大了，心小了/","link":"","permalink":"https://www.hojun.cn/2018/08/03/人大了，心小了/","excerpt":"","text":"","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"欧阳明净","slug":"欧阳明净","date":"2018-08-03T13:59:02.000Z","updated":"2018-08-12T04:56:50.816Z","comments":true,"path":"2018/08/03/欧阳明净/","link":"","permalink":"https://www.hojun.cn/2018/08/03/欧阳明净/","excerpt":"","text":"乐律县的一家医院里，伴随着一声清脆的啼哭，一个新的生命来到了这个世界。 “是个男孩。”欧阳杰睁大了满是血丝的眼睛高声叫道。“快给我看看。”一个虚弱而又满怀兴奋的声音传来，躺在床上的费梅脸色苍白。但当她看到男孩洁白的小脸和纯净的眼神时，脸上便只剩下幸福。 对于这个普通的家庭而言，这个孩子的出身无疑是给了他们新的希望。欧阳夫妇共同经营一个便利店，这是他们一家人的收入，不仅要养活自己，还要抽出一部分给生病的老人。 “给他取个名吧”费梅幸福的笑着。“欧阳壮”欧阳杰的老父亲有些迫不及待的发表了自己的意见，他希望自己的小孙子健壮。“这怎么行，以后会被笑话的”欧阳杰无奈的笑笑。“不如叫欧阳明净吧，希望他以后做人做事正大光明，干干净净的。”这个名字得到了全家人的赞同，就这样决定了。 在场的人不会想到，这个寓意深远的名字往后变得家喻户晓 一晃眼12年过去了。 欧阳明净到了该读初中的年龄 本是如花般的年纪，欧阳明净的脸上却有着和同龄人不符的成熟。在这12年里，他没能享受和其他孩子一样的美好童年。从6岁起，在其他孩子进入小学的时候，小明净却只能帮家里看店。 “不行，必须要让他去上学”费梅倔强的对欧阳杰说。“可是我们没有钱”欧阳杰无奈的摊了摊手“难道你希望他像你这样过一辈子吗”费梅红了眼眶，泪水止不住的往外流，房间里陷入了沉默。 房门外欧阳明净暗暗下定了决心。他听说县政府为了响应国家的号召，决定组建一支由小孩组成的足球队，费用由县政府承担。在此之前明净根本不知道足球是什么，但他看见了这个公告，他明白，加入这支球队，就可以为家庭减轻负担，甚至能改变家庭的命运。 “爸爸，我想踢足球”明净推开房门，语气坚定。欧阳杰吃了一惊。随即哈哈大笑了起来“你知道什么是足球吗？”“让我去试试吧，反正报名免费。”明净坚持道。“那就让他试试吧。”费梅摇了摇欧阳杰的衣袖。“好吧，总比一直这样下去强”欧阳杰终于同意了。 这一刻，明净感受到了命运第一次对他微笑 第二天一大早明净和父母来到了乐律县中心体育场，远远的就看见一个个活泼的身影在绿茵场上奔跑，而在场边戴着棒球帽的那位将有权力觉得明净是否能够留下来。 “您好，我们听说足球队还在招收队员，带孩子来看看”欧阳杰语气谦卑的说道 “一边等着去吧，看看教练一会有没有时间。”工作人员深情倨傲。欧阳夫妇连连陪笑着带着明净站在了一边。这是明净又一次看到了这个社会的势利，他发誓会要改变自己的命运，让家人过上好日子。 “看来你们运气不错”刚才那名工作人员走过来“教练要见见你们。”欧阳夫妇连连称谢，仿佛这便是莫大的恩惠。教练叫闫成，是个中年人，满脸的沧桑，据说是以前踢过甲A的职业队员，心系家乡回到了自己生长的地方，为家乡足球尽一份力。 “几岁了，踢过球吗？”闫成先开口了。 “12了，没踢过呢。”欧阳杰有些心虚的低下了头 “没事，让我看看他的身体素质吧，我小时候家里也很穷懂你们现在的感受”闫成和蔼的拍拍小明净的肩膀，率先向外走去。 “好了小家伙，让我看看你的爆发力怎么样，准备好了吗？” “嗯”明净的声音不大，却满是坚定 一小时后…… “明天来训练吧小家伙”闫成有一丝疲惫，但更多的是满足。他没有告诉明净一家人，明净的各项测试数据超过了他12岁时的数据，这还是在明净没有训练的情况下。他认为这个孩子可塑性很好。","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"连载小说","slug":"连载小说","permalink":"https://www.hojun.cn/tags/连载小说/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"百度站长网站改版踩坑记","slug":"百度站长网站改版踩坑记","date":"2018-08-01T15:44:31.000Z","updated":"2018-08-11T15:24:46.638Z","comments":true,"path":"2018/08/01/百度站长网站改版踩坑记/","link":"","permalink":"https://www.hojun.cn/2018/08/01/百度站长网站改版踩坑记/","excerpt":"","text":"这篇文章记录下使用百度搜索资源平台的网站改版功能使用过程中踩过的各种坑。 前言博主用的是hexo+github搭建的个人博客改版原因： github不允许百度蜘蛛爬它 github最近是不是提交不去（怀疑被墙） 改版前提条件首先有个百度账号，下边有两个认证过的域名。（博主之前有认证过，这篇文章就不介绍认证步骤） 网站改版点击：百度搜索资源平台》网站支持》提交链接滚动到底部，找到网站改版第一次随便填了下两个域名（coding和www的）失败如下：于是看了下改版说明：因为是githubpages搭建的，并无服务器，于是弄了份js跳转的，注意这种跳转的http状态码还是200（死马当活马医）。1234&lt;script language=javascript&gt; if (document.domain =='coding.hojun.cn') this.location = \"https://www.hojun.cn\" + this.location.pathname + this.location.search; &lt;/script&gt; 失败如下+1错误原因： 使用cloudflare添加301重定向怎么使用Cloudflare可以参照博主的另一篇文章这里我们使用它提供的Page Rules点击添加：注意一个是/*，而另一个是/$1然后试着访问coding的域名，可以看出已经是301的方式跳转了再次提交改版（注意要先删掉失败的）恭喜成功^_^","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"seo","slug":"seo","permalink":"https://www.hojun.cn/tags/seo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Hexo入住熊掌号之添加JSON_LD数据结构","slug":"Hexo入住熊掌号之添加JSON-LD数据结构","date":"2018-07-30T17:23:21.000Z","updated":"2018-08-11T15:24:48.562Z","comments":true,"path":"2018/07/31/Hexo入住熊掌号之添加JSON-LD数据结构/","link":"","permalink":"https://www.hojun.cn/2018/07/31/Hexo入住熊掌号之添加JSON-LD数据结构/","excerpt":"","text":"百度搜索熊掌号，点击上面的和下面的是两个后台。这个觉得有些像微信公众号的模式。一开始这个主页装修是打不开的，下面的配置了才能打开(不知道是不是我网卡了)下面的是是搜索资源平台，打开如下：点击右边的熊掌号，嗯~怎么搞的有点忘记了。等我想记录的时候已经突破新手期了。。。。突破新手主要就是做任务，其中学习任务类送分（了解粉丝那里要点击复制代码触发），绑定类的是送分，https之前就有送分，（任务在数据统计-&gt;熊掌号搜索指数里的可以查看）下面具体说下JSON-LD，什么是JSON_LD维基百科：1JSON-LD（关联数据的JavaScript对象表示法）是一种使用JSON编码关联数据的方法。这是一个目标，要求开发人员尽可能少地将他们现有的JSON转换为JSON-LD。[1]这允许以类似于传统JSON的方式序列化数据。[2]这是一个万维网联盟建议书。它最初由JSON for Linking Data Community。Group开发，然后转移到RDF工作组[3]进行审查，改进和标准化。[4] 嗯说了一堆看不懂的……找啊找啊，找到说人话的了：编码由Schema.org [6]，Google Knowledge Graph [7]使用，主要用于搜索引擎优化活动。额，就是用于搜索引擎优化的咯…按熊掌号的要求改代码：(要求在号主页展示中)校验工具在粉丝关注-&gt;在线校验工具里第一种报错，存在空行：（报错截图没保存，将就下）要改成这种没空行的，加在head标签中。下面给出hexo中的ejs版的修改代码：1234567891011&lt;script type=\"application/ld+json\"&gt;&#123; \"@context\": \"https://ziyuan.baidu.com/contexts/cambrian.jsonld\", \"@id\": \"https://www.hojun.com&lt;%=url_for(page.path) %&gt;\", \"appid\": \"xxxxxxxxxxxx\",&lt;% if (page.title)&#123; %&gt; \"title\": \"&lt;%= page.title %&gt;\",&lt;% &#125; else &#123;%&gt;\"title\": \"hojun-好少年光芒万丈\", \"images\": ['https://wx1.sinaimg.cn/large/006bYVyvgy1ftand2qurdj303c03cdfv.jpg'],&lt;% &#125; %&gt;&lt;% if (page.photos &amp;&amp; page.photos.length)&#123; %&gt; \"images\": [\"&lt;%= page.photos[0] %&gt;\"],&lt;% &#125; %&gt; \"pubDate\": \"&lt;%= date(page.date, 'YYYY-MM-DDThh:mm:ss') %&gt;\"&#125;&lt;/script&gt; 接着有碰到这种错误这么改：顺带加上这个：还有可能碰到这种报错：原因是在地址栏复制url的时候把中文转码了，我们直接复制下面$id里的值粘贴进去就行校验成功！未完待续……To be Continued……","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"距离玩BeatSaber还差...","slug":"距离玩BeatSaber还差","date":"2018-07-26T15:12:31.000Z","updated":"2018-08-11T15:24:47.460Z","comments":true,"path":"2018/07/26/距离玩BeatSaber还差/","link":"","permalink":"https://www.hojun.cn/2018/07/26/距离玩BeatSaber还差/","excerpt":"","text":"以前一直有一种想法，开发出一种玩出实际价值的游戏……BeatSaber的出现感觉那奇葩想法好像能实现，据说这游戏的锻炼效果比打网球还好~ #distance2{ font-size:2.5em; color:#ffffff; } #distance2{ -webkit-animation: neon1 1.5s ease-in-out infinite alternate; -moz-animation: neon1 1.5s ease-in-out infinite alternate; animation: neon1 1.5s ease-in-out infinite alternate; } #distance1{ font-size:2.5em; color:#ffffff; } #distance1{ -webkit-animation: neon2 1.5s ease-in-out infinite alternate; -moz-animation: neon2 1.5s ease-in-out infinite alternate; animation: neon2 1.5s ease-in-out infinite alternate; } @-webkit-keyframes neon1 { from { text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #FF1177, 0 0 70px #FF1177, 0 0 80px #FF1177, 0 0 100px #FF1177, 0 0 150px #FF1177; } to { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #fff, 0 0 20px #FF1177, 0 0 35px #FF1177, 0 0 40px #FF1177, 0 0 50px #FF1177, 0 0 75px #FF1177; } } @-webkit-keyframes neon2 { from { text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #228DFF, 0 0 70px #228DFF, 0 0 80px #228DFF, 0 0 100px #228DFF, 0 0 150px #228DFF; } to { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 15px #fff, 0 0 20px #228DFF, 0 0 35px #228DFF, 0 0 40px #228DFF, 0 0 50px #228DFF, 0 0 75px #228DFF; } } 您的浏览器不支持 video 属性。 距离玩BeatSaber还差: &nbsp; let total = 4000; let bjh = 9.78; let tth = 27.13; let wbhb = 21.89; let distance = total - bjh - tth - wbhb; document.getElementById('distance2').innerHTML = distance + '￥';","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"flag","slug":"flag","permalink":"https://www.hojun.cn/tags/flag/"},{"name":"game","slug":"game","permalink":"https://www.hojun.cn/tags/game/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"HEXO发布到Github报错?凉凉,迁移到Coding","slug":"HEXO发布到Github报错-凉凉-迁移到Coding","date":"2018-07-23T13:58:58.000Z","updated":"2018-08-11T15:24:48.669Z","comments":true,"path":"2018/07/23/HEXO发布到Github报错-凉凉-迁移到Coding/","link":"","permalink":"https://www.hojun.cn/2018/07/23/HEXO发布到Github报错-凉凉-迁移到Coding/","excerpt":"","text":"前言前几日的时候。hexo群里好多人发现hexo d报错，博主亲测结果如下：改为https提交还是报错：测试SSH key是成功的。浏览器访问github也还能访问。注释掉github地址，仅使用coding。轻易提交成功配置如下：1234567deploy: type: git repo: # github: git@github.com:honjun/honjun.github.io.git # github: https://github.com/honjun/honjun.github.io.git coding: https://git.coding.net/hojun/hojun.git branch: master 估计github被墙，凉凉。算了，选择迁移到coding。 教程之前有写过，不过考虑到读者方便，copy过来 第一步：注册codingcoding.net注册流程略。。。。注册完成后先别急，如果你有自己购买的域名。需要把账号升级至银牌会员(只需完善信息，不收money) 第二步：新建项目升级成功后新建项目注意事项: 项目名要和用户名一致 要选择公开 第三步：配置创建好项目后在个人设置里面添加SSH公钥，可以参照帮助文档配置 SSH 公钥访问代码仓库然后复制项目的https或git到hexo的配置文件_config.yml(注意，冒号后面要有个空格)如：123456deploy: type: git repo: github: https://github.com/honjun/honjun.github.io.git coding: https://git.coding.net/hojun/hojun.git branch: master 第四步：开启Pages服务cmd运行hexo g,hexo d在Coding的项目中打开Pages服务-&gt;静态Pages,部署来源-master分支就可以在coding.yourname.me看到你部署好的博客了 第五步：绑定自定义域名在域名解析添加一条CNAME记录即可，如绑定二级域名xxx.你的域名.xx等待生效，一般12小时左右回到项目代码下，新建CNAME文件，内容为1xxx.你的域名.xx 再在Coding Pages服务里面绑定自定义域名接下来在hexo模板的footer下放置「Hosted by Coding Pages」迁移完毕…… 26日更新，github可以提交了……","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"细说网页开发者工具F12-前端开发利器三","slug":"细说网页开发者工具F12-前端开发利器三","date":"2018-07-19T15:40:07.000Z","updated":"2018-08-11T15:24:46.763Z","comments":true,"path":"2018/07/19/细说网页开发者工具F12-前端开发利器三/","link":"","permalink":"https://www.hojun.cn/2018/07/19/细说网页开发者工具F12-前端开发利器三/","excerpt":"","text":"前言写这篇文章是细说网页开发者工具F12 - 前端开发利器三，Network篇，若觉得不错请关注作者。哎，是时候让人类感受黑暗的恐惧了！……居然停电了。这次我们来细说F12工具的Network面板。功能有些多，我们从上往下来介绍，首先是记录network的开关，默认为打开状态。第二个Clear按钮，可以清除记录下来的Network内容。第三个是捕获网页加载截图(Capture Screenshots)。可以记录每次的页面有新加载的时候的截图。可以通过这个截图了解页面的具体显示过程。第四个是Filter滤镜功能，就是提供下面红框框起来的功能的。下文在详细介绍第五个是显示request(请求)列表的样式的按钮，提供大和小(large|small)两种。下图的选择大的样式下图是显示小的样式第六个是总的概览图(咳咳，作用未知。知道的小伙伴欢迎留言)第七个是Group by frame(咳咳，作用未知。知道的小伙伴欢迎留言)第八个是Preserve log。勾选这个按钮可以保存network不被页面刷新清除。下图是我们勾选Preserve log刷新四次的效果，可以看到四次network的记录第九个是Disable cache(禁用缓存)。功能就是禁用本地缓存，强制刷新第十个是离线，效果如下，就是断网状态。 Filder接下来细说Filder，第一个作用未知，咳咳第二个All表示显示所有类型的requestXHR表示显示xhr请求，就是常说的ajax。js,css,img,media,font略过，doc表示document接下来我们打开一个请求，第一栏是header,这里有请求头和响应头数据。(写爬虫的时候经常用到)Preview，表示响应预览。doc的就是显示的代码，若是图片，就可以看到预览图。Response表示返回值，doc的还是显示的代码，有一些会返回的json格式。比如一言接口的返回值。Timing,记录着整个请求的时间段还有一个是Cookie,记录这request请求发送和接收到的cookie未完待续……Continued……","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"网页开发者工具","slug":"网页开发者工具","permalink":"https://www.hojun.cn/tags/网页开发者工具/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"细说网页开发者工具F12-前端开发利器二","slug":"细说网页开发者工具F12-前端开发利器二","date":"2018-07-15T14:30:18.000Z","updated":"2018-08-11T15:24:46.792Z","comments":true,"path":"2018/07/15/细说网页开发者工具F12-前端开发利器二/","link":"","permalink":"https://www.hojun.cn/2018/07/15/细说网页开发者工具F12-前端开发利器二/","excerpt":"","text":"前言写这篇文章是细说网页开发者工具F12 - 前端开发利器的第二篇文章，若觉得不错请关注作者。 F12之Console就是位于Elemnets右边的，打开后你会发现什么都没有我们试着进入到友链页面，发现console面板出现了一些警告。这是因为在https域名下使用http的资源引起的警告。为了更好的示范，我们这里新建一个html文件，代码如下我们可以看出js的console.log方法可以在console面板输出内容这里我们尝试书写错误的语法，console面板会报错，显示错误信息以及错误所在的行号我们还可以直接在console面板直接编写我们的js代码。在百度首页打开console面板还可以看见百度的招聘信息。 F12之SourcesSources面板下可以看到网页加载的各种资源，这里我们看到除了本域名下的资源，还加载了百度的统计，还有新浪微博的相册。通过这个面板我们可以管理网站是否有用到其他网站的资源 未完待续……Continued……","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"网页开发者工具","slug":"网页开发者工具","permalink":"https://www.hojun.cn/tags/网页开发者工具/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"细说网页开发者工具F12-前端开发利器一","slug":"细说网页开发者工具F12-前端开发利器一","date":"2018-07-12T13:57:52.000Z","updated":"2018-08-11T15:24:46.726Z","comments":true,"path":"2018/07/12/细说网页开发者工具F12-前端开发利器一/","link":"","permalink":"https://www.hojun.cn/2018/07/12/细说网页开发者工具F12-前端开发利器一/","excerpt":"","text":"网页开发者工具之 Elements前言写这篇文章的目的主要是为了帮助前端小白，学习使用浏览器自带的F12网页开发者工具，来快速定位调试分析问题、解决问题。当然这仅是作者的个人学习心得，有不足之处欢迎大家指点。由于篇幅有限，这篇文章仅介绍Elements。若觉得不错请关注作者的后续更新。 如何在F12工具中定位元素这里拿我的博客作为网页、用Chrome谷歌浏览器作为例子。打开网页，按下键盘上的F12键。点击Elements栏，选择body元素，如下图： 1.左边用半透明蓝色覆盖表示被选区域，仔细看左下角还有个标志显示元素名称和宽高。2.中部内容就是Elements，即页面元素。看图可以发现我们选择了body元素3.右侧区域为Style，即css样式,显示的是被选元素对应的css。这样就非常方便我们调试样式。 这里我们假设有个需求，需要右边头像的元素代码和css演示。我们不需要右键查看源代码（早期有些教程会使用这个方法）。可以使用F12工具的左上角的指针工具 1.鼠标左键单击指针工具，单击后工具会变为蓝色状态2.移动鼠标到头像上，你会发现自动出现蓝色半透明选框。会显示元素标签和宽高3.点击确认后，你会发现中部Elements会自动定位到头像代码，右边Style也会自动定位到头像的css样式 4.在中部选择元素后，可以右键复制代码。5.在左侧的Style面板中，点击css右边的css文件名也可以定位到个css文件中的具体位置 但是有些特殊的样式需要鼠标到达某一特殊位置的时候才会触发，我们再去点指针的时候就会回到原位。（比如博客右侧的小埋，需要鼠标hover才能触发）。我们可以将鼠标移上去后，按快捷键Ctrl+Shift+C直接使用指针工具。就可以获取这些特殊样式的css代码 还有些时候，我们需要搜索页面中的某些内容。在中部Elements中使用Ctrl+F打开搜索框：如图我们搜索“一个好”就得到的想要的元素位置。 F12工具中的盒子模型还有个东西这里提一下，选择任意一个元素，在右边的Style面板下拉倒最下面，都可以看到我们的盒子模型(网页设计中常听的属性名：内容(content)、内边距(padding)、边框(border)、外边距(margin)。这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来理解，所以叫它盒子模式。)这里可以看出padding的值这个是margin值 如何在F12工具中直接修改页面比如我们要修改下面这个标题直接在Element面板下，双击修改其文本的内容（这里改成余额好多钱，是不是以后都不能相信截图了）接下来尝试修改其css，我们选择修改其字体颜色和大小直接在Style面板下修改：颜色改成红色，字体调大至32px。效果如下我们也可以直接新加css元素，比如加个border(边框)。 移动端开发若是要调试移动端页面怎么办？我们只要点击指标工具右边的移动端工具就行，其他的和pc端一样。效果如下： 最后的也是最重要的事不要在他人电脑上不使用浏览器的记住密码功能！不使用浏览器的记住密码功能！不使用浏览器的记住密码功能！不使用浏览器的记住密码功能！ 为什么？这里作者来举个有道云笔记的栗子：这是作者使用浏览器保密码的有道云笔记的登录页面，你可以看到浏览器默认给你填充好了账号和密码。密码使用···号表示并不可见。但是，我们打开F12工具:用指针工具选择密码框。只要将其input的输入框的type=”password”值改为type=”text”，你的密码就暴露无遗","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"网页开发者工具","slug":"网页开发者工具","permalink":"https://www.hojun.cn/tags/网页开发者工具/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Fiddler小白入门","slug":"Fiddler小白入门","date":"2018-07-11T11:03:42.000Z","updated":"2018-08-11T15:24:48.375Z","comments":true,"path":"2018/07/11/Fiddler小白入门/","link":"","permalink":"https://www.hojun.cn/2018/07/11/Fiddler小白入门/","excerpt":"","text":"什么是Fiddler百度百科：Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指 cookie ,html,js,css等文件）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式。 咳咳，年初玩微信跳一跳的时候知道了有人用Fiddler直接改成绩的时候，就想学习使用一下Fiddler。一直到今天才正式接触Fiddler，不要问我中间那段时间去干了什么w(ﾟДﾟ)w，我也很震惊！ 第一步 安装Fiddler百度fiddler，点击进入其官网点击右下角Free download(免费下载)下载页面如下，需要我们填写问卷后下载1、你准备使用Fiddler来做什么？ 2、你的邮箱地址？ 3、你来自哪个国家？填好后点击Download for Windows下载，自动跳转下载下载好后双击安装默认安装在C盘，我们可以自定义到其他盘 第二步 Fiddler设置安装好后打开Fiddler，页面如下单击tools，选择optionshttps勾选如下Connections勾选如下，端口我这里设置成5555（默认为8888）设置更改好了，记得重新启动Fiddler生效 第三步 手机设置代理打开cmd命令行程序，输入ipconfig命令，回车获取内网IP（注意博主的情况是电脑和手机都连家里的无线网，同一个无线网）打开手机设置，选择WLAN长按选择修改网络点击显示高级选项点击代理，选择手动设置地址为电脑的ip地址，端口为5555 第四步 手机安装Fiddler证书打开浏览器，输入你电脑的ip+端口号点击下载证书下载好后，来到WLAN设置，选择更多-&gt;高级WLAN设置点击安装证书进入到证书下载的路径下，点击证书证书这里不要选择WLAN，不然在应用中打开会显示证书错误应该选择VPN和应用 第五步 Fiddler抓取网页和APP数据(微信跳一跳)设置好后用浏览器访问博主博客Fiddler抓取如下点击叉叉，选择Remove All清除抓取的内容打开微信玩一把跳一跳Fiddler抓取如下，根据分数和历史最高分可知，这个请求就是上传分数的 Fiddler小白入门到此为止……","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"抓包","slug":"抓包","permalink":"https://www.hojun.cn/tags/抓包/"},{"name":"分析","slug":"分析","permalink":"https://www.hojun.cn/tags/分析/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"2018软考成绩查询！","slug":"2018软考成绩查询！","date":"2018-07-07T12:52:14.000Z","updated":"2018-08-11T15:24:48.049Z","comments":true,"path":"2018/07/07/2018软考成绩查询！/","link":"","permalink":"https://www.hojun.cn/2018/07/07/2018软考成绩查询！/","excerpt":"","text":"软考成绩可以查询了！软考成绩可以查询了！软考成绩可以查询了！重要的事情说3遍，昨天下午（7.6）在盆友圈里看见好友在晒软考成绩。看过我之前的《软考之软件设计师经验总结》的盆友应该知道博主在前段时间参加了软考-软件设计师的考试。 知道了这个消息当然是第一时间去查询：点击进入中国计算机技术职业资格网点击查询服务-&gt;成绩查询区呃……尴尬了，没有18上半年的？在尝试下浙江软考成绩管理哈哈哈，功夫不负有心人可以看到有2018年的成绩查询可以选择按证件使用身份证号查询运气不错，贴地擦过没查成绩的小伙伴赶紧去吧！祝大家都过~","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://www.hojun.cn/tags/软考/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"给博客添加文章目录","slug":"给博客添加文章目录","date":"2018-07-03T15:20:53.000Z","updated":"2018-08-11T15:24:47.065Z","comments":true,"path":"2018/07/03/给博客添加文章目录/","link":"","permalink":"https://www.hojun.cn/2018/07/03/给博客添加文章目录/","excerpt":"","text":"前言因为JSimple主题没有自带目录，所以需要自己动手给hexo博客文章添加目录功能。 第一步 查阅hexo文档在Hexo官网 文档&gt;自定义&gt;辅助函数&gt;最下面，可以找到toc这个函数，看其介绍能知道它就是来实现文章目录的。 第二步 决定目录位置根据博客浏览文章的页面，决定将目录放在右上角空白处。 第三步 编写主题模板首先，找到文章模板页面，博主这里是在\\themes\\jsimple\\layout_widget\\common-article.ejs这个文件中，插入需要的代码。（因为toc需要post变量，所以我们把post传入）这里博主采用的是局部模板和局部变量，把目录当成一块独立的组件分离了出去。（你也可以不用分离，直接在当前文件中写详细的代码）既然用到了局部模板，我们就要新建一个toc.ejs的模板，其中插入的代码如下：1234567&lt;aside id=\"article-toc\" role=\"navigation\" class=\"fixed\"&gt; &lt;div id=\"article-toc-inner\"&gt; &lt;strong class=\"sidebar-title\"&gt; 目录&lt;/strong&gt; &lt;%- toc(post.content, &#123;list_number: false&#125;) %&gt; &lt;/div&gt;&lt;/aside&gt; 其中，list_number: false表示目录不显示编号。出来html标签，我们还需要css样式来布局目录的位置大小等。css如下：12345678910111213141516171819202122232425262728293031323334353637383940414243#article-toc-inner:after,#article-toc-inner:before,.inner:after,.inner:before &#123; content: \"\"; display: table&#125;#article-toc-inner:after,.inner:after &#123; clear: both&#125;@media screen &#123; #article-toc-inner,.inner &#123; padding: 0 20px &#125;&#125;#article-toc &#123; display: none; float: right; width: 25%; margin-right: -220px; opacity: .8&#125;@media screen and (min-width:769px) &#123; #article-toc &#123; display: block &#125;&#125;#article-toc.fixed &#123; position: absolute; top: 0; bottom: 0; right: 220px; padding-top: 55px;&#125;.fixed #article-toc-inner &#123; position: fixed; width: 220px; top: 0; bottom: 0; padding-top: 55px;&#125;#article-toc-inner ol &#123; margin-left: -16px;&#125; 将css引入页面即可。 效果预览","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"给博客添加上一篇下一篇功能","slug":"给博客添加上一篇下一篇功能","date":"2018-06-23T10:23:40.000Z","updated":"2018-08-11T15:24:46.965Z","comments":true,"path":"2018/06/23/给博客添加上一篇下一篇功能/","link":"","permalink":"https://www.hojun.cn/2018/06/23/给博客添加上一篇下一篇功能/","excerpt":"","text":"前言发现其他主题有上一篇下一篇的功能，于是就给自己用的主题也加了一个。就是这样子~喵 实现废话不多说，直接开始实现。 第一步 copy代码当然是去有的博客上面去抄代码啊(抄作业什么的最擅长了)找了个用next的友链博客，嗯…可以去我友链看随便打开一片文章，按F12打开开发者工具。使用左上角的指针工具选择到上一篇下一篇元素的代码，右键copy代码得到的代码如下：12345678910111213&lt;div class=\"post-nav\"&gt; &lt;div class=\"post-nav-next post-nav-item\"&gt; &lt;a href=\"/live_16/\" rel=\"next\" title=\"杂感\"&gt; &lt;i class=\"fa fa-chevron-left\"&gt;&lt;/i&gt; 杂感 &lt;/a&gt; &lt;/div&gt; &lt;span class=\"post-nav-divider\"&gt;&lt;/span&gt; &lt;div class=\"post-nav-prev post-nav-item\"&gt; &lt;a href=\"/live_18/\" rel=\"prev\" title=\"英语四级，我是来搞笑的\"&gt; 英语四级，我是来搞笑的 &lt;i class=\"fa fa-chevron-right\"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt;&lt;/div&gt; 第二步 修改代码根据自己主题修改成模板的ejs代码如下：123456789101112&lt;div class=\"post-nav\"&gt; &lt;% if (post.prev)&#123; %&gt; &lt;div class=\"post-nav-prev post-nav-item\"&gt; &lt;a href=\"&lt;%- url_for(post.prev.path) %&gt;\" &gt;&lt;%= post.prev.title %&gt;&lt;i class=\"fa fa-chevron-left\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt; &lt;% if (post.next)&#123; %&gt; &lt;div class=\"post-nav-next post-nav-item\"&gt; &lt;a href=\"&lt;%- url_for(post.next.path) %&gt;\" &gt;&lt;%= post.next.title %&gt;&lt;i class=\"fa fa-chevron-right\"&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; &lt;% &#125; %&gt;&lt;/div&gt; 插入到渲染文章的模板中，作者hojun的是在themes\\jsimple\\layout_widget\\common-article.ejs这个文件里。 第三步 增加样式继续使用F12来抄css，从父级抄到子级(有些不需要的看情况)稍微改了一下：12345678910111213141516171819202122232425262728293031323334353637.post-nav&#123; display: flex;&#125;.post-nav-item &#123; flex: 1; padding: 10px 0 0 0; vertical-align: top;&#125;.post-nav-next a &#123; padding-right: 15px; text-align: right;&#125;.post-nav-prev a &#123; padding-left: 15px;&#125;.post-nav-item a &#123; position: relative; display: block; line-height: 25px; font-size: 14px; color: #555; border-bottom: none;&#125;.post-nav-prev .fa &#123; position: absolute; left: 0; top: 30%; font-size: 12px; line-height: 100%;&#125;.post-nav-next .fa&#123; position: absolute; right: 0; top: 30%; font-size: 12px; line-height: 100%;&#125; 把css加到页面中即可 第四步 oooooook了查看效果：","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js深入篇(六、混合)","slug":"vue-js深入篇-六、混合","date":"2018-06-21T11:08:53.000Z","updated":"2018-08-11T15:24:50.571Z","comments":true,"path":"2018/06/21/vue-js深入篇-六、混合/","link":"","permalink":"https://www.hojun.cn/2018/06/21/vue-js深入篇-六、混合/","excerpt":"","text":"基础混合是一种灵活的分布式复用 Vue 组件的方式。混合对象可以包含任意组件选项。以组件使用混合对象时，所有混合对象的选项将被混入该组件本身的选项。 例子：12345678910111213141516// 定义一个混合对象var myMixin = &#123; created: function () &#123; this.hello() &#125;, methods: &#123; hello: function () &#123; console.log('hello from mixin!') &#125; &#125;&#125;// 定义一个使用混合对象的组件var Component = Vue.extend(&#123; mixins: [myMixin]&#125;)var component = new Component() // -&gt; \"hello from mixin!\" 选项合并当组件和混合对象含有同名选项时，这些选项将以恰当的方式混合。比如，同名钩子函数将混合为一个数组，因此都将被调用。另外，混合对象的 钩子将在组件自身钩子 之前 调用 ：12345678910111213var mixin = &#123; created: function () &#123; console.log('mixin hook called') &#125;&#125;new Vue(&#123; mixins: [mixin], created: function () &#123; console.log('component hook called') &#125;&#125;)// -&gt; \"混合对象的钩子被调用\"// -&gt; \"组件钩子被调用\" 值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。 两个对象键名冲突时，取组件对象的键值对。123456789101112131415161718192021222324var mixin = &#123; methods: &#123; foo: function () &#123; console.log('foo') &#125;, conflicting: function () &#123; console.log('from mixin') &#125; &#125;&#125;var vm = new Vue(&#123; mixins: [mixin], methods: &#123; bar: function () &#123; console.log('bar') &#125;, conflicting: function () &#123; console.log('from self') &#125; &#125;&#125;)vm.foo() // -&gt; \"foo\"vm.bar() // -&gt; \"bar\"vm.conflicting() // -&gt; \"from self\" 注意： Vue.extend() 也使用同样的策略进行合并。 全局混合也可以全局注册混合对象。 注意使用！ 一旦使用全局混合对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。12345678910111213// 为自定义的选项 'myOption' 注入一个处理器。 Vue.mixin(&#123; created: function () &#123; var myOption = this.$options.myOption if (myOption) &#123; console.log(myOption) &#125; &#125;&#125;)new Vue(&#123; myOption: 'hello!'&#125;)// -&gt; \"hello!\" 谨慎使用全局混合对象，因为会影响到每个单独创建的 Vue 实例（包括第三方模板）。大多数情况下，只应当应用于自定义选项，就像上面示例一样。 也可以将其用作 Plugins 以避免产生重复应用 自定义选项混合策略自定义选项将使用默认策略，即简单地覆盖已有值。 如果想让自定义选项以自定义逻辑混合，可以向 Vue.config.optionMergeStrategies 添加一个函数：123Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) &#123; // return mergedVal&#125; 对于大多数对象选项，可以使用 methods 的合并策略:12var strategies = Vue.config.optionMergeStrategiesstrategies.myOption = strategies.methods 更多高级的例子可以在 Vuex 1.x的混合策略里找到:12345678910const merge = Vue.config.optionMergeStrategies.computedVue.config.optionMergeStrategies.vuex = function (toVal, fromVal) &#123; if (!toVal) return fromVal if (!fromVal) return toVal return &#123; getters: merge(toVal.getters, fromVal.getters), state: merge(toVal.state, fromVal.state), actions: merge(toVal.actions, fromVal.actions) &#125;&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js深入篇(五、自定义指令)","slug":"vue-js深入篇-五、自定义指令","date":"2018-06-21T11:08:25.000Z","updated":"2018-08-11T15:24:50.538Z","comments":true,"path":"2018/06/21/vue-js深入篇-五、自定义指令/","link":"","permalink":"https://www.hojun.cn/2018/06/21/vue-js深入篇-五、自定义指令/","excerpt":"","text":"简介除了默认设置的核心指令( v-model 和 v-show ),Vue 也允许注册自定义指令。注意，在 Vue2.0 里面，代码复用的主要形式和抽象是组件——然而，有的情况下,你仍然需要对纯 DOM 元素进行底层操作,这时候就会用到自定义指令。 下面这个例子将聚焦一个 input 元素，像这样：123456789101112131415161718&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;div id=\"simplest-directive-example\" class=\"demo\"&gt; &lt;input v-focus=\"\"&gt;&lt;/div&gt;&lt;script&gt;// 注册一个全局自定义指令 v-focusVue.directive('focus', &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;)new Vue(&#123; el: '#simplest-directive-example'&#125;)&lt;/script&gt; 当页面加载时，元素将获得焦点。事实上，你访问后还没点击任何内容，input 就获得了焦点。现在让我们完善这个指令：也可以注册局部指令，组件中接受一个 directives 的选项：12345directives: &#123; focus: &#123; // 指令的定义--- &#125;&#125; 然后你可以在模板中任何元素上使用新的 v-focus 属性：1&lt;input v-focus&gt; 钩子函数指令定义函数提供了几个钩子函数（可选）： bind: 只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个在绑定时执行一次的初始化动作。 inserted: 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于 document 中）。 update: 被绑定元素所在的模板更新时调用，而不论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新（详细的钩子函数参数见下）。 componentUpdated: 被绑定元素所在模板完成一次更新周期时调用。 unbind: 只调用一次， 指令与元素解绑时调用。 接下来我们来看一下钩子函数的参数 (包括 el，binding，vnode，oldVnode) 。 钩子函数参数钩子函数被赋予了以下参数： el: 指令所绑定的元素，可以用来直接操作 DOM 。 binding: 一个对象，包含以下属性： name: 指令名，不包括 v- 前缀。 value: 指令的绑定值， 例如： v-my-directive=”1 + 1”, value 的值是 2。 oldValue: 指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。 expression: 绑定值的字符串形式。 例如 v-my-directive=”1 + 1” ，expression 的值是 “1 + 1”。 arg: 传给指令的参数。例如 v-my-directive:foo， arg 的值是 “foo”。 modifiers: 一个包含修饰符的对象。 例如： v-my-directive.foo.bar, 修饰符对象 modifiers 的值是 { foo: true, bar: true }。 vnode: Vue 编译生成的虚拟节点，查阅 VNode API 了解更多详情。oldVnode: 上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。除了 el 之外，其它参数都应该是只读的，尽量不要修改他们。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行。 一个使用了这些参数的自定义钩子样例：1234567891011121314151617181920212223&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;div id=\"hook-arguments-example\" v-demo:hello.a.b=\"message\" class=\"demo\"&gt;&lt;/div&gt;&lt;script&gt;Vue.directive('demo', &#123; bind: function (el, binding, vnode) &#123; var s = JSON.stringify el.innerHTML = 'name: ' + s(binding.name) + '&lt;br&gt;' + 'value: ' + s(binding.value) + '&lt;br&gt;' + 'expression: ' + s(binding.expression) + '&lt;br&gt;' + 'argument: ' + s(binding.arg) + '&lt;br&gt;' + 'modifiers: ' + s(binding.modifiers) + '&lt;br&gt;' + 'vnode keys: ' + Object.keys(vnode).join(', ') &#125;&#125;)new Vue(&#123; el: '#hook-arguments-example', data: &#123; message: 'hello!' &#125;&#125;)&lt;/script&gt; 函数简写大多数情况下，我们可能想在 bind 和 update 钩子上做重复动作，并且不想关心其它的钩子函数。可以这样写:123Vue.directive('color-swatch', function (el, binding) &#123; el.style.backgroundColor = binding.value&#125;) 对象字面量如果指令需要多个值，可以传入一个 JavaScript 对象字面量。记住，指令函数能够接受所有合法类型的 Javascript 表达式。123456&lt;div v-demo=\"&#123; color: 'white', text: 'hello!' &#125;\"&gt;&lt;/div&gt;Vue.directive('demo', function (el, binding) &#123; console.log(binding.value.color) // =&gt; \"white\" console.log(binding.value.text) // =&gt; \"hello!\"&#125;)","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js深入篇(四、Render函数)","slug":"vue-js深入篇-四、Render函数","date":"2018-06-20T12:37:15.000Z","updated":"2018-08-11T15:24:50.615Z","comments":true,"path":"2018/06/20/vue-js深入篇-四、Render函数/","link":"","permalink":"https://www.hojun.cn/2018/06/20/vue-js深入篇-四、Render函数/","excerpt":"","text":"基础Vue 推荐使用在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，你真的需要 JavaScript 的完全编程的能力，这就是 render 函数，它比 template 更接近编译器。 让我们先深入一个使用 render 函数的简单例子，假设你想生成一个带锚链接的标题：12345&lt;h1&gt; &lt;a name=\"hello-world\" href=\"#hello-world\"&gt; Hello world! &lt;/a&gt;&lt;/h1&gt; 在 HTML 层， 我们决定这样定义组件接口：1&lt;anchored-heading :level=\"1\"&gt;Hello world!&lt;/anchored-heading&gt; 当我们开始写一个通过 level prop 动态生成heading 标签的组件，你可很快能想到这样实现：123456789101112131415161718192021222324252627282930313233&lt;script type=\"text/x-template\" id=\"anchored-heading-template\"&gt; &lt;div&gt; &lt;h1 v-if=\"level === 1\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h1&gt; &lt;h2 v-if=\"level === 2\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h2&gt; &lt;h3 v-if=\"level === 3\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h3&gt; &lt;h4 v-if=\"level === 4\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h4&gt; &lt;h5 v-if=\"level === 5\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h5&gt; &lt;h6 v-if=\"level === 6\"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/h6&gt; &lt;/div&gt;&lt;/script&gt;&lt;script&gt;Vue.component('anchored-heading', &#123; template: '#anchored-heading-template', props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;)&lt;/script&gt; template 在这种场景中就表现的有些冗余了。虽然我们重复使用 &lt;slot&gt;&lt;/slot&gt; 来接收每一个级别的标题标签，在标题标签中添加相同的锚点元素。但是些都会被包裹在一个无用的 div 中，因为组件必须有根节点。 虽然模板在大多数组件中都非常好用，但是在这里它就不是很简洁的了。那么，我们来尝试使用 render 函数重写上面的例子： 1234567891011121314Vue.component('anchored-heading', &#123; render: function (createElement) &#123; return createElement( 'h' + this.level, // tag name 标签名称 this.$slots.default // 子组件中的阵列 ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 简单清晰很多！简单来说，这样代码精简很多，但是需要非常熟悉 Vue 的实例属性。在这个例子中，你需要知道当你不使用 slot 属性向组件中传递内容时，比如 anchored-heading 中的 Hello world!, 这些子元素被存储在组件实例中的 $slots.default中。如果你还不了解， 在深入 render 函数之前推荐阅读 instance properties API。 createElement 参数第二件你需要熟悉的是如何在 createElement 函数中生成模板。这里是 createElement 接受的参数：123456789101112131415161718192021222324// @returns &#123;VNode&#125;createElement( // &#123;String | Object | Function&#125; // 一个 HTML 标签，组件设置，或一个函数 // 必须 Return 上述其中一个 'div', // &#123;Object&#125; // 一个对应属性的数据对象 // 您可以在 template 中使用.可选项. &#123; // (下一章，将详细说明相关细节) &#125;, // &#123;String | Array&#125; // 子节点(VNodes). 可选项. [ createElement('h1', 'hello world'), createElement(MyComponent, &#123; props: &#123; someProp: 'foo' &#125; &#125;), 'bar' ]) 完整数据对象有一件事要注意：在 templates 中，v-bind:class 和 v-bind:style ，会有特别的处理，他们在 VNode 数据对象中，为最高级配置。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123; // 和`v-bind:class`一样的 API 'class': &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API style: &#123; color: 'red', fontSize: '14px' &#125;, // 正常的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 props props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器基于 \"on\" // 所以不再支持如 v-on:keyup.enter 修饰器 // 需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅对于组件，用于监听原生事件，而不是组件使用 vm.$emit 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令. 注意事项：不能对绑定的旧值设值 // Vue 会为您持续追踨 directives: [ &#123; name: 'my-custom-directive', value: '2' expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 如果子组件有定义 slot 的名称 slot: 'name-of-slot' // 其他特殊顶层属性 key: 'myKey', ref: 'myRef'&#125; 完整示例 有了这方面的知识，我们现在可以完成我们最开始想实现的组件：123456789101112131415161718192021222324252627282930313233var getChildrenTextContent = function (children) &#123; return children.map(function (node) &#123; return node.children ? getChildrenTextContent(node.children) : node.text &#125;).join('')&#125;Vue.component('anchored-heading', &#123; render: function (createElement) &#123; // create kebabCase id var headingId = getChildrenTextContent(this.$slots.default) .toLowerCase() .replace(/\\W+/g, '-') .replace(/(^\\-|\\-$)/g, '') return createElement( 'h' + this.level, [ createElement('a', &#123; attrs: &#123; name: headingId, href: '#' + headingId &#125; &#125;, this.$slots.default) ] ) &#125;, props: &#123; level: &#123; type: Number, required: true &#125; &#125;&#125;) 约束VNodes 必须唯一所有组件树中的 VNodes 必须唯一。这意味着，下面的 render function 是无效的：1234567render: function (createElement) &#123; var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // Yikes - duplicate VNodes! myParagraphVNode, myParagraphVNode ])&#125; 如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这个例子 render 函数完美有效地渲染了 20 个重复的段落：1234567render: function (createElement) &#123; return createElement('div', Array.apply(null, &#123; length: 20 &#125;).map(function () &#123; return createElement('p', 'hi') &#125;) )&#125; 使用 JavaScript 代替模板功能无论什么都可以使用原生的 JavaScript 来实现，Vue 的 render 函数不会提供专用的 API。比如， template 中的 v-if 和 v-for:1234&lt;ul v-if=\"items.length\"&gt; &lt;li v-for=\"item in items\"&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; 这些都会在 render 函数中被 JavaScript 的 if/else 和 map 重写：123456789render: function (createElement) &#123; if (this.items.length) &#123; return createElement('ul', this.items.map(function (item) &#123; return createElement('li', item.name) &#125;)) &#125; else &#123; return createElement('p', 'No items found.') &#125;&#125; JSX如果你写了很多 render 函数，可能会觉得痛苦：12345678910createElement( 'anchored-heading', &#123; props: &#123; level: 1 &#125; &#125;, [ createElement('span', 'Hello'), ' world!' ]) 特别是模板如此简单的情况下：123&lt;anchored-heading :level=\"1\"&gt; &lt;span&gt;Hello&lt;/span&gt; world!&lt;/anchored-heading&gt; 这就是会有一个 Babel plugin 插件，用于在 Vue 中使用 JSX 语法的原因，它可以让我们回到于更接近模板的语法上。 1234567891011import AnchoredHeading from './AnchoredHeading.vue'new Vue(&#123; el: '#demo', render (h) &#123; return ( &lt;AnchoredHeading level=&#123;1&#125;&gt; &lt;span&gt;Hello&lt;/span&gt; world! &lt;/AnchoredHeading&gt; ) &#125;&#125;) 将 h 作为 createElement 的别名是一个通用惯例，你会发现在 Vue 生态系统中，实际上必须用到 JSX，如果在作用域中 h 失去作用， 在应用中会触发报错。 函数化组件之前创建的锚点标题组件是比较简单，没有管理或者监听任何传递给他的状态，也没有生命周期方法。它只是一个接收参数的函数。在这个例子中，我们标记组件为 functional， 这意味它是无状态（没有 data），无实例（没有 this 上下文）。一个 函数化组件 就像这样： 123456789101112Vue.component('my-component', &#123; functional: true, // 为了弥补缺少的实例 // 提供第二个参数作为上下文 render: function (createElement, context) &#123; // ... &#125;, // Props 可选 props: &#123; // ... &#125;&#125;) 组件需要的一切都是通过上下文传递，包括： props: 提供props 的对象 children: VNode 子节点的数组 slots: slots 对象 data: 传递给组件的 data 对象 parent: 对父组件的引用 在添加 functional: true 之后，锚点标题组件的 render 函数之间简单更新增加 context 参数，this.$slots.default 更新为 context.children，之后this.level 更新为 context.props.level。 函数化组件只是一个函数，所以渲染开销也低很多。但同样它也有完整的组件封装，你需要知道这些， 比如： 程序化地在多个组件中选择一个 在将 children, props, data 传递给子组件之前操作它们。 下面是一个依赖传入 props 的值的 smart-list 组件例子，它能代表更多具体的组件：12345678910111213141516171819202122232425262728var EmptyList = &#123; /* ... */ &#125;var TableList = &#123; /* ... */ &#125;var OrderedList = &#123; /* ... */ &#125;var UnorderedList = &#123; /* ... */ &#125;Vue.component('smart-list', &#123; functional: true, render: function (createElement, context) &#123; function appropriateListComponent () &#123; var items = context.props.items if (items.length === 0) return EmptyList if (typeof items[0] === 'object') return TableList if (context.props.isOrdered) return OrderedList return UnorderedList &#125; return createElement( appropriateListComponent(), context.data, context.children ) &#125;, props: &#123; items: &#123; type: Array, required: true &#125;, isOrdered: Boolean &#125;&#125;) slots() 和 children 对比你可能想知道为什么同时需要 slots() 和 children。slots().default 不是和 children 类似的吗？在一些场景中，是这样，但是如果是函数式组件和下面这样的 children 呢？ 123456&lt;my-functional-component&gt; &lt;p slot=\"foo\"&gt; first &lt;/p&gt; &lt;p&gt;second&lt;/p&gt;&lt;/my-functional-component&gt; 对于这个组件，children 会给你两个段落标签，而 slots().default 只会传递第二个匿名段落标签，slots().foo 会传递第一个具名段落标签。同时拥有 children 和 slots() ，因此你可以选择让组件通过 slot() 系统分发或者简单的通过 children 接收，让其他组件去处理。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"给Hexo博客添加Mathjax数学公式支持","slug":"给Hexo博客添加Mathjax数学公式支持","date":"2018-06-18T14:04:14.000Z","updated":"2018-08-11T15:24:46.834Z","comments":true,"path":"2018/06/18/给Hexo博客添加Mathjax数学公式支持/","link":"","permalink":"https://www.hojun.cn/2018/06/18/给Hexo博客添加Mathjax数学公式支持/","excerpt":"","text":"前言小白文，大神请略过…… 最近群里经常有人询问Hexo博客的Mathjax的扩展使用，由于网上教程不靠谱，忽悠人一大圈还没啥卵用。于是花点时间折腾了下Mathjax.js，出了这篇教程。（表示没用数学公式，mathjax也是第一次接触） 唠叨一下修改代码的建议：可以在其上扩展，最好不要修改。修改会出现: 改好一个bug，出来N多个bug的这种情况，因为你不知道其他地方是否还用到你修改的这部分代码，后果很严重。 开始搞百度搜索mathjax点击第一个进入其官网找到Getting Started，点击Learn more拉到最下边，Jump to our docs找到其demo代码 注意其代码有个坑，js的src应改为https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML接下来就是实验代码了，新建文章输入以下代码：12345678&lt;p&gt;When $a \\ne 0$, there are two solutions to \\(ax^2 + bx + c = 0\\) and they are$$x = &#123;-b \\pm \\sqrt&#123;b^2-4ac&#125; \\over 2a&#125;.$$&lt;/p&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt;&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config(&#123;tex2jax: &#123;inlineMath: [['$','$'], ['\\\\(','\\\\)']]&#125;&#125;);&lt;/script&gt; 这里发现了个bug,即代码快里面放入raw标签会把代码直接当成html，会被解析了。所以上面的代码缺少了raw标签,还需用raw标签包起来。关于raw标签的介绍请参考hexo标签插件 正确的代码如下图： 接下来再页面上预览一下图片：真实效果 When $a \\ne 0$, there are two solutions to \\(ax^2 + bx + c = 0\\) and they are $$x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.$$ MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}}); ok了，很简单有木有。而且在md插入这种不常用的js可以节省一些资源。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"搞事","slug":"搞事","permalink":"https://www.hojun.cn/tags/搞事/"},{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"添加系列文章功能","slug":"添加系列文章功能","date":"2018-06-17T03:54:58.000Z","updated":"2018-08-11T15:24:46.559Z","comments":true,"path":"2018/06/17/添加系列文章功能/","link":"","permalink":"https://www.hojun.cn/2018/06/17/添加系列文章功能/","excerpt":"","text":"前言因为写了一堆有关于一、二、三等有关的系列文章，而且这些文章写得时间又肯不是连续的。所以hexo的上一篇、下一篇文章功能就不能满足。需要有个系列文章的功能，于是着手实现该需求... 一开始的思路就是模仿分类(categories)和标签(tags)，来创建一个系列(series)来实现。为了弄懂分类和标签的生成实现原理还跑hexo的github仓库上看了下源代码。辛亏是时间不多，用平时的的空闲时间来实现的，所以没在这条探索HEXO大道的深坑上走的太久。 第二天偶然一次机会让我发现了hexo的二级分类，会在一级分类下新建一个二级分类的文件夹，所有该二级分类的文章都在这个文件夹下。就想借助这个二级分类来实现系列功能。 嗯…就在我快用二级分类来实现系列文章功能的时候，我发现之前绕了远路。 之前是想用分类和标签来遍历出对应的文章。由于没有系列这个变量使用了二级分类来代替…但是我们可以通过遍历文章来显示出有关的系列文章。这种方法就容易实现很多，而且比用二级分类代替更加合理。 实现废话不多说，加下来带大家来实现。在这里只介绍用遍历文章法实现的： 第一步在改文件里添加一个series，效果如下：123456789101112131415title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: hojunavatar: https://wx1.sinaimg.cn/large/006bYVyvgy1ftand2qurdj303c03cdfv.jpgauthorLink: /about/hojun.html authorAbout: authorDesc: 一个好奇的人categories: 技术comments: trueseries:tags: keywords: description: photos: --- 内容看你自己的主题而定，你只需加个series:就行。这时候你新建的md文件就都有series:这个项了，我们可以在其中填写系列名称。 第二步在md文章中添加series:的值。如： 第三步这步才是干货，在主题对应渲染文章的模板文件下添加系列文件显示。由于博主的主题用的是ejs写的，以下仅给出ejs的代码：123456789&lt;% if (post.series)&#123; %&gt; &lt;div class=&quot;post-series&quot;&gt;&lt;%= post.series %&gt;-&lt;%= __(&apos;series&apos;) %&gt;： &lt;% site.posts.sort(&apos;date&apos;).map(function(p)&#123; %&gt; &lt;% if (post.series == p.series)&#123; %&gt; &lt;li&gt;&lt;a href=&quot;&lt;%- url_for(p.path) %&gt;&quot;&gt;&lt;%= p.title %&gt;&lt;/a&gt;&lt;/li&gt; &lt;% &#125; %&gt; &lt;% &#125;) %&gt; &lt;/div&gt;&lt;% &#125; %&gt; 解释： post.series是该篇文章的系列，即第二步中填的值。 if (post.series) 如果有值才调用。 site.posts.sort(‘date’).map(function(p){ 将本站所有的文章按日期排序并遍历 if (post.series == p.series){ 如果改文章的系列和遍历文章的系列一样，则进入 &lt;%- url_for(p.path) %&gt;”&gt;&lt;%= p.title %&gt; 显示出满足文章的url路径和文章标题 到此为止系列文章的需求实现了最终效果如下：","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"前端开发规范(七、移动端优化)","slug":"前端开发规范-七、移动端优化","date":"2018-06-15T13:55:26.000Z","updated":"2018-08-11T15:24:45.168Z","comments":true,"path":"2018/06/15/前端开发规范-七、移动端优化/","link":"","permalink":"https://www.hojun.cn/2018/06/15/前端开发规范-七、移动端优化/","excerpt":"","text":"移动端优化click 的 300ms 延迟响应click 的 300ms 延迟是由双击缩放(double tap to zoom)所导致的，由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，移动端浏览器就等待 300 毫秒，以判断用户是否再次点击了屏幕。 随着响应式网页逐渐增多，用户使用双击缩放机会减少，这 300ms 的延迟就更不可接受了。浏览器开发商也随之提供相应的解决方案。这些方案在5 Ways to Prevent the 300ms Click Delay on Mobile Devices 中，被提及的包括“禁用缩放”和“width=device-width”等方案，但这些方案并不完美，需要针对某些版本浏览器，又或仅在 Android 的浏览器上使用。 所以这时候就需要一个更简单通用的解决方案，其中 FT Labs 专门为解决移动端浏览器 300 毫秒点击延迟问题所开发的一个轻量级的库 FastClick 就是很好的选择。FastClick 在检测到 touchend 事件的时候，会通过 DOM 自定义事件立即触发一个模拟 click 事件，并把浏览器在 300 毫秒之后真正触发的 click 事件阻止掉。 FastClick 的使用方法非常简单，在 window load 事件之后，在 &lt;body&gt; 上调用FastClick.attach() 即可。 123window.addEventListener( \"load\", function() &#123; FastClick.attach( document.body );&#125;, false ); 快速回弹滚动快速回弹滚动在手机浏览器上的发展历史： 早期的时候，移动端的浏览器都不支持非 body 元素的滚动条，所以一般都借助 iScroll;Android 3.0 / iOS 解决了非 body 元素的滚动问题，但滚动条不可见，同时 iOS 上只能通过2个手指进行滚动；Android 4.0 解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除；iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果如果想要为某个元素拥有 Native 般的滚动效果，可以这样操作： .element { overflow: auto; / auto | scroll / -webkit-overflow-scrolling: touch;}除了 iScroll 之外，还有一个更加强大的滚动插件 Swiper，支持 3D 和内置滚动条等。 设备检测123456789101112131415161718192021222324// 这段代码引用自：https://github.com/binnng/device.jsvar WIN = window;var LOC = WIN[\"location\"];var NA = WIN.navigator;var UA = NA.userAgent.toLowerCase();function test(needle) &#123; return needle.test(UA);&#125;var IsTouch = \"ontouchend\" in WIN;var IsAndroid = test(/android|htc/) || /linux/i.test(NA.platform + \"\");var IsIPad = !IsAndroid &amp;&amp; test(/ipad/);var IsIPhone = !IsAndroid &amp;&amp; test(/ipod|iphone/);var IsIOS = IsIPad || IsIPhone;var IsWinPhone = test(/windows phone/);var IsWebapp = !!NA[\"standalone\"];var IsXiaoMi = IsAndroid &amp;&amp; test(/mi\\s+/);var IsUC = test(/ucbrowser/);var IsWeixin = test(/micromessenger/);var IsBaiduBrowser = test(/baidubrowser/);var IsChrome = !!WIN[\"chrome\"];var IsBaiduBox = test(/baiduboxapp/);var IsPC = !IsAndroid &amp;&amp; !IsIOS &amp;&amp; !IsWinPhone;var IsHTC = IsAndroid &amp;&amp; test(/htc\\s+/);var IsBaiduWallet = test(/baiduwallet/); 获取滚动条值PC 端滚动条的值是通过 document.scrollTop 和 document.scrollLeft 获得，但在 iOS 中并没有滚动条的概念，所以仅能通过 windows.scroll 获取，同时也能兼容 Android 。12window.scrollYwindow.scrollX 清除输入框内阴影在 iOS 上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样操作：12345input,textarea &#123; border: 0; /* 方法1 */ -webkit-appearance: none; /* 方法2 */&#125; Meta 相关页面窗口自动调整到设备宽度，并禁止用户缩放页面1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no\" /&gt; 电话号码识别iOS Safari ( Android 或其他浏览器不会) 会自动识别看起来像电话号码的数字，将其处理为电话号码链接，比如： 7位数字，形如：1234567带括号及加号的数字，形如：(+86)123456789双连接线的数字，形如：00-00-0011111位数字，形如：13800138000 123456&lt;!-- 关闭电话号码识别： --&gt;&lt;meta name=\"format-detection\" content=\"telephone=no\" /&gt;&lt;!-- 开启电话功能： --&gt;&lt;a href=\"tel:123456\"&gt;123456&lt;/a&gt;&lt;!-- 开启短信功能： --&gt;&lt;a href=\"sms:123456\"&gt;123456&lt;/a&gt; 邮箱地址的识别在 Android （ iOS 不会）上，浏览器会自动识别看起来像邮箱地址的字符串，不论有你没有加上邮箱链接，当你在这个字符串上长按，会弹出发邮件的提示。 123456789&lt;!-- 关闭邮箱地址识别： --&gt;&lt;meta name=\"format-detection\" content=\"email=no\" /&gt;&lt;!-- 开启邮件发送： --&gt;&lt;a mailto:&gt;mobile@gmail.com\"&gt;mobile@gmail.com&lt;/a&gt;### 指定 iOS 的 safari 顶端状态条的样式&lt;meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black\" /&gt;&lt;!-- 可选default、black、black-translucent --&gt;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"移动端","slug":"移动端","permalink":"https://www.hojun.cn/tags/移动端/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"前端开发规范(六、JS优化篇)","slug":"前端开发规范-六、JS优化篇","date":"2018-06-15T13:55:14.000Z","updated":"2018-08-11T15:24:45.337Z","comments":true,"path":"2018/06/15/前端开发规范-六、JS优化篇/","link":"","permalink":"https://www.hojun.cn/2018/06/15/前端开发规范-六、JS优化篇/","excerpt":"","text":"性能优化避免不必要的 DOM 操作浏览器遍历 DOM 元素的代价是昂贵的。最简单优化 DOM 树查询的方案是，当一个元素出现多次时，将它保存在一个变量中，就避免多次查询 DOM 树了。1234567891011// Recommendedvar myList = \"\";var myListHTML = document.getElementById(\"myList\").innerHTML;for (var i = 0; i &lt; 100; i++) &#123; myList += \"&lt;span&gt;\" + i + \"&lt;/span&gt;\";&#125;myListHTML = myList;// Not recommendedfor (var i = 0; i &lt; 100; i++) &#123; document.getElementById(\"myList\").innerHTML += \"&lt;span&gt;\" + i + \"&lt;/span&gt;\";&#125; 缓存数组长度循环无疑是和 JavaScript 性能非常相关的一部分。通过存储数组的长度，可以有效避免每次循环重新计算。 注: 虽然现代浏览器引擎会自动优化这个过程，但是不要忘记还有旧的浏览器。12345678var arr = new Array(1000), len, i;// Recommended - size is calculated only 1 time and then storedfor (i = 0, len = arr.length; i &lt; len; i++) &#123;&#125;// Not recommended - size needs to be recalculated 1000 timesfor (i = 0; i &lt; arr.length; i++) &#123;&#125; 异步加载第三方内容当你无法保证嵌入第三方内容比如 Youtube 视频或者一个 like/tweet 按钮可以正常工作的时候，你需要考虑用异步加载这些代码，避免阻塞整个页面加载。12345678910111213(function() &#123; var script, scripts = document.getElementsByTagName('script')[0]; function load(url) &#123; script = document.createElement('script'); script.async = true; script.src = url; scripts.parentNode.insertBefore(script, scripts); &#125; load('//apis.google.com/js/plusone.js'); load('//platform.twitter.com/widgets.js'); load('//s.widgetsite.com/widget.js');&#125;()); 避免使用 jQuery 实现动画 禁止使用 slideUp/Down() fadeIn/fadeOut() 等方法； 尽量不使用 animate() 方法；","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"js","slug":"js","permalink":"https://www.hojun.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"前端开发规范(五、jQuery篇)","slug":"前端开发规范-五、jQuery篇","date":"2018-06-15T13:51:36.000Z","updated":"2018-08-11T15:24:45.304Z","comments":true,"path":"2018/06/15/前端开发规范-五、jQuery篇/","link":"","permalink":"https://www.hojun.cn/2018/06/15/前端开发规范-五、jQuery篇/","excerpt":"","text":"jQuery 规范使用最新版本的 jQuery最新版本的 jQuery 会改进性能和增加新功能，若不是为了兼容旧浏览器，建议使用最新版本的 jQuery。以下是三条常见的 jQuery 语句，版本越新，性能越好. jQuery 变量 存放 jQuery 对象的变量以 $ 开头； 将 jQuery 选择器返回的对象缓存到本地变量中复用； 使用驼峰命名变量； 12var $myDiv = $(\"#myDiv\");$myDiv.click(function()&#123;...&#125;); 选择器 尽可能的使用 ID 选择器，因为它会调用浏览器原生方法 document.getElementById 查找元素。当然直接使用原生 document.getElementById 方法性能会更好； 在父元素中选择子元素使用 .find() 方法性能会更好, 因为 ID 选择器没有使用到 Sizzle 选择器引擎来查找元素； 1234// Not recommendedvar $productIds = $(\"#products .class\");// Recommendedvar $productIds = $(\"#products\").find(\".class\"); DOM 操作 当要操作 DOM 元素的时候，尽量将其分离节点，操作结束后，再插入节点； 使用字符串连接或 array.join 要比 .append()性能更好； 123456789101112131415161718192021var $myList = $(\"#list-container &gt; ul\").detach();//...a lot of complicated things on $myList$myList.appendTo(\"#list-container\");// Not recommendedvar $myList = $(\"#list\");for(var i = 0; i &lt; 10000; i++)&#123; $myList.append(\"&lt;li&gt;\"+i+\"&lt;/li&gt;\");&#125;// Recommendedvar $myList = $(\"#list\");var list = \"\";for(var i = 0; i &lt; 10000; i++)&#123; list += \"&lt;li&gt;\"+i+\"&lt;/li&gt;\";&#125;$myList.html(list);// Much to recommendedvar array = [];for(var i = 0; i &lt; 10000; i++)&#123; array[i] = \"&lt;li&gt;\"+i+\"&lt;/li&gt;\";&#125;$myList.html(array.join('')); 事件 如果需要，对事件使用自定义的 namespace，这样容易解绑特定的事件，而不会影响到此 DOM 元素的其他事件监听； 对 Ajax 加载的 DOM 元素绑定事件时尽量使用事件委托。事件委托允许在父元素绑定事件，子代元素可以响应事件，也包括 Ajax 加载后添加的子代元素； 123456$(\"#myLink\").on(\"click.mySpecialClick\", myEventHandler);$(\"#myLink\").unbind(\"click.mySpecialClick\");// Not recommended$(\"#list a\").on(\"click\", myClickHandler);// Recommended$(\"#list\").on(\"click\", \"a\", myClickHandler); 链式写法 尽量使用链式写法而不是用变量缓存或者多次调用选择器方法； 当链式写法超过三次或者因为事件绑定变得复杂后，使用换行和缩进保持代码可读性； 123456$(\"#myDiv\").addClass(\"error\").show();$(\"#myLink\") .addClass(\"bold\") .on(\"click\", myClickHandler) .on(\"mouseover\", myMouseOverHandler) .show(); 其他 多个参数使用对象字面量存储； 不要将 CSS 写在 jQuery 里面； 正则表达式仅准用 .test() 和 .exec() 。不准用 “string”.match() ； jQuery 插件模板123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// jQuery Plugin Boilerplate// A boilerplate for jumpstarting jQuery plugins development// version 1.1, May 14th, 2011// by Stefan Gabos// remember to change every instance of \"pluginName\" to the name of your plugin!(function($) &#123; // here we go! $.pluginName = function(element, options) &#123; // plugin's default options // this is private property and is accessible only from inside the plugin var defaults = &#123; foo: 'bar', // if your plugin is event-driven, you may provide callback capabilities // for its events. execute these functions before or after events of your // plugin, so that users may customize those particular events without // changing the plugin's code onFoo: function() &#123;&#125; &#125; // to avoid confusions, use \"plugin\" to reference the // current instance of the object var plugin = this; // this will hold the merged default, and user-provided options // plugin's properties will be available through this object like: // plugin.settings.propertyName from inside the plugin or // element.data('pluginName').settings.propertyName from outside the plugin, // where \"element\" is the element the plugin is attached to; plugin.settings = &#123;&#125; var $element = $(element), // reference to the jQuery version of DOM element element = element; // reference to the actual DOM element // the \"constructor\" method that gets called when the object is created plugin.init = function() &#123; // the plugin's final properties are the merged default and // user-provided options (if any) plugin.settings = $.extend(&#123;&#125;, defaults, options); // code goes here &#125; // public methods // these methods can be called like: // plugin.methodName(arg1, arg2, ... argn) from inside the plugin or // element.data('pluginName').publicMethod(arg1, arg2, ... argn) from outside // the plugin, where \"element\" is the element the plugin is attached to; // a public method. for demonstration purposes only - remove it! plugin.foo_public_method = function() &#123; // code goes here &#125; // private methods // these methods can be called only from inside the plugin like: // methodName(arg1, arg2, ... argn) // a private method. for demonstration purposes only - remove it! var foo_private_method = function() &#123; // code goes here &#125; // fire up the plugin! // call the \"constructor\" method plugin.init(); &#125; // add the plugin to the jQuery.fn object $.fn.pluginName = function(options) &#123; // iterate through the DOM elements we are attaching the plugin to return this.each(function() &#123; // if plugin has not already been attached to the element if (undefined == $(this).data('pluginName')) &#123; // create a new instance of the plugin // pass the DOM element and the user-provided options as arguments var plugin = new $.pluginName(this, options); // in the jQuery version of the element // store a reference to the plugin object // you can later access the plugin and its methods and properties like // element.data('pluginName').publicMethod(arg1, arg2, ... argn) or // element.data('pluginName').settings.propertyName $(this).data('pluginName', plugin); &#125; &#125;); &#125;&#125;)(jQuery); 此 jQuery 插件模板出自：jQuery Plugin Boilerplate, revisited","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://www.hojun.cn/tags/jquery/"},{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"前端开发规范(四、JS篇)","slug":"前端开发规范-四、JS篇","date":"2018-06-15T13:23:05.000Z","updated":"2018-08-11T15:24:45.371Z","comments":true,"path":"2018/06/15/前端开发规范-四、JS篇/","link":"","permalink":"https://www.hojun.cn/2018/06/15/前端开发规范-四、JS篇/","excerpt":"","text":"通用约定注释原则 As short as possible（如无必要，勿增注释）：尽量提高代码本身的清晰性、可读性。 As long as necessary（如有必要，尽量详尽）：合理的注释、空行排版等，可以让代码更易阅读、更具美感。 单行注释必须独占一行。// 后跟一个空格，缩进与下一行被注释说明的代码一致。 多行注释避免使用 /…/ 这样的多行注释。有多行注释内容时，使用多个单行注释。 函数/方法注释函数/方法注释必须包含函数说明，有参数和返回值时必须使用注释标识。；参数和返回值注释必须包含类型信息和说明；当函数是内部函数，外部不可访问时，可以使用 @inner 标识；1234567891011121314151617/** * 函数描述 * * @param &#123;string&#125; p1 参数1的说明 * @param &#123;string&#125; p2 参数2的说明，比较长 * 那就换行了. * @param &#123;number=&#125; p3 参数3的说明（可选） * @return &#123;Object&#125; 返回值描述 */function foo(p1, p2, p3) &#123; var p3 = p3 || 10; return &#123; p1: p1, p2: p2, p3: p3 &#125;;&#125; 文件注释文件注释用于告诉不熟悉这段代码的读者这个文件中包含哪些东西。 应该提供文件的大体内容, 它的作者, 依赖关系和兼容性信息。如下:123456/** * @fileoverview Description of file, its uses and information * about its dependencies. * @author user@meizu.com (Firstname Lastname) * Copyright 2009 Meizu Inc. All Rights Reserved. */ 命名变量, 使用 Camel 命名法。1var loadingModules = &#123;&#125;; 私有属性、变量和方法以下划线 _ 开头。1var _privateMethod = &#123;&#125;; 常量, 使用全部字母大写，单词间下划线分隔的命名方式。1var HTML_ENTITY = &#123;&#125;; 函数, 使用 Camel 命名法。函数的参数, 使用 Camel 命名法。12function stringFormat(source) &#123;&#125;function hear(theBells) &#123;&#125; 类, 使用 Pascal 命名法类的 方法 / 属性, 使用 Camel 命名法1234567function TextNode(value, engine) &#123; this.value = value; this.engine = engine;&#125;TextNode.prototype.clone = function () &#123; return this;&#125;; 枚举变量 使用 Pascal 命名法。枚举的属性， 使用全部字母大写，单词间下划线分隔的命名方式。123456var TargetState = &#123; READING: 1, READED: 2, APPLIED: 3, READY: 4&#125;; 由多个单词组成的 缩写词，在命名中，根据当前命名法和出现的位置，所有字母的大小写与首字母的大小写保持一致。123function XMLParser() &#123;&#125;function insertHTML(element, html) &#123;&#125;var httpRequest = new HTTPRequest(); 命名语法类名，使用名词。1function Engine(options) &#123;&#125; 函数名，使用动宾短语。1function getStyle(element) &#123;&#125; boolean 类型的变量使用 is 或 has 开头。12var isReady = false;var hasMoreCommands = false; Promise 对象用动宾短语的进行时表达。12var loadingData = ajax.get('url');loadingData.then(callback); 接口命名规范可读性强，见名晓义；尽量不与 jQuery 社区已有的习惯冲突；尽量写全。不用缩写，除非是下面列表中约定的；（变量以表达清楚为目标，uglify 会完成压缩体积工作） 常用词 说明 options 表示选项，与 jQuery 社区保持一致，不要用 config, opts 等 active 表示当前，不要用 current 等 index 表示索引，不要用 idx 等 trigger 触点元素 triggerType 触发类型、方式 context 表示传入的 this 对象 object 推荐写全，不推荐简写为 o, obj 等 element 推荐写全，不推荐简写为 el, elem 等 length 不要写成 len, l prev previous 的缩写 next next 下一个 constructor 不能写成 ctor easing 示动画平滑函数 min minimize 的缩写 max maximize 的缩写 DOM 不要写成 dom, Dom .hbs 使用 hbs 后缀表示模版 btn button 的缩写 link 超链接 title 主要文本 img 图片路径（img标签src属性） dataset html5 data-xxx 数据接口 theme 主题 className 类名 classNameSpace class 命名空间 True 和 False 布尔表达式类型检测优先使用 typeof。对象类型检测使用 instanceof。null 或 undefined 的检测使用 == null。 下面的布尔表达式都返回 false: null undefined ‘’ 空字符串 0 数字0 但小心下面的, 可都返回 true: ‘0’ 字符串0 [] 空数组 {} 空对象 不要在 Array 上使用 for-in 循环for-in 循环只用于 object/map/hash 的遍历, 对 Array 用 for-in 循环有时会出错. 因为它并不是从 0 到 length - 1 进行遍历, 而是所有出现在对象及其原型链的键值。123456789101112131415161718192021222324// Not recommendedfunction printArray(arr) &#123; for (var key in arr) &#123; print(arr[key]); &#125;&#125;printArray([0,1,2,3]); // This works.var a = new Array(10);printArray(a); // This is wrong.a = document.getElementsByTagName('*');printArray(a); // This is wrong.a = [0,1,2,3];a.buhu = 'wine';printArray(a); // This is wrong again.a = new Array;a[3] = 3;printArray(a); // This is wrong again.// Recommendedfunction printArray(arr) &#123; var l = arr.length; for (var i = 0; i &lt; l; i++) &#123; print(arr[i]); &#125;&#125; 二元和三元操作符操作符始终写在前一行, 以免分号的隐式插入产生预想不到的问题。 1234567891011var x = a ? b : c;var y = a ? longButSimpleOperandB : longButSimpleOperandC;var z = a ? moreComplicatedB : moreComplicatedC;. 操作符也是如此：var x = foo.bar(). doSomething(). doSomethingElse(); 条件(三元)操作符 (?:)三元操作符用于替代 if 条件判断语句。 12345678// Not recommendedif (val != 0) &#123; return foo();&#125; else &#123; return bar();&#125;// Recommendedreturn val ? foo() : bar(); &amp;&amp; 和 ||二元布尔操作符是可短路的, 只有在必要时才会计算到最后一项。 1234567891011121314151617181920212223242526// Not recommendedfunction foo(opt_win) &#123; var win; if (opt_win) &#123; win = opt_win; &#125; else &#123; win = window; &#125; // ...&#125;if (node) &#123; if (node.kids) &#123; if (node.kids[index]) &#123; foo(node.kids[index]); &#125; &#125;&#125;// Recommendedfunction foo(opt_win) &#123; var win = opt_win || window; // ...&#125;var kid = node &amp;&amp; node.kids &amp;&amp; node.kids[index];if (kid) &#123; foo(kid);&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"js","slug":"js","permalink":"https://www.hojun.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"前端开发规范(三、CSS性能优化)","slug":"前端开发规范-三、CSS性能优化","date":"2018-06-14T12:53:15.000Z","updated":"2018-08-11T15:24:45.211Z","comments":true,"path":"2018/06/14/前端开发规范-三、CSS性能优化/","link":"","permalink":"https://www.hojun.cn/2018/06/14/前端开发规范-三、CSS性能优化/","excerpt":"","text":"性能优化慎重选择高消耗的样式高消耗属性在绘制前需要浏览器进行大量计算： box-shadows border-radius transparency transforms CSS filters（性能杀手） 避免过分重排当发生重排的时候，浏览器需要重新计算布局位置与大小，更多详情。 常见的重排元素: width height padding margin display border-width position top left right bottom font-size float text-align overflow-y font-weight overflow font-family line-height vertical-align clear white-space min-height 正确使用 Display 的属性Display 属性会影响页面的渲染，请合理使用。 display: inline后不应该再使用 width、height、margin、padding 以及 float； display: inline-block 后不应该再使用 float； display: block 后不应该再使用 vertical-align； display: table-* 后不应该再使用 margin 或者 float； 不滥用 FloatFloat在渲染时计算量比较大，尽量减少使用。 动画性能优化动画的实现原理，是利用了人眼的“视觉暂留”现象，在短时间内连续播放数幅静止的画面，使肉眼因视觉残象产生错觉，而误以为画面在“动”。 动画的基本概念： 帧：在动画过程中，每一幅静止画面即为一“帧”; 帧率：即每秒钟播放的静止画面的数量，单位是fps(Frame per second); 帧时长：即每一幅静止画面的停留时间，单位一般是ms(毫秒); 跳帧(掉帧/丢帧)：在帧率固定的动画中，某一帧的时长远高于平均帧时长，导致其后续数帧被挤压而丢失的现象。 一般浏览器的渲染刷新频率是 60 fps，所以在网页当中，帧率如果达到 50-60 fps 的动画将会相当流畅，让人感到舒适。 如果使用基于 javaScript 的动画，尽量使用 requestAnimationFrame. 避免使用 setTimeout, setInterval. 避免通过类似 jQuery animate()-style 改变每帧的样式，使用 CSS 声明动画会得到更好的浏览器优化。 使用 translate 取代 absolute 定位就会得到更好的 fps，动画会更顺滑。 多利用硬件能力，如通过 3D 变形开启 GPU 加速一般在 Chrome 中，3D或透视变换（perspective transform）CSS属性和对 opacity 进行 CSS 动画会创建新的图层，在硬件加速渲染通道的优化下，GPU 完成 3D 变形等操作后，将图层进行复合操作（Compesite Layers），从而避免触发浏览器大面积重绘和重排。 注：3D 变形会消耗更多的内存和功耗。 使用 translate3d 右移 500px 的动画流畅度要明显优于直接使用 left：12345678910111213.ball-1 &#123; transition: -webkit-transform .5s ease; -webkit-transform: translate3d(0, 0, 0);&#125;.ball-1.slidein&#123; -webkit-transform: translate3d(500px, 0, 0);&#125;.ball-2 &#123; transition: left .5s ease; left: 0;&#125;.ball-2.slidein &#123; left: 500px;&#125; 测试代码：123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;style type=\"text/css\"&gt; .ball-1 &#123; width: 1000px; height: 100px; transition: -webkit-transform .5s ease; -webkit-transform: translate3d(0, 0, 0); background: #F00; &#125; .ball-1:hover&#123; -webkit-transform: translate3d(500px, 0, 0); &#125; .ball-2 &#123; position: relative; left: 0px; width: 1000px; height: 100px; transition: left .5s ease; background: #00F; &#125; .ball-2:hover&#123; left: 500px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"ball-1\"&gt;&lt;/div&gt; &lt;div class=\"ball-2\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 提升 CSS 选择器性能CSS 选择器对性能的影响源于浏览器匹配选择器和文档元素时所消耗的时间，所以优化选择器的原则是应尽量避免使用消耗更多匹配时间的选择器。而在这之前我们需要了解 CSS 选择器匹配的机制， 如子选择器规则：1#header &gt; a &#123;font-weight:blod;&#125; 我们中的大多数人都是从左到右的阅读习惯，会习惯性的设定浏览器也是从左到右的方式进行匹配规则，推测这条规则的开销并不高。 我们会假设浏览器以这样的方式工作：寻找 id 为 header 的元素，然后将样式规则应用到直系子元素中的 a 元素上。我们知道文档中只有一个 id 为 header 的元素，并且它只有几个 a 元素的子节点，所以这个 CSS 选择器应该相当高效。 事实上，却恰恰相反，CSS 选择器是从右到左进行规则匹配。了解这个机制后，例子中看似高效的选择器在实际中的匹配开销是很高的，浏览器必须遍历页面中所有的 a 元素并且确定其父元素的 id 是否为 header 。 如果把例子的子选择器改为后代选择器则会开销更多，在遍历页面中所有 a 元素后还需向其上级遍历直到根节点。1#header a &#123;font-weight:blod;&#125; 理解了CSS选择器从右到左匹配的机制后，明白只要当前选择符的左边还有其他选择符，样式系统就会继续向左移动，直到找到和规则匹配的选择符，或者因为不匹配而退出。我们把最右边选择符称之为关键选择器。——更多详情 1、避免使用通用选择器12/* Not recommended */.content * &#123;color: red;&#125; 浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 content 的元素，直到文档的根节点。因此其匹配开销是非常大的，所以应避免使用关键选择器是通配选择器的情况。 2、避免使用标签或 class 选择器限制 id 选择器1234/* Not recommended */button#backButton &#123;…&#125;/* Recommended */#newMenuIcon &#123;…&#125; 3、避免使用标签限制 class 选择器123456/* Not recommended */treecell.indented &#123;…&#125;/* Recommended */.treecell-indented &#123;…&#125;/* Much to recommended */.hierarchy-deep &#123;…&#125; 4、避免使用多层标签选择器。使用 class 选择器替换，减少css查找1234/* Not recommended */treeitem[mailfolder=\"true\"] &gt; treerow &gt; treecell &#123;…&#125;/* Recommended */.treecell-mailfolder &#123;…&#125; 5、避免使用子选择器123456/* Not recommended */treehead treerow treecell &#123;…&#125;/* Recommended */treehead &gt; treerow &gt; treecell &#123;…&#125;/* Much to recommended */.treecell-header &#123;…&#125; 6、使用继承1234/* Not recommended */#bookmarkMenuItem &gt; .menu-left &#123; list-style-image: url(blah) &#125;/* Recommended */#bookmarkMenuItem &#123; list-style-image: url(blah) &#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.hojun.cn/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"前端开发规范(二、CSS篇)","slug":"前端开发规范-二、CSS篇","date":"2018-06-13T13:57:40.000Z","updated":"2018-08-11T15:24:45.265Z","comments":true,"path":"2018/06/13/前端开发规范-二、CSS篇/","link":"","permalink":"https://www.hojun.cn/2018/06/13/前端开发规范-二、CSS篇/","excerpt":"","text":"CSS代码组织 以组件为单位组织代码段； 制定一致的注释规范； 组件块和子组件块以及声明块之间使用一空行分隔，子组件块之间三空行分隔； 如果使用了多个 CSS 文件，将其按照组件而非页面的形式分拆，因为页面会被重组，而组件只会被移动； 良好的注释是非常重要的。请留出时间来描述组件（component）的工作方式、局限性和构建它们的方法。不要让你的团队其它成员 来猜测一段不通用或不明显的代码的目的。 提示：通过配置编辑器，可以提供快捷键来输出一致认可的注释模式。123456789101112131415/* ========================================================================== 组件块 ============================================================================ *//* 子组件块 ============================================================================ */.selector &#123; padding: 15px; margin-bottom: 15px;&#125;/* 子组件块 ============================================================================ */.selector-secondary &#123; display: block; /* 注释*/&#125; Class 和 ID 使用语义化、通用的命名方式； 使用连字符 - 作为 ID、Class 名称界定符，不要驼峰命名法和下划线； 避免选择器嵌套层级过多，尽量少于 3 级； 避免选择器和 Class、ID 叠加使用； 出于性能考量，在没有必要的情况下避免元素选择器叠加 Class、ID 使用。 元素选择器和 ID、Class 混合使用也违反关注分离原则。如果HTML标签修改了，就要再去修改 CSS 代码，不利于后期维护。 12345678910/* Not recommended */.red &#123;&#125;.box_green &#123;&#125;.page .header .login #username input &#123;&#125;ul#example &#123;&#125;/* Recommended */#nav &#123;&#125;.box-video &#123;&#125;#username input &#123;&#125;#example &#123;&#125; 声明顺序相关属性应为一组，推荐的样式编写顺序 Positioning Box model Typographic Visual 由于定位（positioning）可以从正常的文档流中移除元素，并且还能覆盖盒模型（box model）相关的样式，因此排在首位。盒模型决定了组件的尺寸和位置，因此排在第二位。 其他属性只是影响组件的内部（inside）或者是不影响前两组属性，因此排在后面。123456789101112131415161718192021222324252627282930.declaration-order &#123; /* Positioning */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* Box model */ display: block; box-sizing: border-box; width: 100px; height: 100px; padding: 10px; border: 1px solid #e5e5e5; border-radius: 3px; margin: 10px; float: right; overflow: hidden; /* Typographic */ font: normal 13px \"Helvetica Neue\", sans-serif; line-height: 1.5; text-align: center; /* Visual */ background-color: #f5f5f5; color: #fff; opacity: .8; /* Other */ cursor: pointer;&#125; 引号使用url() 、属性选择符、属性值使用双引号。 1234567/* Recommended */@import url(\"//www.google.com/css/maia.css\");html &#123; font-family: \"open sans\", arial, sans-serif;&#125;.selector[type=\"text\"] &#123;&#125; 媒体查询（Media query）的位置将媒体查询放在尽可能相关规则的附近。不要将他们打包放在一个单一样式文件中或者放在文档底部。如果你把他们分开了，将来只会被大家遗忘。12345678.element &#123; ... &#125;.element-avatar &#123; ... &#125;.element-selected &#123; ... &#125;@media (max-width: 768px) &#123; .element &#123; ...&#125; .element-avatar &#123; ... &#125; .element-selected &#123; ... &#125;&#125; 不要使用 @import与 &lt;link&gt; 相比，@import 要慢很多，不光增加额外的请求数，还会导致不可预料的问题。 替代办法： 使用多个 元素； 通过 Sass 或 Less 类似的 CSS 预处理器将多个 CSS 文件编译为一个文件； 其他 CSS 文件合并工具； 链接的样式顺序：a:link -&gt; a:visited -&gt; a:hover -&gt; a:active（LoVeHAte）选择字体在 Web 上应用字体，是一门技术，同时也是一门艺术. 由于计算机历史发展的原因，西文有大量优秀的字体可供选择，可对于中文来说就是一项挑战. 主流操作系统提供的本地中文字体极少，另一方面中文字体组成的特殊性，其体积过于庞大，无法良好地使用 webfont. 所以编写健壮的 font-family 是一件需要深思熟虑的事情. 以下列出各种平台下合适的中西文字体： 桌面端 Mac, Windows, Linux 上适合网页显示的优秀中文字体 Mac Windows Linux 冬青黑体 Hiragino Sans GB 中易宋体 SimSun 文泉驿微米黑 WenQuanYi Microhei 黑体-简（华文黑体）Heiti SC (STHeiti) 微软雅黑 Microsoft YaHei 宋体-简（华文宋体）Songti SC (STSong) 移动端 iOS, Android 上适合网页显示的优秀中文字体 iOS Android 黑体-简（华文黑体）Heiti SC (STHeiti) 思源黑体 Noto Sans CJK SC Droid Sans Fallback 主流操作系统上适合网页显示的优秀西文字体 无衬线 衬线 等宽 Lucida Grande Georgia Menlo Helvetica Neue Times New Roman Courier Arial 抛开宋/明体长时间作为系统默认字体，所产生的审美疲劳，宋/明体相比黑体是更合适作为内文字体. 大多的宋/明体针对内文设计，横细直粗，造型方正，笔画在小字号的情况下，不会糊在一起，给人一种素雅的感觉. 而黑体笔画粗壮有力，引人注目，更适合作为标题使用. 但大部分人已经习惯在网页上阅读黑体，以及宋/明体在字重过大的情况下，显示效果还是不太理想. 所以内文默认提供黑体，可选择性的切换宋/明体. 12p &#123; font-family: \"Georgia\", \"Times New Roman\", \"Songti SC\", \"SimSun\", serif; &#125;h1, h2, h3, h4, h5, h6 &#123; font-family: \"Lucida Grande\", \"Helvetica Neue\", \"Arial\", \"Hiragino Sans GB\", \"Noto Sans CJK SC\", \"Heiti SC\", \"Microsoft YaHei\", \"WenQuanYi Microhei\", sans-serif; &#125; 垂直的旋律音阶Robert Bringhurst 在《The Elements of Typographic Style》谈到字号大小之间的比例，形似于音乐中的音阶. 作曲时以某个特定的音阶为基础，才会形成特定的风格. 字号的排版同样如此，有规律的字号变化，才会形成特定的排版风格. 将内文以 16px 作为字号标题 h1, h2, h3, h4, h5, h6 以 16px 作为字号基础，按同比例的递减123456p &#123; font-size: 16px; &#125;h1 &#123; font-size: 2em; &#125;h2 &#123; font-size: 1.8em; &#125;h3 &#123; font-size: 1.6em; &#125;h4 &#123; font-size: 1.4em; &#125;h5, h6 &#123; font-size: 1.2em; &#125; 节拍此外，Robert Bringhurst 还谈到版式中的空间就像音乐中的时间(Space in typography is like time in music)，言下之意，把握间距（行高）就如把握节拍. 节拍是对时间的分割，倘若抢拍便失去节奏. 文字的间距（行高）亦是对空间的分割，不一致间距（行高）比例，便会失去「垂直的旋律」. 将内文以 1.7em 作为行高标题 h1, h2, h3, h4, h5, h6 以 1.5em 作为行高.12p &#123; line-height: 1.7em; &#125;h1, h2, h3, h4, h5, h6 &#123; line-height: 1.5em; &#125; 段首缩进 VS 段落间距段落分隔对于中文排版而言也是特别重要，主要以「段首缩进」和「段落间距」两种方式表现，它们的唯一目的就是将段落分隔. 「段首缩进」主要用于印刷书籍，节省纵向空间，保持文本连贯，但一般在网页上的阅读速度较快，会使文字过于密集产生压力. 相反「段落间距」主要用于网页，充分利用网页无限的纵向空间，保障文本块的整洁，同时给予长篇阅读休息的间隙. 所以一般网页排版，会考虑选择「段落间距」，可以设置以下属性实现「段落间距」.12345p &#123; margin-bottom: 1.7em; &#125;h1, h2, h3, h4, h5, h6 &#123; margin-top: .7em; margin-bottom: 0.2em;&#125; 对齐汉字的方块性质构成了汉字独有的艺术美感，使其具有工整的特点，从而显现出中文排版的重要原则：所有元素都是正方体. 但从二十世纪开始使用标点后，以及中西文混排的情况越来越多，为了保证「禁则处理」和「齐头尾」实现，可能需要在不同条件下进行适当的断词处理. 「禁則」是来自日语的排版术语，主要指的就是禁止一些标点等字符出现在行首或行尾的规则，大致相当于汉语常说的「避头尾」.可以设置以下属性实现「齐头尾」，其中inter-ideographic意思是「通过调整单词和字符之间的留白来实现两端对齐」.1234p &#123;text-align: justify;text-justify: inter-ideographic;&#125; 但这样的「齐头尾」并不是完美的，主要由于技术遗留原因，在 Windows 和 Linux 上的 webkit 浏览器并没有实现 inter-ideographic 导致中西文混排的时候，容易出现过度拉伸字间距的情况。 为此有一种不优雅的解决方案，在极易出现字间距拉伸的小尺寸屏幕（手机）上使用「断词处理」，避免字间距拉伸，可是这样也带来「无视避头尾规则」和「西文单词断词」的坏毛病. 这是用一种不优雅解决另一种不优雅，按需抉择吧. 可以设置以下属性进行「断词处理」 1p &#123; word-break: break-all; &#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.hojun.cn/tags/css/"},{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"前端开发规范(一、HTML篇)","slug":"前端开发规范-一、HTML篇","date":"2018-06-11T14:13:04.000Z","updated":"2018-08-11T15:24:45.127Z","comments":true,"path":"2018/06/11/前端开发规范-一、HTML篇/","link":"","permalink":"https://www.hojun.cn/2018/06/11/前端开发规范-一、HTML篇/","excerpt":"","text":"基本原则结构、样式、行为分离尽量确保文档和模板只包含 HTML 结构，样式都放到样式表里，行为都放到脚本里。 缩进统一两个空格缩进（总之缩进统一即可），不要使用 Tab 或者 Tab、空格混搭。 文件编码使用不带 BOM 的 UTF-8 编码。 在 HTML中指定编码 &lt;meta charset=&quot;utf-8&quot;&gt; ；无需使用 @charset 指定样式表的编码，它默认为 UTF-8 （参考 @charset）； 一律使用小写字母1234&lt;!-- Recommended --&gt;&lt;img src=\"google.png\" alt=\"Google\"&gt;&lt;!-- Not recommended --&gt;&lt;A HREF=\"/\"&gt;Home&lt;/A&gt; 1234/* Recommended */color: #e5e5e5;/* Not recommended */color: #E5E5E5; 省略外链资源 URL 协议部分省略外链资源（图片及其它媒体资源）URL 中的 http / https 协议，使 URL 成为相对地址，避免Mixed Content 问题，减小文件字节数。 其它协议（ftp 等）的 URL 不省略。1234&lt;!-- Recommended --&gt;&lt;script src=\"//www.google.com/js/gweb/analytics/autotrack.js\"&gt;&lt;/script&gt;&lt;!-- Not recommended --&gt;&lt;script src=\"http://www.google.com/js/gweb/analytics/autotrack.js\"&gt;&lt;/script&gt; 12345678/* Recommended */.example &#123; background: url(//www.google.com/images/example);&#125;/* Not recommended */.example &#123; background: url(http://www.google.com/images/example);&#125; 统一注释通过配置编辑器，可以提供快捷键来输出一致认可的注释模式。 HTML篇标签 自闭合（self-closing）标签，无需闭合 ( 例如： img input br hr 等 )； 可选的闭合标签（closing tag），需闭合 ( 例如：&lt;/li&gt; 或 &lt;/body&gt; )； 尽量减少标签数量； Class 与 ID class 应以功能或内容命名，不以表现形式命名； class 与 id 单词字母小写，多个单词组成时，采用中划线-分隔； 使用唯一的 id 作为 Javascript hook, 同时避免创建无样式信息的 class； 属性顺序HTML 属性应该按照特定的顺序出现以保证易读性。 id class name data-xxx src, for, type, href title, alt aria-xxx, role 引号属性的定义，统一使用双引号。1234&lt;!-- Not recommended --&gt;&lt;span id='j-hook' class=text&gt;Google&lt;/span&gt;&lt;!-- Recommended --&gt;&lt;span id=\"j-hook\"&gt;Google&lt;/span&gt; 嵌套a 不允许嵌套 div这种约束属于语义嵌套约束，与之区别的约束还有严格嵌套约束，比如a 不允许嵌套 a。 严格嵌套约束在所有的浏览器下都不被允许；而语义嵌套约束，浏览器大多会容错处理，生成的文档树可能相互不太一样。 语义嵌套约束&lt;li&gt; 用于 &lt;ul&gt; 或 &lt;ol&gt; 下；&lt;dd&gt;, &lt;dt&gt; 用于 &lt;dl&gt; 下；&lt;thead&gt;, &lt;tbody&gt;, &lt;tfoot&gt;, &lt;tr&gt;, &lt;td&gt; 用于 &lt;table&gt; 下； 严格嵌套约束inline-Level 元素，仅可以包含文本或其它 inline-Level 元素;&lt;a&gt;里不可以嵌套交互式元素&lt;a&gt;、&lt;button&gt;、&lt;select&gt;等;&lt;p&gt;里不可以嵌套块级元素&lt;div&gt;、&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;ul&gt;/&lt;ol&gt;/&lt;li&gt;、&lt;dl&gt;/&lt;dt&gt;/&lt;dd&gt;、&lt;form&gt;等。更多详情，参考WEB标准系列-HTML元素嵌套 布尔值属性HTML5 规范中 disabled、checked、selected 等属性不用设置值。12345&lt;input type=\"text\" disabled&gt;&lt;input type=\"checkbox\" value=\"1\" checked&gt;&lt;select&gt; &lt;option value=\"1\" selected&gt;1&lt;/option&gt;&lt;/select&gt; 语义化没有 CSS 的 HTML 是一个语义系统而不是 UI 系统。 通常情况下，每个标签都是有语义的，所谓语义就是你的衣服分为外套， 裤子，裙子，内裤等，各自有对应的功能和含义。所以你总不能把内裤套在脖子上吧。– 一丝 此外语义化的 HTML 结构，有助于机器（搜索引擎）理解，另一方面多人协作时，能迅速了解开发者意图。 HEAD文档类型为每个 HTML 页面的第一行添加标准模式（standard mode）的声明， 这样能够确保在每个浏览器中拥有一致的表现。1&lt;!DOCTYPE html&gt; 语言属性lang属性的取值应该遵循 BCP 47 - Tags for Identifying Languages。12345678&lt;!-- 中文 --&gt;&lt;html lang=\"zh-Hans\"&gt;&lt;!-- 简体中文 --&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;!-- 繁体中文 --&gt;&lt;html lang=\"zh-cmn-Hant\"&gt;&lt;!-- English --&gt;&lt;html lang=\"en\"&gt; 字符编码以无 BOM 的 utf-8 编码作为文件格式;指定字符编码的 meta 必须是 head 的第一个直接子元素；123456789&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; ...... &lt;/head&gt; &lt;body&gt; ...... &lt;/body&gt;&lt;/html&gt; IE 兼容模式优先使用最新版本的IE 和 Chrome 内核1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; SEO 优化123456789&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;!-- SEO --&gt; &lt;title&gt;Style Guide&lt;/title&gt; &lt;meta name=\"keywords\" content=\"your keywords\"&gt; &lt;meta name=\"description\" content=\"your description\"&gt; &lt;meta name=\"author\" content=\"author,email address\"&gt;&lt;/head&gt; viewportviewport: 一般指的是浏览器窗口内容区的大小，不包含工具条、选项卡等内容；width: 浏览器宽度，输出设备中的页面可见区域宽度；device-width: 设备分辨率宽度，输出设备的屏幕可见宽度；initial-scale: 初始缩放比例；maximum-scale: 最大缩放比例；为移动端设备优化，设置可见区域的宽度和初始缩放比例。1&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\" /&gt; iOS 图标apple-touch-icon 图片自动处理成圆角和高光等效果;apple-touch-icon-precomposed 禁止系统自动添加效果，直接显示设计原图;12345678&lt;!-- iPhone 和 iTouch，默认 57x57 像素，必须有 --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"&gt;&lt;!-- iPad，72x72 像素，可以没有，但推荐有 --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-72x72-precomposed.png\" sizes=\"72x72\"&gt;&lt;!-- Retina iPhone 和 Retina iTouch，114x114 像素，可以没有，但推荐有 --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-114x114-precomposed.png\" sizes=\"114x114\"&gt;&lt;!-- Retina iPad，144x144 像素，可以没有，但推荐有 --&gt;&lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-144x144-precomposed.png\" sizes=\"144x144\"&gt; favicon在未指定 favicon 时，大多数浏览器会请求 Web Server 根目录下的 favicon.ico 。为了保证 favicon 可访问，避免404，必须遵循以下两种方法之一： 在 Web Server 根目录放置 favicon.ico 文件； 使用 link 指定 favicon； 1&lt;link rel=\"shortcut icon\" href=\"path/to/favicon.ico\"&gt; HEAD 模板12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"zh-cmn-Hans\"&gt;&lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\"&gt; &lt;title&gt;Style Guide&lt;/title&gt; &lt;meta name=\"description\" content=\"不超过150个字符\"&gt; &lt;meta name=\"keywords\" content=\"\"&gt; &lt;meta name=\"author\" content=\"name, email@gmail.com\"&gt; &lt;!-- 为移动设备添加 viewport --&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;!-- iOS 图标 --&gt; &lt;link rel=\"apple-touch-icon-precomposed\" href=\"/apple-touch-icon-57x57-precomposed.png\"&gt; &lt;link rel=\"alternate\" type=\"application/rss+xml\" title=\"RSS\" href=\"/rss.xml\" /&gt; &lt;link rel=\"shortcut icon\" href=\"path/to/favicon.ico\"&gt;&lt;/head&gt;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"html","slug":"html","permalink":"https://www.hojun.cn/tags/html/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"手把手教你搭建HEXO博客(四)","slug":"手把手教你搭建HEXO博客-四","date":"2018-06-09T06:56:11.000Z","updated":"2018-08-11T15:24:46.021Z","comments":true,"path":"2018/06/09/手把手教你搭建HEXO博客-四/","link":"","permalink":"https://www.hojun.cn/2018/06/09/手把手教你搭建HEXO博客-四/","excerpt":"","text":"手把手教你搭建HEXO+Github博客 （系列教程四） 为什么推荐hexo+github？ 最重要两点：简单、免费 Next主题使用在hexo官网的Themes（主题）下，搜索next搜索结果点击跳转到github仓库点击CN查看中文介绍点击详细安装步骤下载最新版本选择下载zip版右键-&gt;解压到当前文件夹（若没有解压选项，请百度下载或360安全卫士下载压缩软件）（作者用的WinRAR）重命名为next拷贝到博客目录的themes下在sublime中打开config，修改 theme: next。注意是博客目录下的config，不是主题目录下的hexo g 重新生成一下hexo s -p 5555本地端口部署打开浏览器输入：localhost:5555，预览一下主题效果需要更多关于next主题的教程，可以百度搜索hexo next，点击第一个Next|使用文档。如下：发现next支持多种外观我们试着换一个外观模式，打开主题next下的config文件，注释第一个，显示第二个。再在浏览器上预览效果如下。 搭建篇到此结束！感兴趣的小伙伴们可以着手搭建了。有问题尽管联系作者。尽量在当天晚上会全部回复！","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.hojun.cn/tags/博客/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"手把手教你搭建HEXO博客(三)","slug":"手把手教你搭建HEXO博客-三","date":"2018-06-08T15:37:04.000Z","updated":"2018-08-11T15:24:45.901Z","comments":true,"path":"2018/06/08/手把手教你搭建HEXO博客-三/","link":"","permalink":"https://www.hojun.cn/2018/06/08/手把手教你搭建HEXO博客-三/","excerpt":"","text":"手把手教你搭建HEXO+Github博客 （系列教程三） 为什么推荐hexo+github？ 最重要两点：简单、免费 安装HEXO先在本地新建个blog文件夹（随意）在cmd命令行进入到blog文件夹下。（win+R打开运行对话框，输入cmd打开命令行程序）heox主页上的就是安装命令（npm install hexo-cli -g），复制下来在cmd从粘贴，回车确认命令，安装。安装需要时间，请耐心等待安装成功后，运行初始化命令(hexo init hojunBlog)hexo官网也有部署命令的教程初始化好后，进入文件夹，输入命令安装依赖 npm install(安装需要时间，请耐心等待)（网好的请无视）若网络较差，可以使用淘宝镜像：命令:npm install -g cnpm –registry=https://registry.npm.taobao.org使用就是把npm改成cnpm即可。网好的作者这里继续使用npm安装完成后，输入hexo s -p 5555(在端口5555启动服务)在网页上输入localhost:5555预览一下（localhost表示本地访问，小伙伴是看不到的） 安装sublimesublime不是必要的，只是编辑文本用的编辑器。不过安利大家推荐：百度搜索sublime，进入官网下载点击按钮下载下载好后确认安装我们将其安装在D盘：安装完成后，打开程序直接将博客文件夹拖入编辑器打开config文件，需要修改的地方有：网站名，介绍，关键字（这部分自己取），url(即是“http://用户名.github.io)。使用Ctrl+S保存文件现在我们打开github获取仓库地址,点击头像-&gt;Your profile点击对应的仓库点击Clone or download，复制仓库地址在config的最后找到deploy，输入如下内容（注意要有空格和缩进，不然会报错）接下来还需要安装git插件，命令 npm install hexo-deployer-git –save安装好后输入hexo g生成命令输入hexo d部署到github第一提交会提示您配置github的邮箱和用户名根据提示配置在弹出的输入框中输入用户名，密码登录显示出INFO Deploy done: git表示成功发布到github上在浏览器上输入 “用户名.github.io” 即可访问自己的博客（你可以把这个链接发布给小伙伴啦）To Be Continued…(未完待续)视频教程-hexo安装视频教程-sublime安装视频教程-hexo发布","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.hojun.cn/tags/博客/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"手把手教你搭建HEXO博客(二)","slug":"手把手教你搭建HEXO博客-二","date":"2018-06-07T14:20:12.000Z","updated":"2018-08-11T15:24:45.982Z","comments":true,"path":"2018/06/07/手把手教你搭建HEXO博客-二/","link":"","permalink":"https://www.hojun.cn/2018/06/07/手把手教你搭建HEXO博客-二/","excerpt":"","text":"手把手教你搭建HEXO+Github博客 （系列教程二） 为什么推荐hexo+github？ 最重要两点：简单、免费 gitforwin安装百度搜索gitforwindows，点击进入官网点击下载：下载好后确认安装：我们选择安装在D盘这里我们选择Use Windows的这个选项，我们就可以在cmd窗口中使用git命令win+R打开运行对话框，输入cmd打开命令行输入git检查是否安装成功，输出一堆git相关命令表示安装成功 github SSH Key 配置接下来来到我们gitforwin的安装目录下，打开git-bash输入ssh-keygen -t rsa -C “github的注册邮箱地址”一路回车生成密钥，默认生成在C:\\Users\\用户名.ssh目录下面接下来来到github官网，点击头像选择setting再点击SSH and GPG keys，选择右边的New SSH key标题可以自定义找到我们生成的密钥，默认生成在C:\\Users\\用户名.ssh目录下面拷贝到Key下成功To Be Continued…(未完待续)视频教程-gitforwin安装视频教程-gitsshkey配置","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.hojun.cn/tags/博客/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"手把手教你搭建HEXO博客(一)","slug":"手把手教你搭建HEXO博客-一","date":"2018-06-06T13:25:30.000Z","updated":"2018-08-11T15:24:45.827Z","comments":true,"path":"2018/06/06/手把手教你搭建HEXO博客-一/","link":"","permalink":"https://www.hojun.cn/2018/06/06/手把手教你搭建HEXO博客-一/","excerpt":"","text":"手把手教你搭建HEXO+Github博客 （系列教程一） 为什么推荐hexo+github？最重要两点：简单、免费 环境搭建node安装百度搜索node，进入官网。下载稳定版：下载好后直接打开安装我这里将其安装在D盘（可以自己选择安装位置）可以看到安装包中已经自带npm包管理工具等待安装完成后，WIN+R打开运行对话框。输入cmd带开命令行控制程序。输入node -v命令检测node是否安装成功。成功会显示出版本号 github注册百度搜索github,进入官网注册。（注意：用户名跟你的博客域名有关，请慎重取名）选择free点击start会叫你去验证邮箱进入注册的邮箱，打开github给我们发送的邮件点击验证链接验证完成后点击start，创建仓库。仓库名必须为’用户名.github.io’创建好后我们来新建个文件，点击Create new file文件为index.html，内容为&lt;h1&gt;Hello Github Pages&lt;/h1&gt;复制你的仓库名————用户名.github.io在浏览器中粘贴，访问。看到如下页面（即使我们刚刚输入的内容） To Be Continued…(未完待续) 视频教程-node安装视频教程-github注册","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"},{"name":"博客","slug":"博客","permalink":"https://www.hojun.cn/tags/博客/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"评论系统之来必力","slug":"评论系统之来必力","date":"2018-06-04T12:47:20.000Z","updated":"2018-08-11T15:24:47.426Z","comments":true,"path":"2018/06/04/评论系统之来必力/","link":"","permalink":"https://www.hojun.cn/2018/06/04/评论系统之来必力/","excerpt":"","text":"前言最近发现了一个比较实用的评论系统，花了几分钟注册使用它 ————来必力 使用教程第一步打开来必力首页，点击安装 第二步选择City 第三步注册选择个人-&gt;安装代码-&gt;引入到自己博客（这里没截图，略过） 后台管理 页面效果","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"评论","slug":"评论","permalink":"https://www.hojun.cn/tags/评论/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js深入篇(三、状态过渡)","slug":"vue-js深入篇-三、状态过渡","date":"2018-06-02T09:09:31.000Z","updated":"2018-08-11T15:24:50.404Z","comments":true,"path":"2018/06/02/vue-js深入篇-三、状态过渡/","link":"","permalink":"https://www.hojun.cn/2018/06/02/vue-js深入篇-三、状态过渡/","excerpt":"","text":"状态过渡Vue 的过渡系统提供了非常多简单的方法设置进入、离开和列表的动效。那么对于数据元素本身的动效呢，比如： 数字和运算 颜色的显示 SVG 节点的位置 元素的大小和其他的属性 所有的原始数字都被事先存储起来，可以直接转换到数字。做到这一步，我们就可以结合 Vue 的响应式和组件系统，使用第三方库来实现切换元素的过渡状态。 状态动画与侦听器通过侦听器我们能监听到任何数值属性的数值更新。可能听起来很抽象，所以让我们先来看看使用 GreenSock 一个例子：12345678910111213141516171819202122232425&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/gsap/1.20.3/TweenMax.min.js\"&gt;&lt;/script&gt;&lt;div id=\"animated-number-demo\"&gt; &lt;input v-model.number=\"number\" type=\"number\" step=\"20\"&gt; &lt;p&gt;&#123;&#123; animatedNumber &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#animated-number-demo', data: &#123; number: 0, tweenedNumber: 0 &#125;, computed: &#123; animatedNumber: function() &#123; return this.tweenedNumber.toFixed(0); &#125; &#125;, watch: &#123; number: function(newValue) &#123; TweenLite.to(this.$data, 0.5, &#123; tweenedNumber: newValue &#125;); &#125; &#125;&#125;)&lt;/script&gt; {{ animatedNumber }} new Vue({ el: '#animated-number-demo', data: { number: 0, tweenedNumber: 0 }, computed: { animatedNumber: function() { return this.tweenedNumber.toFixed(0); } }, watch: { number: function(newValue) { TweenLite.to(this.$data, 0.5, { tweenedNumber: newValue }); } } }) 当你把数值更新时，就会触发动画。这个是一个不错的演示，但是对于不能直接像数字一样存储的值，比如 CSS 中的 color 的值，通过下面的例子我们来通过 Tween.js 和 Color.js 实现一个例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;script src=\"https://cdn.jsdelivr.net/npm/tween.js@16.3.4\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/color-js@1.0.3\"&gt;&lt;/script&gt;&lt;div id=\"example-7\"&gt; &lt;input v-model=\"colorQuery\" v-on:keyup.enter=\"updateColor\" placeholder=\"Enter a color\" &gt; &lt;button v-on:click=\"updateColor\"&gt;Update&lt;/button&gt; &lt;p&gt;Preview:&lt;/p&gt; &lt;span v-bind:style=\"&#123; backgroundColor: tweenedCSSColor &#125;\" class=\"example-7-color-preview\" &gt;&lt;/span&gt; &lt;p&gt;&#123;&#123; tweenedCSSColor &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var Color = net.brehaut.Colornew Vue(&#123; el: '#example-7', data: &#123; colorQuery: '', color: &#123; red: 0, green: 0, blue: 0, alpha: 1 &#125;, tweenedColor: &#123;&#125; &#125;, created: function () &#123; this.tweenedColor = Object.assign(&#123;&#125;, this.color) &#125;, watch: &#123; color: function () &#123; function animate () &#123; if (TWEEN.update()) &#123; requestAnimationFrame(animate) &#125; &#125; new TWEEN.Tween(this.tweenedColor) .to(this.color, 750) .start() animate() &#125; &#125;, computed: &#123; tweenedCSSColor: function () &#123; return new Color(&#123; red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha &#125;).toCSS() &#125; &#125;, methods: &#123; updateColor: function () &#123; this.color = new Color(this.colorQuery).toRGB() this.colorQuery = '' &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt;.example-7-color-preview &#123; display: inline-block; width: 50px; height: 50px;&#125;&lt;/style&gt; Update Preview: {{ tweenedCSSColor }} var Color = net.brehaut.Color new Vue({ el: '#example-7', data: { colorQuery: '', color: { red: 0, green: 0, blue: 0, alpha: 1 }, tweenedColor: {} }, created: function () { this.tweenedColor = Object.assign({}, this.color) }, watch: { color: function () { function animate () { if (TWEEN.update()) { requestAnimationFrame(animate) } } new TWEEN.Tween(this.tweenedColor) .to(this.color, 750) .start() animate() } }, computed: { tweenedCSSColor: function () { return new Color({ red: this.tweenedColor.red, green: this.tweenedColor.green, blue: this.tweenedColor.blue, alpha: this.tweenedColor.alpha }).toCSS() } }, methods: { updateColor: function () { this.color = new Color(this.colorQuery).toRGB() this.colorQuery = '' } } }) .example-7-color-preview { display: inline-block; width: 50px; height: 50px; } 动态状态过渡就像 Vue 的过渡组件一样，数据背后状态过渡会实时更新，这对于原型设计十分有用。当你修改一些变量，即使是一个简单的 SVG 多边形也可实现很多难以想象的效果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124&lt;style&gt;svg &#123; display: block; &#125;polygon &#123; fill: #41B883; &#125;circle &#123; fill: transparent; stroke: #35495E;&#125;input[type=\"range\"] &#123; display: block; width: 100%; margin-bottom: 15px;&#125;&lt;/style&gt;&lt;div id=\"app\"&gt; &lt;svg width=\"200\" height=\"200\"&gt; &lt;polygon :points=\"points\"&gt;&lt;/polygon&gt; &lt;circle cx=\"100\" cy=\"100\" r=\"90\"&gt;&lt;/circle&gt; &lt;/svg&gt; &lt;label&gt;Sides: &#123;&#123; sides &#125;&#125;&lt;/label&gt; &lt;input type=\"range\" min=\"3\" max=\"500\" v-model.number=\"sides\" &gt; &lt;label&gt;Minimum Radius: &#123;&#123; minRadius &#125;&#125;%&lt;/label&gt; &lt;input type=\"range\" min=\"0\" max=\"90\" v-model.number=\"minRadius\" &gt; &lt;label&gt;Update Interval: &#123;&#123; updateInterval &#125;&#125; milliseconds&lt;/label&gt; &lt;input type=\"range\" min=\"10\" max=\"2000\" v-model.number=\"updateInterval\" &gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: function () &#123; var defaultSides = 10 var stats = Array.apply(null, &#123; length: defaultSides &#125;) .map(function () &#123; return 100 &#125;) return &#123; stats: stats, points: generatePoints(stats), sides: defaultSides, minRadius: 50, interval: null, updateInterval: 500 &#125; &#125;, watch: &#123; sides: function (newSides, oldSides) &#123; var sidesDifference = newSides - oldSides if (sidesDifference &gt; 0) &#123; for (var i = 1; i &lt;= sidesDifference; i++) &#123; this.stats.push(this.newRandomValue()) &#125; &#125; else &#123; var absoluteSidesDifference = Math.abs(sidesDifference) for (var i = 1; i &lt;= absoluteSidesDifference; i++) &#123; this.stats.shift() &#125; &#125; &#125;, stats: function (newStats) &#123; TweenLite.to( this.$data, this.updateInterval / 1000, &#123; points: generatePoints(newStats) &#125; ) &#125;, updateInterval: function () &#123; this.resetInterval() &#125; &#125;, mounted: function () &#123; this.resetInterval() &#125;, methods: &#123; randomizeStats: function () &#123; var vm = this this.stats = this.stats.map(function () &#123; return vm.newRandomValue() &#125;) &#125;, newRandomValue: function () &#123; return Math.ceil(this.minRadius + Math.random() * (100 - this.minRadius)) &#125;, resetInterval: function () &#123; var vm = this clearInterval(this.interval) this.randomizeStats() this.interval = setInterval(function () &#123; vm.randomizeStats() &#125;, this.updateInterval) &#125; &#125;&#125;)function valueToPoint (value, index, total) &#123; var x = 0 var y = -value * 0.9 var angle = Math.PI * 2 / total * index var cos = Math.cos(angle) var sin = Math.sin(angle) var tx = x * cos - y * sin + 100 var ty = x * sin + y * cos + 100 return &#123; x: tx, y: ty &#125;&#125;function generatePoints (stats) &#123; var total = stats.length return stats.map(function (stat, index) &#123; var point = valueToPoint(stat, index, total) return point.x + ',' + point.y &#125;).join(' ')&#125;&lt;/script&gt; svg { display: block; } polygon { fill: #41B883; } circle { fill: transparent; stroke: #35495E; } input[type=\"range\"] { display: block; width: 100%; margin-bottom: 15px; } Sides: {{ sides }} Minimum Radius: {{ minRadius }}% Update Interval: {{ updateInterval }} milliseconds new Vue({ el: '#app', data: function () { var defaultSides = 10 var stats = Array.apply(null, { length: defaultSides }) .map(function () { return 100 }) return { stats: stats, points: generatePoints(stats), sides: defaultSides, minRadius: 50, interval: null, updateInterval: 500 } }, watch: { sides: function (newSides, oldSides) { var sidesDifference = newSides - oldSides if (sidesDifference > 0) { for (var i = 1; i","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"六一儿童节flag","slug":"六一儿童节flag","date":"2018-06-01T15:47:11.000Z","updated":"2018-08-11T15:24:44.982Z","comments":true,"path":"2018/06/01/六一儿童节flag/","link":"","permalink":"https://www.hojun.cn/2018/06/01/六一儿童节flag/","excerpt":"","text":"多做一月一或多本本（心理）（hacker）(技术的)（其他的）每日锻炼每日coding每日视频每日动漫每日眼保每日整理 少做少吃荤菜少玩游戏（一小时以内）少熬夜(11点)少烦恼","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"节日","slug":"节日","permalink":"https://www.hojun.cn/tags/节日/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"vue.js深入篇(二、过渡效果下篇)","slug":"vue-js深入篇-二、过渡效果下篇","date":"2018-06-01T12:58:03.000Z","updated":"2018-08-11T15:24:50.471Z","comments":true,"path":"2018/06/01/vue-js深入篇-二、过渡效果下篇/","link":"","permalink":"https://www.hojun.cn/2018/06/01/vue-js深入篇-二、过渡效果下篇/","excerpt":"","text":"列表的进入/离开过渡现在让我们由一个简单的例子深入，进入和离开的过渡使用之前一样的 CSS 类名。1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;div id=\"list-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"add\"&gt;Add&lt;/button&gt; &lt;button v-on:click=\"remove\"&gt;Remove&lt;/button&gt; &lt;transition-group name=\"list\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" :key=\"item\" class=\"list-item\"&gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#list-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, &#125;&#125;)&lt;/script&gt;&lt;style&gt;.list-item &#123; display: inline-block; margin-right: 10px;&#125;.list-enter-active, .list-leave-active &#123; transition: all 1s;&#125;.list-enter, .list-leave-active &#123; opacity: 0; transform: translateY(30px);&#125;&lt;/style&gt; Add Remove {{ item }} new Vue({ el: '#list-demo1', data: { items: [1,2,3,4,5,6,7,8,9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, } }) .list-item { display: inline-block; margin-right: 10px; } .list-enter-active, .list-leave-active { transition: all 1s; } .list-enter, .list-leave-active { opacity: 0; transform: translateY(30px); } 这个例子有个问题，当添加和移除元素的时候，周围的元素会瞬间移动到他们的新布局的位置，而不是平滑的过渡，我们下面会解决这个问题。 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。像之前的类名一样，可以通过 name 属性来自定义前缀，也可以通过 move-class 属性手动设置。v-move 对于设置过渡的切换时机和过渡曲线非常有用，你会看到如下的例子： 12345678910111213141516171819202122232425262728&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;div id=\"flip-list-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt; &lt;transition-group name=\"flip-list\" tag=\"ul\"&gt; &lt;li v-for=\"item in items\" v-bind:key=\"item\"&gt; &#123;&#123; item &#125;&#125; &lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#flip-list-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9] &#125;, methods: &#123; shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt;.flip-list-move &#123; transition: transform 1s;&#125;&lt;/style&gt; Shuffle {{ item }} new Vue({ el: '#flip-list-demo', data: { items: [1,2,3,4,5,6,7,8,9] }, methods: { shuffle: function () { this.items = _.shuffle(this.items) } } }) .flip-list-move { transition: transform 1s; } 这个看起来很神奇，内部的实现，Vue 使用了一个叫 FLIP 简单的动画队列使用 transforms 将元素从之前的位置平滑过渡新的位置。我们将之前实现的例子和这个技术结合，使我们列表的一切变动都会有动画过渡。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;div id=\"list-complete-demo\" class=\"demo\"&gt; &lt;button v-on:click=\"shuffle\"&gt;Shuffle&lt;/button&gt; &lt;button v-on:click=\"add\"&gt;Add&lt;/button&gt; &lt;button v-on:click=\"remove\"&gt;Remove&lt;/button&gt; &lt;transition-group name=\"list-complete\" tag=\"p\"&gt; &lt;span v-for=\"item in items\" v-bind:key=\"item\" class=\"list-complete-item\" &gt; &#123;&#123; item &#125;&#125; &lt;/span&gt; &lt;/transition-group&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#list-complete-demo', data: &#123; items: [1,2,3,4,5,6,7,8,9], nextNum: 10 &#125;, methods: &#123; randomIndex: function () &#123; return Math.floor(Math.random() * this.items.length) &#125;, add: function () &#123; this.items.splice(this.randomIndex(), 0, this.nextNum++) &#125;, remove: function () &#123; this.items.splice(this.randomIndex(), 1) &#125;, shuffle: function () &#123; this.items = _.shuffle(this.items) &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt;.list-complete-item &#123; transition: all 1s; display: inline-block; margin-right: 10px;&#125;.list-complete-enter, .list-complete-leave-to/* .list-complete-leave-active for below version 2.1.8 */ &#123; opacity: 0; transform: translateY(30px);&#125;.list-complete-leave-active &#123; position: absolute;&#125; &lt;/style&gt; Shuffle Add Remove {{ item }} new Vue({ el: '#list-complete-demo', data: { items: [1,2,3,4,5,6,7,8,9], nextNum: 10 }, methods: { randomIndex: function () { return Math.floor(Math.random() * this.items.length) }, add: function () { this.items.splice(this.randomIndex(), 0, this.nextNum++) }, remove: function () { this.items.splice(this.randomIndex(), 1) }, shuffle: function () { this.items = _.shuffle(this.items) } } }) .list-complete-item { transition: all 1s; display: inline-block; margin-right: 10px; } .list-complete-enter, .list-complete-leave-to /* .list-complete-leave-active for below version 2.1.8 */ { opacity: 0; transform: translateY(30px); } .list-complete-leave-active { position: absolute; } 需要注意的是使用 FLIP 过渡的元素不能设置为 display: inline 。作为替代方案，可以设置为 display: inline-block 或者放置于 flex 中。FLIP 动画不仅可以实现单列过渡，多维网格也同样可以过渡：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.14.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;div id=\"sudoku-demo\" class=\"demo\"&gt; &lt;strong&gt;Lazy Sudoku&lt;/strong&gt; &lt;p&gt;Keep hitting the shuffle button until you win.&lt;/p&gt; &lt;button @click=\"shuffle\"&gt; Shuffle &lt;/button&gt; &lt;transition-group name=\"cell\" tag=\"div\" class=\"sudoku-container\"&gt; &lt;div v-for=\"cell in cells\" :key=\"cell.id\" class=\"cell\"&gt; &#123;&#123; cell.number &#125;&#125; &lt;/div&gt; &lt;/transition-group&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#sudoku-demo', data: &#123; cells: Array.apply(null, &#123; length: 81 &#125;) .map(function (_, index) &#123; return &#123; id: index, number: index % 9 + 1 &#125; &#125;) &#125;, methods: &#123; shuffle: function () &#123; this.cells = _.shuffle(this.cells) &#125; &#125;&#125;)&lt;/script&gt;&lt;style&gt;.sudoku-container &#123; display: flex; flex-wrap: wrap; width: 238px; margin-top: 10px;&#125;.cell &#123; display: flex; justify-content: space-around; align-items: center; width: 25px; height: 25px; border: 1px solid #aaa; margin-right: -1px; margin-bottom: -1px;&#125;.cell:nth-child(3n) &#123; margin-right: 0;&#125;.cell:nth-child(27n) &#123; margin-bottom: 0;&#125;.cell-move &#123; transition: transform 1s;&#125;&lt;/style&gt; Lazy Sudoku Keep hitting the shuffle button until you win. Shuffle {{ cell.number }} new Vue({ el: '#sudoku-demo', data: { cells: Array.apply(null, { length: 81 }) .map(function (_, index) { return { id: index, number: index % 9 + 1 } }) }, methods: { shuffle: function () { this.cells = _.shuffle(this.cells) } } }) .sudoku-container { display: flex; flex-wrap: wrap; width: 238px; margin-top: 10px; } .cell { display: flex; justify-content: space-around; align-items: center; width: 25px; height: 25px; border: 1px solid #aaa; margin-right: -1px; margin-bottom: -1px; } .cell:nth-child(3n) { margin-right: 0; } .cell:nth-child(27n) { margin-bottom: 0; } .cell-move { transition: transform 1s; } 列表的交错过渡通过 data 属性与 JavaScript 通信 ，就可以实现列表的交错过渡：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"staggered-list-demo\"&gt; &lt;input v-model=\"query\"&gt; &lt;transition-group name=\"staggered-fade\" tag=\"ul\" v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;li v-for=\"(item, index) in computedList\" v-bind:key=\"item.msg\" v-bind:data-index=\"index\" &gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt;new Vue(&#123; el: '#staggered-list-demo', data: &#123; query: '', list: [ &#123; msg: 'Bruce Lee' &#125;, &#123; msg: 'Jackie Chan' &#125;, &#123; msg: 'Chuck Norris' &#125;, &#123; msg: 'Jet Li' &#125;, &#123; msg: 'Kung Fury' &#125; ] &#125;, computed: &#123; computedList: function () &#123; var vm = this return this.list.filter(function (item) &#123; return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 &#125;) &#125; &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.height = 0 &#125;, enter: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 1, height: '1.6em' &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125;, leave: function (el, done) &#123; var delay = el.dataset.index * 150 setTimeout(function () &#123; Velocity( el, &#123; opacity: 0, height: 0 &#125;, &#123; complete: done &#125; ) &#125;, delay) &#125; &#125;&#125;) {{ item.msg }} new Vue({ el: '#staggered-list-demo', data: { query: '', list: [ { msg: 'Bruce Lee' }, { msg: 'Jackie Chan' }, { msg: 'Chuck Norris' }, { msg: 'Jet Li' }, { msg: 'Kung Fury' } ] }, computed: { computedList: function () { var vm = this return this.list.filter(function (item) { return item.msg.toLowerCase().indexOf(vm.query.toLowerCase()) !== -1 }) } }, methods: { beforeEnter: function (el) { el.style.opacity = 0 el.style.height = 0 }, enter: function (el, done) { var delay = el.dataset.index * 150 setTimeout(function () { Velocity( el, { opacity: 1, height: '1.6em' }, { complete: done } ) }, delay) }, leave: function (el, done) { var delay = el.dataset.index * 150 setTimeout(function () { Velocity( el, { opacity: 0, height: 0 }, { complete: done } ) }, delay) } } }) 可复用的过渡过渡可以通过 Vue 的组件系统实现复用。要创建一个可复用过渡组件，你需要做的就是将 &lt;transition&gt; 或者 &lt;transition-group&gt; 作为根组件，然后将任何子组件放置在其中就可以了。使用 template 的简单例子：1234567891011121314151617181920212223242526272829303132333435363738394041Vue.component('my-special-transition', &#123; template: '\\ &lt;transition\\ name=\"very-special-transition\"\\ mode=\"out-in\"\\ v-on:before-enter=\"beforeEnter\"\\ v-on:after-enter=\"afterEnter\"\\ &gt;\\ &lt;slot&gt;&lt;/slot&gt;\\ &lt;/transition&gt;\\ ', methods: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125;&#125;)函数组件更适合完成这个任务：Vue.component('my-special-transition', &#123; functional: true, render: function (createElement, context) &#123; var data = &#123; props: &#123; name: 'very-special-transition', mode: 'out-in' &#125;, on: &#123; beforeEnter: function (el) &#123; // ... &#125;, afterEnter: function (el) &#123; // ... &#125; &#125; &#125; return createElement('transition', data, context.children) &#125;&#125;) 动态过渡在 Vue 中即使是过渡也是数据驱动的！动态过渡最基本的例子是通过 name 特性来绑定动态值。123&lt;transition v-bind:name=\"transitionName\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 当你想用 Vue 的过渡系统来定义的 CSS 过渡/动画 在不同过渡间切换会非常有用。所有的过渡特性都是动态绑定。它不仅是简单的特性，通过事件的钩子函数方法，可以在获取到相应上下文数据。这意味着，可以根据组件的状态通过 JavaScript 过渡设置不同的过渡效果。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"dynamic-fade-demo\" class=\"demo\"&gt; Fade In: &lt;input type=\"range\" v-model=\"fadeInDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\"&gt; Fade Out: &lt;input type=\"range\" v-model=\"fadeOutDuration\" min=\"0\" v-bind:max=\"maxFadeDuration\"&gt; &lt;transition v-bind:css=\"false\" v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt; &lt;button v-if=\"stop\" v-on:click=\"stop = false; show = false\" &gt;Start animating&lt;/button&gt; &lt;button v-else v-on:click=\"stop = true\" &gt;Stop it!&lt;/button&gt;&lt;/div&gt;new Vue(&#123; el: '#dynamic-fade-demo', data: &#123; show: true, fadeInDuration: 1000, fadeOutDuration: 1000, maxFadeDuration: 1500, stop: true &#125;, mounted: function () &#123; this.show = false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 &#125;, enter: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 1 &#125;, &#123; duration: this.fadeInDuration, complete: function () &#123; done() if (!vm.stop) vm.show = false &#125; &#125; ) &#125;, leave: function (el, done) &#123; var vm = this Velocity(el, &#123; opacity: 0 &#125;, &#123; duration: this.fadeOutDuration, complete: function () &#123; done() vm.show = true &#125; &#125; ) &#125; &#125;&#125;) 最后，创建动态过渡的最终方案是组件通过接受 props 来动态修改之前的过渡。一句老话，唯一的限制是你的想象力。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js深入篇(二、过渡效果中篇)","slug":"vue-js深入篇-二、过渡效果中篇","date":"2018-06-01T11:15:09.000Z","updated":"2018-08-11T15:24:50.504Z","comments":true,"path":"2018/06/01/vue-js深入篇-二、过渡效果中篇/","link":"","permalink":"https://www.hojun.cn/2018/06/01/vue-js深入篇-二、过渡效果中篇/","excerpt":"","text":"初始渲染的过渡可以通过 appear 特性设置节点在初始渲染的过渡123&lt;transition appear&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 这里默认和进入/离开过渡一样，同样也可以自定义 CSS 类名。12345678&lt;transition appear appear-class=\"custom-appear-class\" appear-to-class=\"custom-appear-to-class\" (2.1.8+) appear-active-class=\"custom-appear-active-class\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 自定义 JavaScript 钩子：123456789&lt;transition appear v-on:before-appear=\"customBeforeAppearHook\" v-on:appear=\"customAppearHook\" v-on:after-appear=\"customAfterAppearHook\" v-on:appear-cancelled=\"customAppearCancelledHook\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 多个元素的过渡我们之后讨论多个组件的过渡，对于原生标签可以使用 v-if/v-else 。最常见的多标签过渡是一个列表和描述这个列表为空消息的元素：123456&lt;transition&gt; &lt;table v-if=\"items.length &gt; 0\"&gt; &lt;!-- ... --&gt; &lt;/table&gt; &lt;p v-else&gt;Sorry, no items found.&lt;/p&gt;&lt;/transition&gt; 可以这样使用，但是有一点需要注意：当有相同标签名的元素切换时，需要通过 key 特性设置唯一的值来标记以让 Vue 区分它们，否则 Vue 为了效率只会替换相同标签内部的内容。即使在技术上没有必要，给在 &lt;transition&gt; 组件中的多个元素设置 key 是一个更好的实践。 示例：12345678&lt;transition&gt; &lt;button v-if=\"isEditing\" key=\"save\"&gt; Save &lt;/button&gt; &lt;button v-else key=\"edit\"&gt; Edit &lt;/button&gt;&lt;/transition&gt; 在一些场景中，也可以通过给同一个元素的 key 特性设置不同的状态来代替 v-if 和 v-else，上面的例子可以重写为：12345&lt;transition&gt; &lt;button v-bind:key=\"isEditing\"&gt; &#123;&#123; isEditing ? 'Save' : 'Edit' &#125;&#125; &lt;/button&gt;&lt;/transition&gt; 使用多个 v-if 的多个元素的过渡可以重写为绑定了动态属性的单个元素过渡。例如：1234567891011&lt;transition&gt; &lt;button v-if=\"docState === 'saved'\" key=\"saved\"&gt; Edit &lt;/button&gt; &lt;button v-if=\"docState === 'edited'\" key=\"edited\"&gt; Save &lt;/button&gt; &lt;button v-if=\"docState === 'editing'\" key=\"editing\"&gt; Cancel &lt;/button&gt;&lt;/transition&gt; 可以重写为：123456789101112131415&lt;transition&gt; &lt;button v-bind:key=\"docState\"&gt; &#123;&#123; buttonMessage &#125;&#125; &lt;/button&gt;&lt;/transition&gt;// ...computed: &#123; buttonMessage: function () &#123; switch (this.docState) &#123; case 'saved': return 'Edit' case 'edited': return 'Save' case 'editing': return 'Cancel' &#125; &#125;&#125; 过渡模式这里还有一个问题，试着点击下面的按钮：123456789101112131415161718192021222324252627&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;div id=\"no-mode-demo\" class=\"demo\"&gt; &lt;transition name=\"no-mode-fade\"&gt; &lt;button v-if=\"on\" key=\"on\" @click=\"on = false\"&gt; on &lt;/button&gt; &lt;button v-else key=\"off\" @click=\"on = true\"&gt; off &lt;/button&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#no-mode-demo', data: &#123; on: false &#125;&#125;)&lt;/script&gt;&lt;style&gt;.no-mode-fade-enter-active, .no-mode-fade-leave-active &#123; transition: opacity .5s&#125;.no-mode-fade-enter, .no-mode-fade-leave-active &#123; opacity: 0&#125;&lt;/style&gt; on off new Vue({ el: '#no-mode-demo', data: { on: false } }) .no-mode-fade-enter-active, .no-mode-fade-leave-active { transition: opacity .5s } .no-mode-fade-enter, .no-mode-fade-leave-active { opacity: 0 } 在 “on” 按钮和 “off” 按钮的过渡中，两个按钮都被重绘了，一个离开过渡的时候另一个开始进入过渡。这是 &lt;transition&gt; 的默认行为 - 进入和离开同时发生。 在元素绝对定位在彼此之上的时候运行正常：1234567.no-mode-absolute-demo-wrapper &#123; position: relative; height: 18px;&#125;.no-mode-absolute-demo-wrapper button &#123; position: absolute;&#125; on off new Vue({ el: '#no-mode-demo2', data: { on: false } }) .no-mode-fade2-enter-active, .no-mode-fade2-leave-active { transition: opacity .5s } .no-mode-fade2-enter, .no-mode-fade2-leave-active { opacity: 0 } .no-mode-absolute-demo-wrapper { position: relative; height: 18px; } .no-mode-absolute-demo-wrapper button { position: absolute; } 然后，我们加上 translate 让它们运动像滑动过渡：123456.no-mode-translate-fade-enter &#123; transform: translateX(31px);&#125;.no-mode-translate-fade-leave-active &#123; transform: translateX(-31px);&#125; on off new Vue({ el: '#no-mode-translate-demo', data: { on: false } }) .no-mode-translate-demo-wrapper { position: relative; height: 18px; } .no-mode-translate-demo-wrapper button { position: absolute; } .no-mode-translate-fade-enter-active, .no-mode-translate-fade-leave-active { transition: all 1s; } .no-mode-translate-fade-enter, .no-mode-translate-fade-leave-active { opacity: 0; } .no-mode-translate-fade-enter { transform: translateX(31px); } .no-mode-translate-fade-leave-active { transform: translateX(-31px); } 同时生效的进入和离开的过渡不能满足所有要求，所以 Vue 提供了 过渡模式 in-out: 新元素先进行过渡，完成之后当前元素过渡离开。 out-in: 当前元素先进行过渡，完成之后新元素过渡进入。 用 out-in 重写之前的开关按钮过渡：123&lt;transition name=\"fade\" mode=\"out-in\"&gt;&lt;!-- ... the buttons ... --&gt;&lt;/transition&gt; 123456789101112131415161718192021222324252627&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;div id=\"with-mode-demo\" class=\"demo\"&gt; &lt;transition name=\"with-mode-fade\" mode=\"out-in\"&gt; &lt;button v-if=\"on\" key=\"on\" @click=\"on = false\"&gt; on &lt;/button&gt; &lt;button v-else=\"\" key=\"off\" @click=\"on = true\"&gt; off &lt;/button&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#with-mode-demo', data: &#123; on: false &#125;&#125;)&lt;/script&gt;&lt;style&gt;.with-mode-fade-enter-active, .with-mode-fade-leave-active &#123; transition: opacity .5s&#125;.with-mode-fade-enter, .with-mode-fade-leave-active &#123; opacity: 0&#125;&lt;/style&gt; on off new Vue({ el: '#with-mode-demo', data: { on: false } }) .with-mode-fade-enter-active, .with-mode-fade-leave-active { transition: opacity .5s } .with-mode-fade-enter, .with-mode-fade-leave-active { opacity: 0 } 只用添加一个简单的特性，就解决了之前的过渡问题而无需任何额外的代码。 in-out 模式不是经常用到，但对于一些稍微不同的过渡效果还是有用的。将之前滑动淡出的例子结合：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;div id=\"in-out-translate-demo\" class=\"demo\"&gt; &lt;div class=\"in-out-translate-demo-wrapper\"&gt; &lt;transition name=\"in-out-translate-fade\" mode=\"in-out\"&gt; &lt;button v-if=\"on\" key=\"on\" @click=\"on = false\"&gt; on &lt;/button&gt; &lt;button v-else=\"\" key=\"off\" @click=\"on = true\"&gt; off &lt;/button&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#in-out-translate-demo', data: &#123; on: false &#125;&#125;)&lt;/script&gt;&lt;style&gt;.in-out-translate-demo-wrapper &#123; position: relative; height: 18px;&#125;.in-out-translate-demo-wrapper button &#123; position: absolute;&#125;.in-out-translate-fade-enter-active, .in-out-translate-fade-leave-active &#123; transition: all .5s;&#125;.in-out-translate-fade-enter, .in-out-translate-fade-leave-active &#123; opacity: 0;&#125;.in-out-translate-fade-enter &#123; transform: translateX(31px);&#125;.in-out-translate-fade-leave-active &#123; transform: translateX(-31px);&#125;&lt;/style&gt; on off new Vue({ el: '#in-out-translate-demo', data: { on: false } }) .in-out-translate-demo-wrapper { position: relative; height: 18px; } .in-out-translate-demo-wrapper button { position: absolute; } .in-out-translate-fade-enter-active, .in-out-translate-fade-leave-active { transition: all .5s; } .in-out-translate-fade-enter, .in-out-translate-fade-leave-active { opacity: 0; } .in-out-translate-fade-enter { transform: translateX(31px); } .in-out-translate-fade-leave-active { transform: translateX(-31px); } 多个组件的过渡多个组件的过渡简单很多 - 我们不需要使用 key 特性。相反，我们只需要使用动态组件：123456789101112131415161718192021222324&lt;transition name=\"component-fade\" mode=\"out-in\"&gt; &lt;component v-bind:is=\"view\"&gt;&lt;/component&gt;&lt;/transition&gt;new Vue(&#123; el: '#transition-components-demo', data: &#123; view: 'v-a' &#125;, components: &#123; 'v-a': &#123; template: '&lt;div&gt;Component A&lt;/div&gt;' &#125;, 'v-b': &#123; template: '&lt;div&gt;Component B&lt;/div&gt;' &#125; &#125;&#125;).component-fade-enter-active, .component-fade-leave-active &#123; transition: opacity .3s ease;&#125;.component-fade-enter, .component-fade-leave-to/* .component-fade-leave-active for below version 2.1.8 */ &#123; opacity: 0;&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js深入篇(二、过渡效果上篇)","slug":"vue-js深入篇-二、过渡效果上篇","date":"2018-05-30T14:18:20.000Z","updated":"2018-08-11T15:24:50.438Z","comments":true,"path":"2018/05/30/vue-js深入篇-二、过渡效果上篇/","link":"","permalink":"https://www.hojun.cn/2018/05/30/vue-js深入篇-二、过渡效果上篇/","excerpt":"","text":"Vue 在插入、更新或者移除 DOM 时，提供多种不同方式的应用过渡效果。包括以下工具： 在 CSS 过渡和动画中自动应用 class 可以配合使用第三方 CSS 动画库，如 Animate.css 在过渡钩子函数中使用 JavaScript 直接操作 DOM 可以配合使用第三方 JavaScript 动画库，如 Velocity.js 单元素/组件的过渡Vue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 举个例子：1234567891011121314151617181920212223242526&lt;style type=\"text/css\"&gt;.fade-enter-active, .fade-leave-active &#123; transition: opacity .5s&#125;.fade-enter, .fade-leave-active &#123; opacity: 0&#125;&lt;/style&gt;&lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt;&lt;div id=\"demo\"&gt; &lt;button v-on:click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition name=\"fade\"&gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; new Vue(&#123; el: '#demo', data: &#123; show: true &#125; &#125;)&lt;/script&gt; 当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理： 自动嗅探目标元素是否应用了 CSS 过渡或动画，如果是，在恰当的时机添加/删除 CSS 类名。 如果过渡组件提供了 JavaScript 钩子函数，这些钩子函数将在恰当的时机被调用。 如果没有找到 JavaScript 钩子并且也没有检测到 CSS 过渡/动画，DOM 操作 (插入/删除) 在下一帧中立即执行。(注意：此指浏览器逐帧动画机制，和 Vue 的 nextTick 概念不同) 过渡的类名在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 &lt;transition&gt;，则 v- 是这些类名的默认前缀。如果你使用了 &lt;transition name=&quot;my-transition&quot;&gt;，那么 v-enter 会替换为 my-transition-enter。v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线。 CSS动画上面的例子使用的CSS过滤，下面我们来看一种CSS动画的实现方式。1234567891011121314151617181920212223242526272829303132333435&lt;style type=\"text/css\"&gt;.bounce-enter-active &#123; animation: bounce-in .5s;&#125;.bounce-leave-active &#123; animation: bounce-in .5s reverse;&#125;@keyframes bounce-in &#123; 0% &#123; transform: scale(0); &#125; 50% &#123; transform: scale(1.5); &#125; 100% &#123; transform: scale(1); &#125;&#125;&lt;/style&gt;&lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example-2\"&gt; &lt;button @click=\"show = !show\"&gt;Toggle show&lt;/button&gt; &lt;transition name=\"bounce\"&gt; &lt;p v-if=\"show\"&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris facilisis enim libero, at lacinia diam fermentum id. Pellentesque habitant morbi tristique senectus et netus.&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;new Vue(&#123; el: '#example-2', data: &#123; show: true &#125;&#125;)&lt;/script&gt; 自定义过渡类名我们可以通过以下特性来自定义过渡类名： enter-class enter-active-class enter-to-class (2.1.8+) leave-class leave-active-class leave-to-class (2.1.8+) 他们的优先级高于普通的类名，这对于 Vue 的过渡系统和其他第三方 CSS 动画库，如 Animate.css 结合使用十分有用。 1234567891011121314151617181920212223&lt;link href=\"https://unpkg.com/animate.css@3.5.1/animate.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;&lt;div id=\"example-3\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle render &lt;/button&gt; &lt;transition name=\"custom-classes-transition\" enter-active-class=\"animated tada\" leave-active-class=\"animated bounceOutRight\" &gt; &lt;p v-if=\"show\"&gt;hello&lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;&lt;script src=\"https://unpkg.com/vue/dist/vue.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt;new Vue(&#123; el: '#example-3', data: &#123; show: true &#125;&#125;)&lt;/script&gt; 同时使用过渡和动画Vue 为了知道过渡的完成，必须设置相应的事件监听器。它可以是 transitionend 或 animationend ，这取决于给元素应用的 CSS 规则。如果你使用其中任何一种，Vue 能自动识别类型并设置监听。 但是，在一些场景中，你需要给同一个元素同时设置两种过渡动效，比如 animation 很快的被触发并完成了，而 transition 效果还没结束。在这种情况中，你就需要使用 type 特性并设置 animation 或 transition 来明确声明你需要 Vue 监听的类型。 JavaScript 钩子可以在属性中声明 JavaScript 钩子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:after-enter=\"afterEnter\" v-on:enter-cancelled=\"enterCancelled\" v-on:before-leave=\"beforeLeave\" v-on:leave=\"leave\" v-on:after-leave=\"afterLeave\" v-on:leave-cancelled=\"leaveCancelled\"&gt; &lt;!-- ... --&gt;&lt;/transition&gt;// ...methods: &#123; // -------- // 进入中 // -------- beforeEnter: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 enter: function (el, done) &#123; // ... done() &#125;, afterEnter: function (el) &#123; // ... &#125;, enterCancelled: function (el) &#123; // ... &#125;, // -------- // 离开时 // -------- beforeLeave: function (el) &#123; // ... &#125;, // 此回调函数是可选项的设置 // 与 CSS 结合时使用 leave: function (el, done) &#123; // ... done() &#125;, afterLeave: function (el) &#123; // ... &#125;, // leaveCancelled 只用于 v-show 中 leaveCancelled: function (el) &#123; // ... &#125;&#125; 这些钩子函数可以结合 CSS transitions/animations 使用，也可以单独使用。当只用 JavaScript 过渡的时候， 在 enter 和 leave 中，回调函数 done 是必须的 。否则，它们会被同步调用，过渡会立即完成。 推荐对于仅使用 JavaScript 过渡的元素添加 v-bind:css=”false”，Vue 会跳过 CSS 的检测。这也可以避免过渡过程中 CSS 的影响。 一个使用 Velocity.js 的简单例子：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!--Velocity 和 jQuery.animate 的工作方式类似，也是用来实现 JavaScript 动画的一个很棒的选择--&gt;&lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/velocity/1.2.3/velocity.min.js\"&gt;&lt;/script&gt;&lt;div id=\"example-4\"&gt; &lt;button @click=\"show = !show\"&gt; Toggle &lt;/button&gt; &lt;transition v-on:before-enter=\"beforeEnter\" v-on:enter=\"enter\" v-on:leave=\"leave\" v-bind:css=\"false\" &gt; &lt;p v-if=\"show\"&gt; Demo &lt;/p&gt; &lt;/transition&gt;&lt;/div&gt;new Vue(&#123; el: '#example-4', data: &#123; show: false &#125;, methods: &#123; beforeEnter: function (el) &#123; el.style.opacity = 0 el.style.transformOrigin = 'left' &#125;, enter: function (el, done) &#123; Velocity(el, &#123; opacity: 1, fontSize: '1.4em' &#125;, &#123; duration: 300 &#125;) Velocity(el, &#123; fontSize: '1em' &#125;, &#123; complete: done &#125;) &#125;, leave: function (el, done) &#123; Velocity(el, &#123; translateX: '15px', rotateZ: '50deg' &#125;, &#123; duration: 600 &#125;) Velocity(el, &#123; rotateZ: '100deg' &#125;, &#123; loop: 2 &#125;) Velocity(el, &#123; rotateZ: '45deg', translateY: '30px', translateX: '30px', opacity: 0 &#125;, &#123; complete: done &#125;) &#125; &#125;&#125;)","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"软考备考之前趋图PV操作","slug":"软考备考之前趋图PV操作","date":"2018-05-30T04:55:31.000Z","updated":"2018-08-11T15:24:47.671Z","comments":true,"path":"2018/05/30/软考备考之前趋图PV操作/","link":"","permalink":"https://www.hojun.cn/2018/05/30/软考备考之前趋图PV操作/","excerpt":"","text":"来源https://blog.csdn.net/mengmei16/article/details/49453869 我们对于P、V的含义肯定不陌生。 P（S）：①将信号量S的值减1，即S=S-1； ②如果S&gt;=0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。V（S）：①将信号量S的值加1，即S=S+1； ②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。 概念理解的再透彻，也不过是纸上谈兵。 例：看一道我们在软考中经常遇到的题，每次都束手无策的那道。 P操作，我们可以看作是获得或者请求、消耗一个信号量。 V操作，我们可以看作是释放或者发送一个信号量。 我们可以这样理解：看前驱图， P1执行完之后，会向P2和P3分别发送两个信号S1和S2（所以a处填V（S1）V（S2）； 然后是P2执行，P2执行之前，要先获得S1（所以b处填P（S1））; P2执行完之后，会向P3发送一个信号S3（所以b下一处为V（S3））； P3执行之前，要先获得P2发送给P3的信号，也要获得P1发送给P3的信号（所以c处填（P（S2）P（S3）））；P3执行完后，会向P4发送一个信号S4（所以c下一处为V（S4））； P4执行之前，要先获得P3发送给P4的信号方可执行（所以d处填P（S4））。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://www.hojun.cn/tags/软考/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"软考之软件设计师经验总结","slug":"软考之软件设计师经验总结","date":"2018-05-30T04:53:30.000Z","updated":"2018-08-11T15:24:47.560Z","comments":true,"path":"2018/05/30/软考之软件设计师经验总结/","link":"","permalink":"https://www.hojun.cn/2018/05/30/软考之软件设计师经验总结/","excerpt":"","text":"前言26日急急忙忙考完软考之后总算解决掉一件事情，今后的日子也不用慌慌张张的备考了。嘤嘤嘤~这篇文章主要来总结下这次软考备考过程。 咳咳，首先是备考。恩……大概是从考前20天，5月6日前后开始的。（笔记为证）报考的是软件设计师中级。觉得有实力的可以选择直接报考高级的。下图是报考类别： 全国计算机技术与软件专业技术资格（水平）考试考试级别 选择软件设计师主要是因为大学时期有去考过一次，记得上午卷是过了，下午没过。所以难点还是下午卷。上午75道选择题只要刷下历年试卷，弄懂一些重点的考点。考过基本没问题。（上下午都是75分卷，45分及格）。 回顾下这20几天备考，反省下自己大部分的时间都在都在都在都在……不知道干嘛了。大致考前一星期才觉得快来不及了去努力啃考试教材。可惜其他事情忙忙~耽误耽误，到最后也才看了半本书TOT。（注：大学是也没好好备考，就算备过得也忘得差不多了）。 废话不多说，直接来点干货。本次考试还是按规矩来的，重点考点都有，下午试卷的考题也是中规中矩（本人觉得这次题目较为简单）。 上午试题以下内容全凭作者小脑袋记住，内容不全敬请谅解，个人见解仅供参考 海明校验码 考到了而且这次考得比较细，要求你理解掌握海明校验码的实现原理了。不只是简单的考察2^r-1 ≥ k + r这个公式了。详细理解可以看我之前的文章《简单理解海明校验码》 Gantt和PERT图 考到了考得还是常见套路：考得的种图的特点 甘特图特点：能清晰的描述每个任务从何时开始，到何时结束，以及任务之间的并行关系。但是他不能清晰的反应出各任务的依赖关系。 PERT图特点：不仅给出了每个任务的开始时间、结束时间和完成该任务所需的时间，还给出了任务之间的关系。在PERT图中，关键路径是图中最长的一条路径。而松弛时间则反映了完成某些任务时可以推迟其开始时间或延长其所需完成的事件。但是PERT图不能反应任务之间的并行关系。 以及PERT图的关键路线（累计时间最长的的路线称为关键路径）和某小段线路的最迟开始时间。 正规式 考到了考得就是正规式的转换。 正规式是一种表示正规集的工具，正规式是描述程序语言单词的表达式，对于字母表∑。运算符“|”、“·”、“*”分别称为“或”、“连接”和“闭包”。在正规式的书写中，连接运算符“·”可省略。运算符的优先级从高到低顺序排列为：“*”、“·”、“|”。运算符“|”表示“或”、并集。“*”表示*之前括号里的内容出现0次或多次。若两个正规式表示的正规集相同，则认为二者等价。两个等价的正规集U和V记作U=V。b(ab)*=(ba)*b,(a|b)*=(a*b*)*需要注意的是，编译原理里面的正规式叫做范式，和正则表达式不是一个概念，但是有相通之处：都是通过一定的语法规则来描述文法，也就是所谓的匹配。 易错点：ab* 不是 0~n个ab, 而是a + 若干个b(包括0个)。完整的写法应该是 a.b*。 (ab)* 才是若干个ab。 后缀式 考到了考得就是后缀式的转换。 后缀表达式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。 举个简单的好理解干货例子：1234567891011a+b*(c+d/e)(a+(b*(c+(d/e)))) 按计算顺序加上括号(a(b(c(de)/)+)*)+ 把运算符放到括号外面abcde/+*+ 去掉括号a&amp;b|c&amp;(b|x&gt;0)(a&amp;b)|(c&amp;(b|(x&gt;0)))((a&amp;b)|(c&amp;(b|(x&gt;0)))) 把运算符放到括号外面注意(a&amp;b)先运算,得：((ab)&amp;(c(b(x0)&gt;)|)&amp;)| 去掉括号得：ab&amp;cbx0&gt;|&amp;| McCabe度量法 考到了MaCabe度量法是通过定义环路复杂度，建立程序复杂性的度量，它基于一个程序模块的程序图中的环路的个数。计算有向图G的环路复杂性的公式为V(G) = m - n + 2，其中V(G)是有向图G中的环路个数，m是G中的有向弧数，n是G中的节点数。 前趋图PV操作 考到了详情查看《软考备考之前趋图PV操作》这篇文章 考到的还有 不说你也猜到UML图、二叉树、设计模式、算法时间复杂度、面向对象设计（多态）、几种经典的算法策略（分治、动态规划、贪心、回溯）、图表、网络协议和对应层的设备、软件著作权、CPU等等。 哦，最后顺带提一下考过浮点数运算的的流程:小阶对大阶，同时将小阶码对应的浮点数的尾数右移相应位数。这也是今年的考点之一。（之前也有考过） 下午试题第一道:用例图+流程图 一样的套路 第二题:数据库设计+实体联系图 一样的套路 第三题:用例图+类图 一样的套路（今年的考题是那种全部都是空的题型，只要认真审题，容易拿多分）前三题是拿分题，大家务必认真读题，写写画画，难度不大。第四题:一样的C语言算法题，还是一样的味道。 算法是求啥钢材长度价值的那种，怎样裁能得到最大价值。（之前好像考过，不知道是不是作者的错觉，觉得复习的时候见过，似曾相识）。 顺带吐槽下这道题……为啥么变量定义的时候都用单个字母表示而不用有具体含义的英文表示，这样在读代码的时候经常看到一半又忘了这个变量代表的值。无形中加大了这道算法题的难度。解题的时候可以自己给变量取个有语义的名称，带入理解可能会比较清晰。 代码的空填完就是考这题的算法设计采用啥策略以及算法的时间复杂度。 第五题:作者选择相对熟悉的java代码。这题考得是设计模式，如果你掌握了对应的设计模式，解起题来会比较容易。 安利一本设计模式的书《HeadFirst设计模式》，书上是用java代码做案例的，内容通俗易懂，推荐大家学习。 最后不管有没有考好，重要的是你在整个过程中有没有收获到新知识以及备考学习的乐趣。祝大家身体健康笑口常开233333~","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://www.hojun.cn/tags/软考/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js深入篇(一、响应式原理)","slug":"vue-js深入篇-一、响应式原理","date":"2018-05-29T11:15:53.000Z","updated":"2018-08-11T15:24:50.366Z","comments":true,"path":"2018/05/29/vue-js深入篇-一、响应式原理/","link":"","permalink":"https://www.hojun.cn/2018/05/29/vue-js深入篇-一、响应式原理/","excerpt":"","text":"让我们来回顾下Vue的介绍，可以发现Vue 最显著的一个功能是响应系统。那么它的实现原理有又是如何呢？ 如何追踪变化把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。这是 ES5 的特性，不能打补丁实现，这便是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。 用户看不到 getter/setters，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 vue-devtools 来获取更加友好的检查接口。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。 变化检测问题受现代 Javascript 的限制(以及 Object.observe 的废弃)，Vue 不能检测到对象属性的添加或删除。因为 Vue 在初始化实例时将属性转为 getter/setter，所以属性必须在 data 对象上才能让 Vue 转换它，这样才能让它是响应的。例如：12345678var vm = new Vue(&#123; data:&#123; a:1 &#125;&#125;)// `vm.a` 是响应的vm.b = 2// `vm.b` 是非响应的 Vue 不允许在已经创建的实例上动态添加新的根级响应式属性（root-level reactive properties）。然而它可以使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上：1Vue.set(vm.someObject, 'b', 2) 您还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名：1this.$set(this.someObject,'b',2) 有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。但是，添加到对象上的新属性不会触发更新。在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：12// 代替 `Object.assign(this.someObject, &#123; a: 1, b: 2 &#125;)`this.someObject = Object.assign(&#123;&#125;, this.someObject, &#123; a: 1, b: 2 &#125;) 也有一些数组相关的问题，之前已经在列表渲染中讲过。 由于 Vue 不允许动态添加根级响应式属性，所以你必须在初始化实例前声明根级响应式属性，哪怕只是一个空值:123456789var vm = new Vue(&#123; data: &#123; // 声明 message 为一个空值字符串 message: '' &#125;, template: '&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;'&#125;)// 之后设置 `message` vm.message = 'Hello!' 如果你不在 data 对象中声明 message，Vue 将发出警告表明你的渲染方法正试图访问一个不存在的属性。 这样的限制在背后是有其技术原因的，在依赖项跟踪系统中，它消除了一类边界情况，也使 Vue 实例在类型检查系统的帮助下运行的更高效。在代码可维护性方面上这也是重要的一点：data 对象就像组件状态的模式（Schema），在它上面声明所有的属性让组织代码更易于被其他开发者或是自己回头重新阅读时更加快速地理解。 异步更新队列你应该注意到 Vue 执行 DOM 更新是异步的，只要观察到数据变化，Vue 就开始一个队列，将同一事件循环内所有的数据变化缓存起来。如果一个 watcher 被多次触发，只会推入一次到队列中。然后，在接下来的事件循环中，Vue 刷新队列并仅执行必要的 DOM 更新。Vue 在内部使用 Promise.then 和 MutationObserver 为可用的异步队列调用回调 setTimeout(fn, 0). 例如，当你设置 vm.someData = ‘new value’，该组件不会马上被重新渲染。当刷新队列时，这个组件会在下一次事件循环清空队列时更新。我们基本不用关心这个过程，但是如果你想在 DOM 状态更新后做点什么，这就可能会有些棘手。一般来讲，Vue 鼓励开发者沿着数据驱动的思路，尽量避免直接接触 DOM，但是有时我们确实要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调在 DOM 更新完成后就会调用。例如：1&lt;div id=\"example\"&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt; 1234567891011var vm = new Vue(&#123;el: '#example', data: &#123; message: '123' &#125;&#125;)vm.message = 'new message' // 更改数据vm.$el.textContent === 'new message' // falseVue.nextTick(function () &#123; vm.$el.textContent === 'new message' // true&#125;) vm.$nextTick() 这个实例方法在组件内使用特别方便，因为它不需要全局 Vue，它的回调 this 将自动绑定到当前的 Vue 实例上：1234567891011121314151617Vue.component('example', &#123; template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;', data: function () &#123; return &#123; message: 'not updated' &#125; &#125;, methods: &#123; updateMessage: function () &#123; this.message = 'updated' console.log(this.$el.textContent) // =&gt; 'not updated' this.$nextTick(function () &#123; console.log(this.$el.textContent) // =&gt; 'updated' &#125;) &#125; &#125;&#125;)","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"峰谷电计算","slug":"峰谷电计算","date":"2018-05-26T15:41:34.000Z","updated":"2018-08-11T15:24:45.786Z","comments":true,"path":"2018/05/26/峰谷电计算/","link":"","permalink":"https://www.hojun.cn/2018/05/26/峰谷电计算/","excerpt":"","text":".field{ width: 100%; margin: 20px 0 0 0; font-size: 18px; } .calc{ height: 30px; width: 80px; text-align: center; margin: 40px 0 0 20px; background: #7bc549; border: none; color: #fff; } .fee{ color: #ff763b; font-weight: 700; } .pv-fee{ color: #7bc549; font-weight: 700; } 总电量: 峰电量: 计算 不执行峰谷总费用: 执行峰谷总费用: $(function(){ $('body').on('click', '.calc', function() { var t_price = 0.538; var p_price = 0.568; var v_price = 0.288; var total = Number($(\"input[name='total']\").val()); var peak = Number($(\"input[name='peak']\").val()); var fee = (total * (1000 * t_price)) / 1000; var pv_fee = (Number(peak * (1000 * p_price)) + Number((total - peak) * (1000 * v_price)))/1000; $('.fee').html(fee); $('.pv-fee').html(pv_fee); }) });","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://www.hojun.cn/tags/其他/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"vue.js初入门(十一组件-下篇)","slug":"vue-js初入门-十一组件-下篇","date":"2018-05-22T13:12:20.000Z","updated":"2018-08-11T15:24:50.227Z","comments":true,"path":"2018/05/22/vue-js初入门-十一组件-下篇/","link":"","permalink":"https://www.hojun.cn/2018/05/22/vue-js初入门-十一组件-下篇/","excerpt":"","text":"自定义事件我们知道，父组件是使用 props 传递数据给子组件，但如果子组件要把数据传递回去，应该怎样做？那就是自定义事件！使用 v-on 绑定自定义事件每个 Vue 实例都实现了事件接口(Events interface)，即： 使用 $on(eventName) 监听事件 使用 $emit(eventName) 触发事件 另外，父组件可以在使用子组件的地方直接用 v-on 来监听子组件触发的事件。 举个栗子：123456789101112131415161718192021222324252627282930313233343536373839404142&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue初入门&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; total &#125;&#125;&lt;/p&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;button-counter v-on:increment=\"incrementTotal\"&gt;&lt;/button-counter&gt; &lt;/div&gt;&lt;script&gt; Vue.component('button-counter', &#123; template: '&lt;button v-on:click=\"increment\"&gt;&#123;&#123; counter &#125;&#125;&lt;/button&gt;', data: function () &#123; return &#123; counter: 0 &#125; &#125;, methods: &#123; increment: function () &#123; this.counter += 1 this.$emit('increment') &#125; &#125;, &#125;) new Vue(&#123; el: '#app', data: &#123; total: 0 &#125;, methods: &#123; incrementTotal: function () &#123; this.total += 1 &#125; &#125; &#125;)&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 如下： 给组件绑定原生事件有时候，你可能想在某个组件的根元素上监听一个原生事件。可以使用 .native 修饰 v-on 。例如：1&lt;my-component v-on:click.native=\"doTheThing\"&gt;&lt;/my-component&gt; 使用自定义事件的表单输入组件自定义事件也可以用来创建自定义的表单输入组件，使用 v-model 来进行数据双向绑定。牢记，表单控件进行数据绑定时的语法：1&lt;input v-model=\"something\"&gt; 仅仅是一个语法糖：1&lt;input v-bind:value=\"something\" v-on:input=\"something = $event.target.value\"&gt; 所以在组件中使用时，它相当于下面的简写：1&lt;input v-bind:value=\"something\" v-on:input=\"something = arguments[0]\"&gt; 所以要让组件的 v-model 生效，它必须： 接受一个 value 属性 在有新的 value 时触发 input 事件 举个栗子：123456789101112131415161718192021222324252627282930&lt;div id=\"app\"&gt; &lt;my-input label=\"Message\" v-model=\"message\" &gt;&lt;/my-input&gt; &lt;/div&gt;&lt;script&gt;Vue.component('my-input', &#123; template: '\\ &lt;div class=\"form-group\"&gt;\\ &lt;label v-bind:for=\"randomId\"&gt;&#123;&#123; label &#125;&#125;:&lt;/label&gt;\\ &lt;input v-bind:id=\"randomId\" v-bind:value=\"value\" v-on:input=\"onInput\"&gt;\\ &lt;/div&gt;\\ ', props: ['value', 'label'], data: function () &#123; return &#123; randomId: 'input-' + Math.random() &#125; &#125;, methods: &#123; onInput: function (event) &#123; this.$emit('input', event.target.value) &#125; &#125;,&#125;)new Vue(&#123; el: '#v-model-example', data: &#123; message: 'hello' &#125;&#125;)&lt;/script&gt; 非父子组件通信有时候非父子关系的组件也需要通信。在简单的场景下，使用一个空的 Vue 实例作为中央事件总线：1var bus = new Vue() 12// 触发组件 A 中的事件 bus.$emit('id-selected', 1) 1234// 在组件 B 创建的钩子中监听事件 bus.$on('id-selected', function (id) &#123;// ... &#125;) 使用 Slots 分发内容在使用组件时，常常要像这样组合它们：1234&lt;app&gt; &lt;app-header&gt;&lt;/app-header&gt; &lt;app-footer&gt;&lt;/app-footer&gt; &lt;/app&gt; 注意两点： &lt;app&gt; 组件不知道它的挂载点会有什么内容。挂载点的内容是由&lt;app&gt;的父组件决定的。 &lt;app&gt; 组件很可能有它自己的模版。 为了让组件可以组合，我们需要一种方式来混合父组件的内容与子组件自己的模板。这个过程被称为 内容分发 (或 “transclusion” 如果你熟悉 Angular)。Vue.js 实现了一个内容分发 API ，参照了当前 Web组件规范草案，使用特殊的 &lt;slot&gt; 元素作为原始内容的插槽。 编译作用域在深入内容分发 API 之前，我们先明确内容的编译作用域。假定模板为：123&lt;child-component&gt; &#123;&#123; message &#125;&#125;&lt;/child-component&gt; message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是： 父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。 一个常见错误是试图在父组件模板内将一个指令绑定到子组件的属性/方法：12&lt;!-- 无效 --&gt; &lt;child-component v-show=\"someChildProperty\"&gt;&lt;/child-component&gt; 假定 someChildProperty 是子组件的属性，上例不会如预期那样工作。父组件模板不应该知道子组件的状态。 如果要绑定子组件内的指令到一个组件的根节点，应当在它的模板内这么做：123456789Vue.component('child-component', &#123; // 有效，因为是在正确的作用域内 template: '&lt;div v-show=\"someChildProperty\"&gt;Child&lt;/div&gt;', data: function () &#123; return &#123; someChildProperty: true &#125;&#125;&#125;) 类似地，分发内容是在父组件作用域内编译。 单个 Slot除非子组件模板包含至少一个 &lt;slot&gt; 插口，否则父组件的内容将会被丢弃。当子组件模板只有一个没有属性的 slot 时，父组件整个内容片段将插入到 slot 所在的 DOM 位置，并替换掉 slot 标签本身。 最初在 &lt;slot&gt; 标签中的任何内容都被视为备用内容。备用内容在子组件的作用域内编译，并且只有在宿主元素为空，且没有要插入的内容时才显示备用内容。 假定 my-component 组件有下面模板：123456&lt;div&gt; &lt;h2&gt;I'm the child title&lt;/h2&gt; &lt;slot&gt; 如果没有分发内容则显示我。 &lt;/slot&gt; &lt;/div&gt; 父组件模版：1234567&lt;div&gt; &lt;h1&gt;I'm the parent title&lt;/h1&gt; &lt;my-component&gt; &lt;p&gt;This is some original content&lt;/p&gt; &lt;p&gt;This is some more original content&lt;/p&gt; &lt;/my-component&gt; &lt;/div&gt; 渲染结果：12345678&lt;div&gt; &lt;h1&gt;I'm the parent title&lt;/h1&gt; &lt;div&gt; &lt;h2&gt;I'm the child title&lt;/h2&gt; &lt;p&gt;This is some original content&lt;/p&gt; &lt;p&gt;This is some more original content&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; 具名Slots&lt;slot&gt; 元素可以用一个特殊的属性 name 来配置如何分发内容。多个 slot 可以有不同的名字。具名 slot 将匹配内容片段中有对应 slot 特性的元素。 仍然可以有一个匿名 slot ，它是默认 slot ，作为找不到匹配的内容片段的备用插槽。如果没有默认的 slot ，这些找不到匹配的内容片段将被抛弃。 例如，假定我们有一个 app-layout 组件，它的模板为：1234567891011&lt;div class=\"container\"&gt; &lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/footer&gt; &lt;/div&gt; 父组件模版：123456&lt;app-layout&gt; &lt;h1 slot=\"header\"&gt;Here might be a page title&lt;/h1&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;p slot=\"footer\"&gt;Here's some contact info&lt;/p&gt; &lt;/app-layout&gt; 渲染结果为：123456789101112&lt;div class=\"container\"&gt; &lt;header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/header&gt; &lt;main&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/main&gt; &lt;footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt; 在组合组件时，内容分发 API 是非常有用的机制。 动态组件多个组件可以使用同一个挂载点，然后动态地在它们之间切换。使用保留的 元素，动态地绑定到它的 is 特性：1234567891011var vm = new Vue(&#123; el: '#example', data: &#123; currentView: 'home' &#125;, components: &#123; home: &#123; /* ... */ &#125;, posts: &#123; /* ... */ &#125;, archive: &#123; /* ... */ &#125; &#125;&#125;) 123&lt;component v-bind:is=\"currentView\"&gt; &lt;!-- 组件在 vm.currentview 变化时改变！ --&gt; &lt;/component&gt; 也可以直接绑定到组件对象上：123456789var Home = &#123; template: '&lt;p&gt;Welcome home!&lt;/p&gt;' &#125;var vm = new Vue(&#123; el: '#example', data: &#123; currentView: Home &#125;&#125;) keep-alive如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个 keep-alive 指令参数：12345&lt;keep-alive&gt; &lt;component :is=\"currentView\"&gt; &lt;!-- 非活动组件将被缓存！ --&gt; &lt;/component&gt; &lt;/keep-alive&gt; 在API 参考查看更多 的细节。 杂项编写可复用组件在编写组件时，记住是否要复用组件有好处。一次性组件跟其它组件紧密耦合没关系，但是可复用组件应当定义一个清晰的公开接口。 Vue 组件的 API 来自三部分 - props, events 和 slots ： Props 允许外部环境传递数据给组件 Events 允许组件触发外部环境的副作用 Slots 允许外部环境将额外的内容组合在组件中。 使用 v-bind 和 v-on 的简写语法，模板的缩进清楚且简洁： 子组件索引尽管有 props 和 events ，但是有时仍然需要在 JavaScript 中直接访问子组件。为此可以使用 ref 为子组件指定一个索引 ID 。例如：123&lt;div id=\"parent\"&gt; &lt;user-profile ref=\"profile\"&gt;&lt;/user-profile&gt; &lt;/div&gt; 123var parent = new Vue(&#123; el: '#parent' &#125;)// 访问子组件 var child = parent.$refs.profile 当 ref 和 v-for 一起使用时， ref 是一个数组或对象，包含相应的子组件。 $refs 只在组件渲染完成后才填充，并且它是非响应式的。它仅仅作为一个直接访问子组件的应急方案——应当避免在模版或计算属性中使用 $refs 。 异步组件在大型应用中，我们可能需要将应用拆分为多个小模块，按需从服务器下载。为了让事情更简单， Vue.js 允许将组件定义为一个工厂函数，动态地解析组件的定义。Vue.js 只在组件需要渲染时触发工厂函数，并且把结果缓存起来，用于后面的再次渲染。例如：1234567Vue.component('async-example', function (resolve, reject) &#123;setTimeout(function () &#123;resolve(&#123;template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;)&#125;, 1000)&#125;) 工厂函数接收一个 resolve 回调，在收到从服务器下载的组件定义时调用。也可以调用 reject(reason) 指示加载失败。这里 setTimeout 只是为了演示。怎么获取组件完全由你决定。推荐配合使用 ：Webpack 的代码分割功能：123456Vue.component('async-webpack-example', function (resolve) &#123;// 这个特殊的 require 语法告诉 webpack // 自动将编译后的代码分割成不同的块， // 这些块将通过 Ajax 请求自动下载。 require(['./my-async-component'], resolve)&#125;) 你可以使用 Webpack 2 + ES2015 的语法返回一个 Promise resolve 函数：1234Vue.component('async-webpack-example',() =&gt; System.import('./my-async-component')) 如果你是 Browserify 用户,可能就无法使用异步组件了,它的作者已经表明 Browserify 是不支持异步加载的。如果这个功能对你很重要，请使用 Webpack。 组件命名约定当注册组件（或者 props）时，可以使用 kebab-case ，camelCase ，或 TitleCase 。Vue 不关心这个。1234567// 在组件定义中 components: &#123;// 使用 camelCase 形式注册 'kebab-cased-component': &#123; /* ... */ &#125;,'camelCasedComponent': &#123; /* ... */ &#125;,'TitleCasedComponent': &#123; /* ... */ &#125;&#125; 在 HTML 模版中，请使用 kebab-case 形式：1234&lt;!-- 在HTML模版中始终使用 kebab-case --&gt; &lt;kebab-cased-component&gt;&lt;/kebab-cased-component&gt; &lt;camel-cased-component&gt;&lt;/camel-cased-component&gt; &lt;title-cased-component&gt;&lt;/title-cased-component&gt; 当使用字符串模式时，可以不受 HTML 的 case-insensitive 限制。这意味实际上在模版中，你可以使用 camelCase 、 PascalCase 或者 kebab-case 来引用你的组件和 prop：1234&lt;!-- 在字符串模版中可以用任何你喜欢的方式! --&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;myComponent&gt;&lt;/myComponent&gt; &lt;MyComponent&gt;&lt;/MyComponent&gt; 如果组件未经 slot 元素传递内容，你甚至可以在组件名后使用 / 使其自闭合：1&lt;my-component/&gt; 当然，这只在字符串模版中有效。因为自闭的自定义元素是无效的 HTML ，浏览器原生的解析器也无法识别它。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(十一组件-中篇)","slug":"vue-js初入门-十一组件-中篇","date":"2018-05-21T12:23:38.000Z","updated":"2018-08-11T15:24:50.259Z","comments":true,"path":"2018/05/21/vue-js初入门-十一组件-中篇/","link":"","permalink":"https://www.hojun.cn/2018/05/21/vue-js初入门-十一组件-中篇/","excerpt":"","text":"在 Vue 中，父子组件的关系可以总结为 props down, events up 。父组件通过 props 向下传递数据给子组件，子组件通过 events 给父组件发送消息。 使用Props传递数据组件实例的作用域是孤立的。这意味着不能并且不应该在子组件的模板内直接引用父组件的数据。可以使用 props 把数据传给子组件。 prop 是父组件用来传递数据的一个自定义属性。子组件需要显式地用 props 选项 声明 “prop”：举个栗子：123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue初入门&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;child message=\"hello!\"&gt;&lt;/child&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', components: &#123; child: &#123; props: ['message'], template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;' &#125; &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; camelCase(驼峰命名法) vs. kebab-case(短横线命名法)因为HTML 特性不区分大小写。当使用非字符串模版时，名字形式为 camelCase(驼峰命名法) 的 prop 用作特性时，需要转为 kebab-case(短横线命名法)（短横线隔开）：1234567891011121314&lt;div id=\"app\"&gt; &lt;child my-message=\"hello!\"&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', components: &#123; child: &#123; props: ['myMessage'], template: '&lt;span&gt;&#123;&#123; myMessage &#125;&#125;&lt;/span&gt;' &#125; &#125; &#125;)&lt;/script&gt; 动态 Props类似于用 v-bind 绑定 HTML 特性到一个表达式，也可以用 v-bind 绑定动态 props 到父组件的数据。每当父组件的数据变化时，也会传导给子组件：12345678910111213141516171819202122&lt;div id=\"app\"&gt; &lt;div&gt; &lt;input v-model=\"parentMsg\"&gt; &lt;br&gt; &lt;child v-bind:my-message=\"parentMsg\"&gt;&lt;/child&gt; &lt;!-- &lt;child :my-message=\"parentMsg\"&gt;&lt;/child&gt;--&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; parentMsg: 'Message from parent' &#125;, components: &#123; child: &#123; props: ['myMessage'], template: '&lt;span&gt;&#123;&#123;myMessage&#125;&#125;&lt;/span&gt;' &#125; &#125; &#125;)&lt;/script&gt; 字面量语法 vs 动态语法初学者常犯的一个错误是使用字面量语法传递数值：12&lt;!-- 传递了一个字符串\"1\" --&gt; &lt;comp some-prop=\"1\"&gt;&lt;/comp&gt; 因为它是一个字面 prop ，它的值以字符串 “1”。如果想传递一个实际的数字，需要使用 v-bind ，从而让它的值被当作 JavaScript 表达式计算：12&lt;!-- 传递实际的数字 --&gt; &lt;comp v-bind:some-prop=\"1\"&gt;&lt;/comp&gt; 单向数据流prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解。 另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告。 通常有两种改变 prop 的情况： prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用； prop 作为需要被转变的原始值传入。 更确切的说这两种情况是： 定义一个局部 data 属性，并将 prop 的初始值作为局部数据的初始值。 定义一个 computed 属性，此属性从 prop 的值计算得出。 注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 prop 是一个对象或数组，在子组件内部改变它会影响父组件的状态。 Prop 验证组件可以为 props 指定验证要求。如果未指定验证要求，Vue 会发出警告。当组件给其他人使用时这很有用。 prop 是一个对象而不是字符串数组时，它包含验证要求：12345678910111213141516171819202122232425262728293031Vue.component('example', &#123; props: &#123; // 基础类型检测 （`null` 意思是任何类型都可以） propA: Number, // 多种类型 propB: [String, Number], // 必传且是字符串 propC: &#123; type: String, required: true &#125;, // 数字，有默认值 propD: &#123; type: Number, default: 100 &#125;, // 数组／对象的默认值应当由一个工厂函数返回 propE: &#123; type: Object, default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; return value &gt; 10 &#125; &#125; &#125;&#125;) type 可以是下面原生构造器： String Number Boolean Function Object Array type 也可以是一个自定义构造器，使用 instanceof 检测。 当 prop 验证失败了， Vue 将拒绝在子组件上设置此值，如果使用的是开发版本会抛出一条警告。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(十一组件-上篇)","slug":"vue-js初入门-十一组件-上篇","date":"2018-05-20T12:45:37.000Z","updated":"2018-08-11T15:24:50.192Z","comments":true,"path":"2018/05/20/vue-js初入门-十一组件-上篇/","link":"","permalink":"https://www.hojun.cn/2018/05/20/vue-js初入门-十一组件-上篇/","excerpt":"","text":"什么是组件？组件（Component）是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素， Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 全局注册使用举个栗子：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue初入门&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; &lt;script&gt; //全局注册 Vue.component('my-component', &#123; template: '&lt;div&gt;A custom component!&lt;/div&gt;' &#125;) new Vue(&#123; el: '#app' &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 局部注册使用举个栗子：123456789101112131415&lt;div id=\"app\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt; var Child = &#123; template: '&lt;div&gt;局部注册&lt;/div&gt;' &#125; var vm = new Vue(&#123; el: '#app', components: &#123; // &lt;my-component&gt; 将只在父模板可用 'my-component': Child &#125; &#125;)&lt;/script&gt; DOM 模版解析说明当使用 DOM 作为模版时（例如，将 el 选项挂载到一个已存在的元素上）, 你会受到 HTML 的一些限制，因为 Vue 只有在浏览器解析和标准化 HTML 后才能获取模版内容。尤其像这些元素 &lt;ul&gt; ， &lt;ol&gt;， &lt;table&gt; ， &lt;select&gt; 限制了能被它包裹的元素， &lt;option&gt; 只能出现在其它元素内部。 在自定义组件中使用这些受限制的元素时会导致一些问题，例如：123&lt;table&gt;&lt;my-row&gt;...&lt;/my-row&gt;&lt;/table&gt; 自定义组件 &lt;my-row&gt; 被认为是无效的内容，因此在渲染的时候会导致错误。变通的方案是使用特殊的 is 属性：123&lt;table&gt; &lt;tr is=\"my-row\"&gt;&lt;/tr&gt; &lt;/table&gt; data 必须是函数如果不是函数，比如：123456789&lt;script&gt; Vue.component('button-counter', &#123; data: &#123; count: 0 &#125;, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;' &#125;) new Vue(&#123; el: '#app' &#125;)&lt;/script&gt; 2.4版vue会直接报错：正确的用法应该使用函数：12345678910111213141516&lt;div id=\"app\"&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt; &lt;button-counter&gt;&lt;/button-counter&gt;&lt;/div&gt;&lt;script&gt; Vue.component('button-counter', &#123; data: function () &#123; return &#123; count: 0 &#125; &#125;, template: '&lt;button v-on:click=\"count++\"&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;' &#125;) new Vue(&#123; el: '#app' &#125;)&lt;/script&gt;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(十表单控件绑定)","slug":"vue-js初入门-十表单控件绑定","date":"2018-05-18T14:31:54.000Z","updated":"2018-08-11T15:24:50.293Z","comments":true,"path":"2018/05/18/vue-js初入门-十表单控件绑定/","link":"","permalink":"https://www.hojun.cn/2018/05/18/vue-js初入门-十表单控件绑定/","excerpt":"","text":"基础用法你可以用 v-model 指令在表单 &lt;input&gt; 及 &lt;textarea&gt; 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但 v-model 本质上不过是语法糖。它负责监听用户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。 v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。 对于需要使用输入法 (如中文、日文、韩文等) 的语言，你会发现 v-model 不会在输入法组合文字过程中得到更新。如果你也想处理这个过程，请使用 input 事件。 文本12&lt;input v-model=\"message\" placeholder=\"edit me\"&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 多行文本1234&lt;span&gt;Multiline message is:&lt;/span&gt;&lt;p style=\"white-space: pre-line;\"&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;&lt;br&gt;&lt;textarea v-model=\"message\" placeholder=\"add multiple lines\"&gt;&lt;/textarea&gt; 在文本区域插值 &lt;textarea&gt;&lt;/textarea&gt; 并不会生效，应用 v-model 来代替。 复选框单个复选框，绑定到布尔值：12&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&lt;label for=\"checkbox\"&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt; 多个复选框，绑定到同一个数组：12345678910111213141516&lt;div id='example-3'&gt; &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt; &lt;label for=\"jack\"&gt;Jack&lt;/label&gt; &lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt; &lt;label for=\"john\"&gt;John&lt;/label&gt; &lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt; &lt;label for=\"mike\"&gt;Mike&lt;/label&gt; &lt;br&gt; &lt;span&gt;Checked names: &#123;&#123; checkedNames &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: '#example-3', data: &#123; checkedNames: [] &#125;&#125;) 单选按钮123456789101112131415&lt;div id=\"example-4\"&gt; &lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt; &lt;label for=\"one\"&gt;One&lt;/label&gt; &lt;br&gt; &lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt; &lt;label for=\"two\"&gt;Two&lt;/label&gt; &lt;br&gt; &lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: '#example-4', data: &#123; picked: '' &#125;&#125;) 选择框123456789101112131415&lt;div id=\"example-5\"&gt; &lt;select v-model=\"selected\"&gt; &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: '...', data: &#123; selected: '' &#125;&#125;) 如果 v-model 表达式的初始值未能匹配任何选项，&lt;select&gt; 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，更推荐像上面这样提供一个值为空的禁用选项。 多选时 (绑定到一个数组)：123456789101112131415&lt;div id=\"example-6\"&gt; &lt;select v-model=\"selected\" multiple style=\"width: 50px;\"&gt; &lt;option&gt;A&lt;/option&gt; &lt;option&gt;B&lt;/option&gt; &lt;option&gt;C&lt;/option&gt; &lt;/select&gt; &lt;br&gt; &lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;&lt;/div&gt;new Vue(&#123; el: '#example-6', data: &#123; selected: [] &#125;&#125;) 用 v-for 渲染的动态选项：1234567891011121314151617&lt;select v-model=\"selected\"&gt; &lt;option v-for=\"option in options\" v-bind:value=\"option.value\"&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;new Vue(&#123; el: '...', data: &#123; selected: 'A', options: [ &#123; text: 'One', value: 'A' &#125;, &#123; text: 'Two', value: 'B' &#125;, &#123; text: 'Three', value: 'C' &#125; ] &#125;&#125;) 值绑定对于单选按钮，复选框及选择框的选项，v-model 绑定的值通常是静态字符串 (对于复选框也可以是布尔值)：12345678910&lt;!-- 当选中时，`picked` 为字符串 \"a\" --&gt;&lt;input type=\"radio\" v-model=\"picked\" value=\"a\"&gt;&lt;!-- `toggle` 为 true 或 false --&gt;&lt;input type=\"checkbox\" v-model=\"toggle\"&gt;&lt;!-- 当选中第一个选项时，`selected` 为字符串 \"abc\" --&gt;&lt;select v-model=\"selected\"&gt; &lt;option value=\"abc\"&gt;ABC&lt;/option&gt;&lt;/select&gt; 但是有时我们可能想把值绑定到 Vue 实例的一个动态属性上，这时可以用 v-bind 实现，并且这个属性的值可以不是字符串。 复选框12345678910&lt;input type=\"checkbox\" v-model=\"toggle\" true-value=\"yes\" false-value=\"no\"&gt;// 当选中时vm.toggle === 'yes'// 当没有选中时vm.toggle === 'no' 这里的 true-value 和 false-value 特性并不会影响输入控件的 value 特性，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如“yes”或“no”)，请换用单选按钮。 单选按钮1234567891011&lt;input type=\"radio\" v-model=\"pick\" v-bind:value=\"a\"&gt;// 当选中时vm.pick === vm.a选择框的选项&lt;select v-model=\"selected\"&gt; &lt;!-- 内联对象字面量 --&gt; &lt;option v-bind:value=\"&#123; number: 123 &#125;\"&gt;123&lt;/option&gt;&lt;/select&gt;// 当选中时typeof vm.selected // =&gt; 'object'vm.selected.number // =&gt; 123 修饰符.lazy在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转变为使用 change 事件进行同步：12&lt;!-- 在“change”时而非“input”时更新 --&gt;&lt;input v-model.lazy=\"msg\" &gt; .number如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符：1&lt;input v-model.number=\"age\" type=\"number\"&gt; 这通常很有用，因为即使在 type=”number” 时，HTML 输入元素的值也总会返回字符串。 .trim如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符：1&lt;input v-model.trim=\"msg\"&gt; 在组件上使用 v-model如果你还不熟悉 Vue 的组件，可以暂且跳过这里。 HTML 原生的输入元素类型并不总能满足需求。幸好，Vue 的组件系统允许你创建具有完全自定义行为且可复用的输入组件。这些输入组件甚至可以和 v-model 一起使用！","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(九事件处理)","slug":"vue-js初入门-九事件处理","date":"2018-05-17T10:32:49.000Z","updated":"2018-08-11T15:24:49.925Z","comments":true,"path":"2018/05/17/vue-js初入门-九事件处理/","link":"","permalink":"https://www.hojun.cn/2018/05/17/vue-js初入门-九事件处理/","excerpt":"","text":"监听事件Vue提供了v-on指令来监听DOM事件举个栗子：12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue初入门&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;button v-on:click=\"counter += 1\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 写在方法中许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 可以接收一个方法来调用。1234567891011121314151617&lt;div id=\"app\"&gt; &lt;button v-on:click=\"add\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; add: function(event) &#123; this.counter += 1 &#125; &#125;&#125;)&lt;/script&gt; 内联处理器方法除了直接绑定到一个方法，也可以用内联 JavaScript 语句：123456789101112131415161718&lt;div id=\"app\"&gt; &lt;button v-on:click=\"add(1)\"&gt;增加 1&lt;/button&gt; &lt;button v-on:click=\"add(2)\"&gt;增加 2&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; add: function(n) &#123; this.counter += n &#125; &#125;&#125;)&lt;/script&gt; 有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法：1234567891011121314151617181920&lt;div id=\"app\"&gt; &lt;button v-on:click=\"add(1,$event)\"&gt;增加 1&lt;/button&gt; &lt;p&gt;这个按钮被点击了 &#123;&#123; counter &#125;&#125; 次。&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; counter: 0 &#125;, methods: &#123; add: function(n, event) &#123; if (event) &#123; alert(event.target.tagName) &#125; this.counter += n &#125; &#125;&#125;)&lt;/script&gt; 事件修饰符在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。 为了解决这个问题， Vue.js 为 v-on 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。 .stop .prevent .capture .self .once 1234567891011121314151617&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=\"doThis\"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=\"doThat\"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;&lt;!-- 即元素自身触发的事件先在此处处理，然后才交由内部元素进行处理 --&gt;&lt;div v-on:click.capture=\"doThis\"&gt;...&lt;/div&gt;&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;&lt;!-- 即事件不是从内部元素触发的 --&gt;&lt;div v-on:click.self=\"doThat\"&gt;...&lt;/div&gt;&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 注意：使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 v-on:click.prevent.self 会阻止所有的点击，而 v-on:click.self.prevent 只会阻止对元素自身的点击。2.1.4 新增 12&lt;!-- 点击事件将只会触发一次 --&gt;&lt;a v-on:click.once=\"doThis\"&gt;&lt;/a&gt; 不像其它只能对原生的 DOM 事件起作用的修饰符，.once 修饰符还能被用到自定义的组件事件上。如果你还没有阅读关于组件的文档，现在大可不必担心。 2.3.0 新增Vue 还对应 addEventListener 中的 passive 选项提供了 .passive 修饰符。1234&lt;!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 --&gt;&lt;!-- 而不会等待 `onScroll` 完成 --&gt;&lt;!-- 这其中包含 `event.preventDefault()` 的情况 --&gt;&lt;div v-on:scroll.passive=\"onScroll\"&gt;...&lt;/div&gt; 这个 .passive 修饰符尤其能够提升移动端的性能。注意：不要把 .passive 和 .prevent 一起使用，因为 .prevent 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，.passive 会告诉浏览器你不想阻止事件的默认行为。 按键修饰符在监听键盘事件时，我们经常需要检查常见的键值。Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：12&lt;!-- 只有在 `keyCode` 是 13 时调用 `vm.submit()` --&gt;&lt;input v-on:keyup.13=\"submit\"&gt; 记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：12345&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=\"submit\"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter=\"submit\"&gt; 全部的按键别名： .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 可以通过全局 config.keyCodes 对象自定义按键修饰符别名：12// 可以使用 `v-on:keyup.f1`Vue.config.keyCodes.f1 = 112 自动匹配按键修饰符2.5.0 新增 你也可直接将 KeyboardEvent.key 暴露的任意有效按键名转换为 kebab-case 来作为修饰符：1&lt;input @keyup.page-down=\"onPageDown\"&gt; 在上面的例子中，处理函数仅在 $event.key === ‘PageDown’ 时被调用。 有一些按键 (.esc 以及所有的方向键) 在 IE9 中有不同的 key 值, 如果你想支持 IE9，它们的内置别名应该是首选。 系统修饰键2.1.0 新增可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 注意：在 Mac 系统键盘上，meta 对应 command 键 (⌘)。在 Windows 系统键盘 meta 对应 Windows 徽标键 (⊞)。在 Sun 操作系统键盘上，meta 对应实心宝石键 (◆)。在其他特定键盘上，尤其在 MIT 和 Lisp 机器的键盘、以及其后继产品，比如 Knight 键盘、space-cadet 键盘，meta 被标记为“META”。在 Symbolics 键盘上，meta 被标记为“META”或者“Meta”。 例如：12345&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=\"clear\"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=\"doSomething\"&gt;Do something&lt;/div&gt; 请注意修饰键与常规按键不同，在和 keyup 事件一起用时，事件触发时修饰键必须处于按下状态。换句话说，只有在按住 ctrl 的情况下释放其它按键，才能触发 keyup.ctrl。而单单释放 ctrl 也不会触发事件。如果你想要这样的行为，请为 ctrl 换用 keyCode：keyup.17。 .exact 修饰符2.5.0 新增 .exact 修饰符允许你控制由精确的系统修饰符组合触发的事件。12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl=\"onClick\"&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact=\"onCtrlClick\"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact=\"onClick\"&gt;A&lt;/button&gt; 鼠标按钮修饰符2.2.0 新增 .left .right .middle 这些修饰符会限制处理函数仅响应特定的鼠标按钮。 为什么在 HTML 中监听事件?你可能注意到这种事件监听的方式违背了关注点分离 (separation of concern) 这个长期以来的优良传统。但不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处： 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(八列表渲染)","slug":"vue-js初入门-八列表渲染","date":"2018-05-15T13:41:58.000Z","updated":"2018-08-11T15:24:50.125Z","comments":true,"path":"2018/05/15/vue-js初入门-八列表渲染/","link":"","permalink":"https://www.hojun.cn/2018/05/15/vue-js初入门-八列表渲染/","excerpt":"","text":"v-forVue给我们提供了v-for 指令来渲染列表。 v-for 指令需要以 item in items 形式的特殊语法。举个栗子：123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue初入门&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=\"app\"&gt; &lt;li v-for=\"item in items\"&gt; &#123;&#123; item.message &#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; items: [ &#123; message: 'item1' &#125;, &#123; message: 'item2' &#125;, &#123; message: 'item3' &#125;, ] &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; v-for 还支持一个可选的第二个参数为当前项的索引。1234567891011121314151617&lt;ul id=\"app\"&gt; &lt;li v-for=\"(item, index) in items\"&gt; &#123;&#123; item.message &#125;&#125; - &#123;&#123;index&#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; items: [ &#123; message: 'item1' &#125;, &#123; message: 'item2' &#125;, &#123; message: 'item3' &#125;, ] &#125;&#125;)&lt;/script&gt; 效果： item1 - 0 item2 - 1 item3 - 2 可以用 of 替代 in 作为分隔符，如：1&lt;div v-for=\"item of items\"&gt;&lt;/div&gt; v-for迭代对象举个栗子：1234567891011121314151617&lt;ul id=\"app\"&gt; &lt;li v-for=\"val in object\"&gt; &#123;&#123; val &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;)&lt;/script&gt; 效果如下： John Doe 30 也可以提供第二个的参数为键名：1234567891011121314151617&lt;ul id=\"app\"&gt; &lt;li v-for=\"(value, key) in object\"&gt; &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;)&lt;/script&gt; 效果如下： firstName: John lastName: Doe age: 30 提供第三个参数为索引：1234567891011121314151617&lt;ul id=\"app\"&gt; &lt;li v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;)&lt;/script&gt; 效果如下： 0.firstName: John 2.lastName: Doe 3.age: 30 key为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有的且唯一的 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用 v-bind 来绑定动态值 (在这里使用简写)：123&lt;div v-for=\"item in items\" :key=\"item.id\"&gt; &lt;!-- 内容 --&gt;&lt;/div&gt; 建议尽可能在使用 v-for 时提供 key，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。 数组更新检测变异方法Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下： push() pop() shift() unshift() splice() sort() reverse() 替换数组变异方法 (mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异 (non-mutating method) 方法，例如：filter(), concat() 和 slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：123example1.items = example1.items.filter(function (item) &#123; return item.message.match(/Foo/)&#125;) 注意事项由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 举个栗子：1234567var vm = new Vue(&#123; data: &#123; items: ['a', 'b', 'c'] &#125;&#125;)vm.items[1] = 'x' // 不是响应性的vm.items.length = 2 // 不是响应性的 为了解决第一类问题，以下两种方式都可以实现和1vm.items[indexOfItem] = newValue 相同的效果，同时也将触发状态更新：1234// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 你也可以使用 vm.$set 实例方法，该方法是全局方法 Vue.set 的一个别名：1vm.$set(vm.items, indexOfItem, newValue) 为了解决第二类问题，你可以使用 splice：1vm.items.splice(newLength) 你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。Vue 为了使得 DOM 元素得到最大范围的重用而实现了一些智能的、启发式的方法，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。 对象更改检测注意事项还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：123456789var vm = new Vue(&#123; data: &#123; a: 1 &#125;&#125;)// `vm.a` 现在是响应式的vm.b = 2// `vm.b` 不是响应式的 对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用1Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如，对于：1234567var vm = new Vue(&#123; data: &#123; userProfile: &#123; name: 'Anika' &#125; &#125;&#125;) 你可以添加一个新的 age 属性到嵌套的 userProfile 对象：1Vue.set(vm.userProfile, 'age', 27) 你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：1vm.$set(vm.userProfile, 'age', 27) 有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：1234Object.assign(vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 你应该这样做: 1234vm.userProfile = Object.assign(&#123;&#125;, vm.userProfile, &#123; age: 27, favoriteColor: 'Vue Green'&#125;) 显示过滤/排序结果有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。 举个栗子：123456789101112131415161718&lt;ul id=\"app\"&gt; &lt;li v-for=\"n in evenNumbers\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; numbers: [ 1, 2, 3, 4, 5 ] &#125;, computed: &#123; evenNumbers: function () &#123; return this.numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125; &#125;&#125;)&lt;/script&gt; 以上代码输出：2,4（偶数） 在计算属性不适用的情况下 (例如，在嵌套 v-for 循环中) 你可以使用一个 method 方法：1234567891011&lt;li v-for=\"n in even(numbers)\"&gt;&#123;&#123; n &#125;&#125;&lt;/li&gt;data: &#123; numbers: [ 1, 2, 3, 4, 5 ]&#125;,methods: &#123; even: function (numbers) &#123; return numbers.filter(function (number) &#123; return number % 2 === 0 &#125;) &#125;&#125; 一段取值范围的 v-forv-for 也可以取整数。在这种情况下，它将重复多次模板。123&lt;div&gt; &lt;span v-for=\"n in 10\"&gt;&#123;&#123; n &#125;&#125; &lt;/span&gt;&lt;/div&gt; 结果：1 2 3 4 5 6 7 8 9 10 v-for on a &lt;template&gt;类似于 v-if，你也可以利用带有 v-for 的 &lt;template&gt; 渲染多个元素。比如：123456&lt;ul&gt; &lt;template v-for=\"item in items\"&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=\"divider\"&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; v-for with v-if当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中。当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用，如下：123&lt;li v-for=\"todo in todos\" v-if=\"!todo.isComplete\"&gt; &#123;&#123; todo &#125;&#125;&lt;/li&gt; 上面的代码只传递了未完成的 todos。 而如果你的目的是有条件地跳过循环的执行，那么可以将 v-if 置于外层元素或 &lt;template&gt;上。如：123456&lt;ul v-if=\"todos.length\"&gt; &lt;li v-for=\"todo in todos\"&gt; &#123;&#123; todo &#125;&#125; &lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No todos left!&lt;/p&gt; 一个组件的 v-for在自定义组件里，你可以像任何普通元素一样用 v-for 。1&lt;my-component v-for=\"item in items\" :key=\"item.id\"&gt;&lt;/my-component&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 然而，任何数据都不会被自动传递到组件里，因为组件有自己独立的作用域。为了把迭代数据传递到组件里，我们要用 props ：123456&lt;my-component v-for=\"(item, index) in items\" v-bind:item=\"item\" v-bind:index=\"index\" v-bind:key=\"item.id\"&gt;&lt;/my-component&gt; 不自动将 item 注入到组件里的原因是，这会使得组件与 v-for 的运作紧密耦合。明确组件数据的来源能够使组件在其他场合重复使用。 下面是一个简单的 todo list 的完整例子：12345678910111213141516&lt;div id=\"todo-list-example\"&gt; &lt;input v-model=\"newTodoText\" v-on:keyup.enter=\"addNewTodo\" placeholder=\"Add a todo\" &gt; &lt;ul&gt; &lt;li is=\"todo-item\" v-for=\"(todo, index) in todos\" v-bind:key=\"todo.id\" v-bind:title=\"todo.title\" v-on:remove=\"todos.splice(index, 1)\" &gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 注意这里的 is=”todo-item” 属性。这种做法在使用 DOM 模板时是十分必要的，因为在 &lt;ul&gt; 元素内只有 &lt;li&gt; 元素会被看作有效内容。这样做实现的效果与 &lt;todo-item&gt;相同，但是可以避开一些潜在的浏览器解析错误。查看 DOM 模板解析说明 来了解更多信息。12345678910111213141516171819202122232425262728293031323334353637383940Vue.component('todo-item', &#123; template: '\\ &lt;li&gt;\\ &#123;&#123; title &#125;&#125;\\ &lt;button v-on:click=\"$emit(\\'remove\\')\"&gt;X&lt;/button&gt;\\ &lt;/li&gt;\\ ', props: ['title']&#125;)new Vue(&#123; el: '#todo-list-example', data: &#123; newTodoText: '', todos: [ &#123; id: 1, title: 'Do the dishes', &#125;, &#123; id: 2, title: 'Take out the trash', &#125;, &#123; id: 3, title: 'Mow the lawn' &#125; ], nextTodoId: 4 &#125;, methods: &#123; addNewTodo: function () &#123; this.todos.push(&#123; id: this.nextTodoId++, title: this.newTodoText &#125;) this.newTodoText = '' &#125; &#125;&#125;)","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"2018-0514每日锻炼","slug":"2018-0514每日锻炼","date":"2018-05-14T15:08:07.000Z","updated":"2018-08-11T15:24:47.948Z","comments":true,"path":"2018/05/14/2018-0514每日锻炼/","link":"","permalink":"https://www.hojun.cn/2018/05/14/2018-0514每日锻炼/","excerpt":"","text":"18/5/16 哑铃侧平举-20 交替哑铃弯举-20 哑铃前平举-20 18/5/15 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/5/14 俯卧撑-240 平板支撑-3m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"锻炼","slug":"锻炼","permalink":"https://www.hojun.cn/tags/锻炼/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"vue.js初入门(七条件渲染)","slug":"vue-js初入门-七条件渲染","date":"2018-05-14T14:22:17.000Z","updated":"2018-08-11T15:24:49.860Z","comments":true,"path":"2018/05/14/vue-js初入门-七条件渲染/","link":"","permalink":"https://www.hojun.cn/2018/05/14/vue-js初入门-七条件渲染/","excerpt":"","text":"v-if举个栗子：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue初入门&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;p v-if=\"ok\"&gt;现在你看到我了&lt;/p&gt; &lt;p v-if=\"hide\"&gt;你看不到我&lt;/p&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; ok: true, hide: false &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 细心的人可能会发现，v-if需要依赖元素，比如上一个栗子，我们不想要p标签，又使用使用v-if指令呢？可以使用&lt;template&gt;元素。如：1&lt;template v-if=\"ok\"&gt;现在你看到我了&lt;/template&gt; 最终的渲染结果将不包含&lt;template&gt;元素。 v-else你可以使用 v-else 指令来表示 v-if 的“else 块”。举个栗子：123456789101112&lt;div id=\"app\"&gt; &lt;p v-if=\"hide\"&gt;hide等于true&lt;/p&gt; &lt;p v-else=\"hide\"&gt;hide等于false&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; hide: false &#125;&#125;)&lt;/script&gt; 注意：v-else 元素必须紧跟在带 v-if 或者 v-else-if 的元素的后面，否则它将不会被识别。 v-else-if2.1.0 新增，举个栗子：123456789101112&lt;div v-if=\"type === 'A'\"&gt; A&lt;/div&gt;&lt;div v-else-if=\"type === 'B'\"&gt; B&lt;/div&gt;&lt;div v-else-if=\"type === 'C'\"&gt; C&lt;/div&gt;&lt;div v-else&gt; Not A/B/C&lt;/div&gt; 类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。 用 key 管理可复用的元素Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\"&gt;&lt;/template&gt; 那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，&lt;input&gt; 不会被替换掉——仅仅是替换了它的 placeholder。效果如下： 这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可：举个栗子：12345678&lt;template v-if=\"loginType === 'username'\"&gt; &lt;label&gt;Username&lt;/label&gt; &lt;input placeholder=\"Enter your username\" key=\"username-input\"&gt;&lt;/template&gt;&lt;template v-else&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input placeholder=\"Enter your email address\" key=\"email-input\"&gt;&lt;/template&gt; 效果如下： 注意，&lt;label&gt; 元素仍然会被高效地复用，因为它们没有添加 key 属性。 v-show另一个用于根据条件展示元素的选项是 v-show 指令。用法大致一样：1&lt;h1 v-show=\"ok\"&gt;Hello!&lt;/h1&gt; 不同的是带有 v-show 的元素始终会被渲染并保留在 DOM 中。v-show 只是简单地切换元素的 CSS 属性 display。 注意，v-show 不支持 &lt;template&gt; 元素，也不支持 v-else。 v-if vs v-showv-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"2018母亲节","slug":"2018母亲节","date":"2018-05-13T13:39:20.000Z","updated":"2018-08-11T15:24:47.981Z","comments":true,"path":"2018/05/13/2018母亲节/","link":"","permalink":"https://www.hojun.cn/2018/05/13/2018母亲节/","excerpt":"","text":"","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"vue.js初入门(六Class和Style绑定)","slug":"vue-js初入门-六Class和Style绑定","date":"2018-05-12T11:24:32.000Z","updated":"2018-08-11T15:24:50.160Z","comments":true,"path":"2018/05/12/vue-js初入门-六Class和Style绑定/","link":"","permalink":"https://www.hojun.cn/2018/05/12/vue-js初入门-六Class和Style绑定/","excerpt":"","text":"class 与 style 是 HTML 元素的属性，用于设置元素的样式，我们可以用 v-bind 来设置样式属性。v-bind 在处理 class 和 style 时， 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。 Class对象我们可以为 v-bind:class 设置一个对象，从而动态的切换 class:12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue初入门&lt;/title&gt; &lt;style&gt; .active &#123; width: 100px; height: 100px; background: #F00; &#125; &lt;/style&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &lt;div v-bind:class=\"&#123; active: isActive &#125;\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; new Vue(&#123; el: '#app', data: &#123; isActive: true &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 字符串123456789101112131415161718192021222324252627&lt;style&gt;.active &#123; width: 100px; height: 100px; background: green;&#125;.text-danger &#123; background: red;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt; &lt;div class=\"static\" v-bind:class=\"&#123; active: isActive, 'text-danger': hasError &#125;\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; isActive: true, hasError: true &#125;&#125;)&lt;/script&gt; 我们也可以直接绑定数据里的一个对象：123456789101112131415&lt;div id=\"app\"&gt; &lt;div v-bind:class=\"classObject\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; classObject: &#123; active: true, 'text-danger': true &#125; &#125;&#125;)&lt;/script&gt; 计算属性我们也可以在这里绑定返回对象的计算属性。这是一个常用且强大的模式：123456789101112131415new Vue(&#123; el: '#app', data: &#123; isActive: true, error: null &#125;, computed: &#123; classObject: function () &#123; return &#123; active: this.isActive &amp;&amp; !this.error, 'text-danger': this.error &amp;&amp; this.error.type === 'fatal', &#125; &#125; &#125;&#125;) 我们可以把一个数组传给 v-bind:class12345678910111213&lt;div id=\"app\"&gt; &lt;div v-bind:class=\"[activeClass, errorClass]\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; activeClass: 'active', errorClass: 'text-danger' &#125;&#125;)&lt;/script&gt; 我们还可以使用三元表达式来切换列表中的 class ：1&lt;div v-bind:class=\"[isActive ? activeClass : '', errorClass]\"&gt;&lt;/div&gt; style(内联样式)v-bind:style 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用单引号括起来) 来命名：我们可以在 v-bind:style 直接设置样式：12345678910111213&lt;div id=\"app\"&gt; &lt;div v-bind:style=\"&#123; color: activeColor, fontSize: fontSize &#125;\"&gt;Vue&lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; activeColor: 'green', fontSize: '30px' &#125;&#125;)&lt;/script&gt; 建议直接绑定到一个样式对象：12345678&lt;div v-bind:style=\"styleObject\"&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: 'red', fontSize: '13px' &#125;&#125; v-bind:style 的数组语法可以将多个样式对象应用到同一个元素上：1&lt;div v-bind:style=\"[baseStyles, overridingStyles]\"&gt;&lt;/div&gt; 自动添加前缀当 v-bind:style 使用需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"软考备考之广义表理解","slug":"软考备考之广义表理解","date":"2018-05-11T13:03:38.000Z","updated":"2018-08-11T15:24:47.704Z","comments":true,"path":"2018/05/11/软考备考之广义表理解/","link":"","permalink":"https://www.hojun.cn/2018/05/11/软考备考之广义表理解/","excerpt":"","text":"什么是广义表？百度百科解释如下：广义表(Lists，又称列表)是一种非线性的数据结构，是线性表的一种推广。即广义表中放松对表元素的原子限制，容许它们具有其自身结构。它被广泛的应用于人工智能等领域的表处理语言LISP语言中。在LISP语言中，广义表是一种最基本的数据结构，就连LISP 语言的程序也表示为一系列的广义表。（又见LISP，自从看了《黑客与画家》总感觉这LISP出现频率高了不少……） 广义表定义广义表是n(n≥0)个元素a1，a2，…，ai，…，an的有限序列。其中： ①ai–或者是原子或者是一个广义表。 ②广义表通常记作：Ls=( a1，a2，…，ai，…，an)。 ③Ls是广义表的名字，n为它的长度。 ④若ai是广义表，则称它为Ls的子表。 注意： ①广义表通常用圆括号括起来，用逗号分隔其中的元素。 ②为了区分原子和广义表，书写时用大写字母表示广义表，用小写字母表示原子。 ③若广义表Ls非空(n≥1)，则al是LS的表头，其余元素组成的表(a1，a2，…，an)称为Ls的表尾。 ④广义表是递归定义的 [1] 广义表表示（1）广义表常用表示 ① E=() : E是一个空表，其长度为0。 ② L=(a，b) : L是长度为2的广义表，它的两个元素都是原子，因此它是一个线性表 ③ A=(x，L)=(x，(a，b)) : A是长度为2的广义表，第一个元素是原子x，第二个元素是子表L。 ④ B=(A，y)=((x，(a，b))，y) : B是长度为2的广义表，第一个元素是子表A，第二个元素是原子y。 ⑤ C=(A，B)=((x，(a，b))，((x，(a，b))，y)) : C的长度为2，两个元素都是子表。 ⑥ D=(a，D)=(a，(a，(a，(…)))) : D的长度为2，第一个元素是原子，第二个元素是D自身，展开后它是一个无限的广义表。 （2）广义表的深度一个表的”深度”是指表展开后所含括号的层数。【例】表L、A、B、C的深度为分别为1、2、3、4，表D的深度为∞。 （3）带名字的广义表表示如果规定任何表都是有名字的，为了既表明每个表的名字，又说明它的组成，则可以在每个表的前面冠以该表的名字，于是上例中的各表又可以写成： ①E() ②L(a，b) ③A(x，L(a，b)) ④B(A(x，L(a，b))，y) ⑤C(A(x，l(a，b))，B(A(x，L(a，b))，y)) ⑥D(a，D(a，D(…))) 广义表运算由于广义表是对线性表和树的推广，并且具有共享和递归特性的广义表可以和有向图(见第7章)建立对应，因此广义表的大部分运算与这些数据结构上的运算类似。在此，只讨论广义表的两个特殊的基本运算：取表头head(Ls)和取表尾tail(Ls)。根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其表尾必定是子表。【例】head(L)=a，tail(L)=(b)head(B)=A，tail(B)=(y)由于tail(L)是非空表，可继续分解得到：head(tail(L))=b， tail(tail(L))=()对非空表A和(y)，也可继续分解。注意:广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()。 看了下说明还是不能够很理解，让我们来做道例题来加强理解：2009年软考真题：若广义表L=((x,y,z),a,(u,t,w)),则从L中取出原子项y的运算是___? A.head(tail(tail(L))) B.tail(head(head(L))) C.head(tail(head(L))) D.tail(tail(head(L))) 正确答案：Chead(L) = (x,y,z) ; tail(L) = (a,(u,t,w))head(head(L)) = xtail(head(L)) = (y,z) //这一步理解了就行 tail得到的却是head外组成的新的广义表head(tail(head(L))) = y 要注意的是head得到的是一个原子,而tail得到的却是原子外组成的新的广义表,不管是只有一个元素,但也是一个广义表,而不是直接的元素。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://www.hojun.cn/tags/软考/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(五计算属性)","slug":"vue-js初入门-五计算属性","date":"2018-05-10T16:10:29.000Z","updated":"2018-08-11T15:24:50.079Z","comments":true,"path":"2018/05/11/vue-js初入门-五计算属性/","link":"","permalink":"https://www.hojun.cn/2018/05/11/vue-js初入门-五计算属性/","excerpt":"","text":"Vue中的计算属性举个栗子：12345678910111213141516171819&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"&#123;&#123; message &#125;&#125;\"&lt;/p&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#example', data: &#123; message: 'Hello' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt; 结果：Original message: “Hello”Computed reversed message: “olleH” 这里我们声明了一个计算属性 reversedMessage。我们提供的函数将用作属性 vm.reversedMessage 的 getter 函数： console.log(vm.reversedMessage) // =&gt; ‘olleH’vm.message = ‘Goodbye’console.log(vm.reversedMessage) // =&gt; ‘eybdooG’你可以打开浏览器的控制台，自行修改例子中的 vm。vm.reversedMessage 的值始终取决于 vm.message 的值。 你可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 vm.reversedMessage 依赖于 vm.message，因此当 vm.message 发生改变时，所有依赖 vm.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。 计算属性缓存 vs 方法值得注意的是我们可以通过在表达式中调用方法来达到同样的效果：1234567&lt;p&gt;Reversed message: \"&#123;&#123; reversedMessage() &#125;&#125;\"&lt;/p&gt;// 在组件中methods: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125; 我们可以将同一函数定义为一个方法而不是一个计算属性。两种方式的最终结果确实是完全相同的。然而，不同的是计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要 message 还没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。 这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖(data中的数据是响应式依赖)：12345computed: &#123; now: function () &#123; return Date.now() &#125;&#125; 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 我们为什么需要缓存？假设我们有一个性能开销比较大的的计算属性 A，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有其他的计算属性依赖于 A 。如果没有缓存，我们将不可避免的多次执行 A 的 getter！如果你不希望有缓存，请用方法来替代。 计算属性 vs 侦听属性Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。123456789101112131415161718&lt;div id=\"demo\"&gt;&#123;&#123; fullName &#125;&#125;&lt;/div&gt;var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' &#125;, watch: &#123; //这里是用watch侦听 firstName: function (val) &#123; this.fullName = val + ' ' + this.lastName &#125;, lastName: function (val) &#123; this.fullName = this.firstName + ' ' + val &#125; &#125;&#125;) 上面代码是命令式且重复的。将它与计算属性的版本进行比较：12345678910111213var vm = new Vue(&#123; el: '#demo', data: &#123; firstName: 'Foo', lastName: 'Bar' &#125;, computed: &#123; fullName: function () &#123; //因为firstName和lastName都是响应式的 return this.firstName + ' ' + this.lastName &#125; &#125;&#125;) 好得多了，不是吗？ 计算属性的 setter计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：1234567891011121314151617// ...computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.firstName = names[0] this.lastName = names[names.length - 1] &#125; &#125;&#125;// ...现在再运行 vm.fullName = 'John Doe' 时，setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。 侦听器虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。 例如：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=\"watch-example\"&gt; &lt;p&gt; Ask a yes/no question: &lt;input v-model=\"question\"&gt; &lt;/p&gt; &lt;p&gt;&#123;&#123; answer &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js\"&gt;&lt;/script&gt;&lt;script&gt;var watchExampleVM = new Vue(&#123; el: '#watch-example', data: &#123; question: '', answer: 'I cannot give you an answer until you ask a question!' &#125;, watch: &#123; // 如果 `question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) &#123; this.answer = 'Waiting for you to stop typing...' this.getAnswer() &#125; &#125;, methods: &#123; // `_.debounce` 是一个通过 Lodash 限制操作频率的函数。 // 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率 // AJAX 请求直到用户输入完毕才会发出。想要了解更多关于 // `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识， // 请参考：https://lodash.com/docs#debounce getAnswer: _.debounce( function () &#123; if (this.question.indexOf('?') === -1) &#123; this.answer = 'Questions usually contain a question mark. ;-)' return &#125; this.answer = 'Thinking...' var vm = this axios.get('https://yesno.wtf/api') .then(function (response) &#123; vm.answer = _.capitalize(response.data.answer) &#125;) .catch(function (error) &#123; vm.answer = 'Error! Could not reach the API. ' + error &#125;) &#125;, // 这是我们为判定用户停止输入等待的毫秒数 500 ) &#125;&#125;)&lt;/script&gt; 在这个示例中，使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"软考备考之数据库数据模型","slug":"软考备考之数据库数据模型","date":"2018-05-08T16:15:15.000Z","updated":"2018-08-11T15:24:47.737Z","comments":true,"path":"2018/05/09/软考备考之数据库数据模型/","link":"","permalink":"https://www.hojun.cn/2018/05/09/软考备考之数据库数据模型/","excerpt":"","text":"数据库应用系统中三种不同的数据模型： 概念模型（E-R模型）：为了实现用户的需求定义的模型，主要是初步表达用户需求 逻辑模型：按照用户观点对数据进行建模，主要用于数据库设计。逻辑模型具体包括：层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化模型等。 物理模型：表示数据在系统内部的表示方法和存取方法，实现数据的物理存储。包括数据的存储位置，索引存放位置，存储文件位置和存储策略等存储细节问题。 数据模型的组成要素：数据结构、数据操作、数据完整性约束条件数据结构数据结构指数据对象和对象之间联系的表达，是系统静态特征的描述，包括两个方面： （1）数据本身：类型、内容、性质。例如关系模型中的域、属性、关系等。 （2）数据之间的联系：数据之间是如何相互联系的，例如关系模型中的主码、外码等联系。 数据操作对数据库中对象（型）的实例（值）允许执行的操作集合，主要指检索和更新（插入、删除、修改）两类操作。数据模型必须定义这些操作的确切含义、操作符号、操作规则（如优先级）以及实现操作的语言。数据操作是对系统动态特征的描述。 完整性约束条件数据完整性约束是一组完整性规则的集合，规定数据库状态及状态变化所应满足的条件，以保证数据的正确性、有效性和相容性。 数据库中主要的逻辑数据模型层次模型（格式化模型）定义和限制条件：有且仅有一个节点，无父节点，此节点为树的根；其他节点有且仅有一个父节点；优点：数据结构简单清晰；利用指针记录边向联系，查询效率高；良好的完整新支持；缺点：只能表示1：N的联系。尽管有许多辅助手段实现M：N的联系，但比较复杂，不易掌握。层次模型的树是有序树（层次顺序）。对任一结点的所有子树都规定了先后次序，这一限制隐含了对数据库存取路径的控制。树中父子结点之间只存在一种联系，因此，对树中的任一结点，只有一条自根结点到达它的路径。 网状模型（格式化模型）网状模型的数据结构主要有以下两个特征：允许一个以上的节点无双亲；一个节点可以有多于一个的双亲；优点：可以更加清晰表达现实，符合现实中的数据关系；可以很快存取操作；缺点：结构复杂；不易掌握，网状模型的DDL，DDM复杂，并且并且要嵌入某一种高级语言（COBOL，c），用户不易掌握；应用程序复杂，记录之间的联系通过存取路径实现的，应用程序在访问数据时必须选择合适的存取路径，因此用户必须了解系统结构的细节，加重编写应用程序的负担； 关系模型单一的数据结构——关系现实世界的实体以及实体间的各种联系均用关系来表示，从用户角度看，关系模型中数据的逻辑结构是一张二维表。优点：数据结构单一，关系模型中，不管是实体还是实体之间的联系，都用关系来表示，而关系都对应一张二维数据表，数据结构简单、清晰。关系规范化，并建立在严格的理论基础上，构成关系的基本规范要求关系中每个属性不可再分割，同时关系建立在具有坚实的理论基础的严格数学概念基础上。概念简单，操作方便，关系模型最大的优点就是简单，用户容易理解和掌握，一个关系就是一张二维表格，用户只需用简单的查询语言就能对数据库进行操作。缺点：查询效率不如格式化数据模型；为了提高性能，数据库管理系统需要优化用户查询，增加了数据库管理系统的开发难度； 面向对象数据模型面向对象数据模型把实体表示为类，一个类描述了对象属性和实体行为。面向对象数据模型四种核心技术：分类是把一组具有相同属性结构和操作方法的对象归纳或映射为一个公共类的过程。如城镇建筑可分为行政区、商业区、住宅区、文化区等若干个类。概括（继承）将相同特征和操作的类再抽象为一个更高层次、更具一般性的超类的过程。子类是超类的一个特例。一个类可能是超类的子类，也可是几个子类的超类。所以，概括可能有任意多层次。概括技术避免了说明和存储上的大量冗余。这需要一种能自动地从超类的属性和操作中获取子类对象的属性和操作的机制，即继承机制。聚集（聚合）聚集是把几个不同性质类的对象组合成一个更高级的复合对象的过程。联合（组合）相似对象抽象组合为集合对象。其操作是成员对象的操作集合。优点：适合处理各种各样的数据类型：与传统的数据库（如层次、网状或关系）不同，面向对象数据库适合存储不同类型的数据，例如，图片、声音、视频，包括文本、数字等。面向对象程序设计与数据库技术相结合：面向对象数据模型结合了面向对象程序设计与数据库技术，因而提供了一个集成应用开发系统。提高开发效率：面向对象数据模型提供强大的特性，例如继承、多态和动态绑定，这样允许用户不用编写特定对象的代码就可以构成对象并提供解决方案。这些特性能有效地提高数据库应用程序开发人员的开发效率。改善数据访问：面向对象数据模型明确地表示联系，支持导航式和关联式两种方式的信息访问。它比基于关系值的联系更能提高数据访问性能。缺点：没有准确的定义：不同产品和原型的对象是不一样的，所以不能对对象做出准确定义；维护困难：随着组织信息需求的改变，对象的定义也要求改变并且需移植现有数据库，以完成新对象的定义。当改变对象的定义和移植数据库时，它可能面临真正的挑战。不适合所有的应用：面向对象数据模型用于需要管理数据对象之间存在的复杂关系的应用，它们特别适合于特定的应用，例如工程、电子商务、医疗等，但并不适合所有应用。当用于普通应用时，其性能会降低并要求很高的处理能力。 对象关系数据模型那叫对象关系数据库映射。Hibernate的原理.核心部分.对象关系映射（ORM）提供了概念性的、易于理解的模型化数据的方法。ORM方法论基于三个核心原则：简单：以最基本的形式建模数据。传达性：数据库结构被任何人都能理解的语言文档化。精确性：基于数据模型创建正确标准化了的结构。 典型地，建模者通过收集来自那些熟悉应用程序但不熟练的数据建模者的人的信息开发信息模型。建模者必须能够用非技术企业专家可以理解的术语在概念层次上与数据结构进行通讯。建模者也必须能以简单的单元分析信息，对样本数据进行处理。ORM专门被设计为改进这种联系。对象-关系数据库映射规则表达式，ORM把应用程序世界表示为具有角色（关系中的部分）的一组对象（实体或值）。优点：ORM还提供了灵活性。使用ORM创建的模型比使用其它方法创建的模型更有能力适应系统的变化。ORM允许非技术企业专家按样本数据谈论模型，因此他们可以使用真实世界的数据验证模型。因为ORM允许重用对象，数据模型能自动映射到正确标准化的数据库结构。ORM模型的简单性简化了数据库查询过程。使用ORM查询工具，用户可以访问期望数据，而不必理解数据库的底层结构。 半结构化模型数据有些是完全无结构的数据，比如声音文件、图像文件等； 有些则具有严谨的结构，比如关系型数据库中的数据；还有一类是结构状态介于以上两种数据之间的数据，这种数据具 有一定的结构，但结构不规则、不完整，或者结构是隐含的， 比如HTML文档，我们把这类数据称为半结构化数据。 有关半结构化数据还没有一个统一的定义。 半结构化模型分为基于树的模型、基于图的模型、基于逻辑的模型、基于关系的模型、基于对象的模型； 半结构化模型的特征 半结构化数据模型是一种数据库模型，但与传统的关系模型或面向对象数据模型有所不同，在这个模型中，模式包含于数据中，而不像关系模型那样，模式与数据严格区分，并且在这种模型巾，模式来源于数据，是先有数据，后有模式，这与传统数据库模型正好相反。半结构化数据模型的结构并非一成不变，其复杂程度取决于实际的应用，可以根据需要进行定制，其模式是非精确的，不对数据结构进行强制约束，只描述数据的结构信息，可能只描述数据的一部分结构，也可能根据数据处理不同阶段的视角不同而不同。由于半结构化数据模型结构的动态可变性，基于它可以在不同结构的数据库问的数据交互提供灵活的数据格式。半结构化数据模型可以帮助用户出于浏览的目的把半结构数据当做结构数据来看不同结构的数据库问数据的传输格式可相互移植由于半结构化数据模型结构的可变性，加大了数据处理的难度","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://www.hojun.cn/tags/软考/"},{"name":"数据库","slug":"数据库","permalink":"https://www.hojun.cn/tags/数据库/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"软考备考之UML类图几种关系总结","slug":"软考备考之UML类图几种关系总结","date":"2018-05-07T13:13:02.000Z","updated":"2018-08-11T15:24:47.627Z","comments":true,"path":"2018/05/07/软考备考之UML类图几种关系总结/","link":"","permalink":"https://www.hojun.cn/2018/05/07/软考备考之UML类图几种关系总结/","excerpt":"","text":"在UML类图中，常见的有以下几种关系: 泛化（Generalization）, 实现（Realization），关联（Association)，聚合（Aggregation），组合(Composition)，依赖(Dependency) 1. 泛化（Generalization）【泛化关系】：是一种继承关系，表示一般与特殊的关系，它指定了子类如何特化父类的所有特征和行为。例如：老虎是动物的一种，即有老虎的特性也有动物的共性。 【箭头指向】：带三角箭头的实线，箭头指向父类 2. 实现（Realization）【实现关系】：是一种类与接口的关系，表示类是接口所有特征和行为的实现. 【箭头指向】：带三角箭头的虚线，箭头指向接口 3. 关联（Association)【关联关系】：是一种拥有的关系，它使一个类知道另一个类的属性和方法；如：老师与学生，丈夫与妻子关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。 【代码体现】：成员变量 【箭头及指向】：带普通箭头的实心线，指向被拥有者 上图中，老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 下图为自身关联： 4. 聚合（Aggregation）【聚合关系】：是整体与部分的关系，且部分可以离开整体而单独存在。如车和轮胎是整体和部分的关系，轮胎离开车仍然可以存在。 聚合关系是关联关系的一种，是强的关联关系；关联和聚合在语法上无法区分，必须考察具体的逻辑关系。 【代码体现】：成员变量 【箭头及指向】：带空心菱形的实心线，菱形指向整体 5. 组合(Composition)【组合关系】：是整体与部分的关系，但部分不能离开整体而单独存在。如公司和部门是整体和部分的关系，没有公司就不存在部门。 组合关系是关联关系的一种，是比聚合关系还要强的关系，它要求普通的聚合关系中代表整体的对象负责代表部分的对象的生命周期。 【代码体现】：成员变量 【箭头及指向】：带实心菱形的实线，菱形指向整体 6. 依赖(Dependency)【依赖关系】：是一种使用的关系，即一个类的实现需要另一个类的协助，所以要尽量不使用双向的互相依赖. 【代码表现】：局部变量、方法的参数或者对静态方法的调用 【箭头及指向】：带箭头的虚线，指向被使用者 各种关系的强弱顺序： 泛化 = 实现 &gt; 组合 &gt; 聚合 &gt; 关联 &gt; 依赖 下面这张UML图，比较形象地展示了各种类图关系：","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://www.hojun.cn/tags/软考/"},{"name":"UML","slug":"UML","permalink":"https://www.hojun.cn/tags/UML/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"软考备考之UML十种建模图","slug":"软考备考之UML十种建模图","date":"2018-05-07T13:10:37.000Z","updated":"2018-08-11T15:24:47.596Z","comments":true,"path":"2018/05/07/软考备考之UML十种建模图/","link":"","permalink":"https://www.hojun.cn/2018/05/07/软考备考之UML十种建模图/","excerpt":"","text":"UML九种建模图：用例图、类图、对象图、顺序图、协作图、状态图、活动图、组件图、配置图。又可以静动分为静态视图和动态视图。静态图分为：用例图，类图，对象图，包图，构件图，部署图。动态图分为：状态图，活动图，协作图，序列图。 用例图用例图(Use case diagrams)描述了作为一个外部的观察者的视角对系统的印象。强调这个系统是什么而不是这个系统怎么工作。 (这不是黄瓜)举个栗子：角色是人状的图标，用例是一个椭圆，通讯是连接角色和用例的线。 又一个栗子： 类图类图(Class diagram)通过显示出系统的类以及这些类之间的关系来表示系统。类图是静态的－它们显示出什么可以产生影响，但不会告诉你什么时候产生影响。 (这不是黄瓜)举个栗子：下面是一个顾客从零售商处预定商品的模型的类图。中心的类是Order。连接它的是购买货物的Customer和Payment。Payment有 三种形式：Cash，Check，或者Credit。订单包括OrderDetails（line item），每个这种类都连着Item。UML类的符号是一个被划分成三块的方框：类名，属性，和操作。抽象类的名字，像Payment是斜体的。类之间的关系是连接线。 类图的几种关系详见之前那篇文章《UML类图几种关系总结》 包图包图由包和包之间的关系构成，它是维护和控制系统总体结构的重要建模工具。设计良好的包是高内聚、低耦合的，并且对其内容的访问具有严密的控制。包的图标是一个大矩形（内容框），左上角带一个小矩形（名字框）。包与包之间的联系主要有两种：依赖（尤其是输入依赖）和泛化。 (这不是黄瓜)举个栗子： 对象图对象图表示在某一时刻一组对象以及他们之间的关系的图。对象图可以被看作是类图在系统某一时刻的实例。对象图由节点以及连接这些节点的连线组成。对象图是对象也可以是类，连线表示对象间的关系。 (这不是黄瓜)举个栗子： 顺序图顺序图（又称时序图、序列图）（Sequence Diagram）是显示对象之间交互的图，这些对象是按时间顺序排列的。顺序图中显示的是参与交互的对象及其对象之间消息交互的顺序。时序图中包括的建模元素主要有：对象（Actor）、生命线（Lifeline）、控制焦点（Focus of control）、消息（Message）等等。 (这不是黄瓜)举个栗子： 协作图协作图(Collaboration Diagram /Communication Diagram，也叫合作图)是一种交互图（interaction diagram），强调的是发送和接收消息的对象之间的组织结构。不关心什么时候消息被传递，只关心对象的角色。一个协作图显示了一系列的对象和在这些对象之间的联系以及对象间发送和接收的消息。对象通常是命名或匿名的类的实例，也可以代表其他事物的实例，例如协作、组件和节点。使用协作图来说明系统的动态情况。 (这不是黄瓜)举个栗子： 状态图对象拥有行为和状态。对象的状态是由对象当前的行动和条件决定的。状态图(statechart diagram)显示出了对象可能的状态以及由状态改变而导致的转移。 (这不是黄瓜)举个栗子：银行的在线登录系统 状态是用圆角矩形来表示的。转移则是使用带箭头的连线表示。触发转移的事件或者条件写在箭头的旁边。我们的图上有两个自转移。一个是在Getting SSN，另一个则在上Getting PIN。 初始状态（黑色圆圈）是开始动作的虚拟开始。结束状态也是动作的虚拟结束。 活动图活动图(activity diagram)是一个很特别的流程图。活动图和状态图之间是有关系的。状态图把焦点集中在过程中的对象身上，而活动图则集中在一个单独过程动作流程。活动图告诉了我们活动之间的依赖关系。 (这不是黄瓜)举个栗子：用户登录 组件图组件图，又称构件图（Component diagram）是面向对象系统从物理方面建模时用到的图之一，显示一组构件之间的组织和依赖关系。使用组件图的思想是复用。 (这不是黄瓜)举个栗子： 部署图部署图又称配置图（Deployment Diagrams）描述了系统运行时进行处理的结点以及在结点上活动的构件的配置。强调了物理设备以及之间的连接关系。 (这不是黄瓜)举个栗子：","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://www.hojun.cn/tags/软考/"},{"name":"UML","slug":"UML","permalink":"https://www.hojun.cn/tags/UML/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(四模板语法)","slug":"vue-js初入门-四模板语法","date":"2018-05-06T14:07:47.000Z","updated":"2018-08-11T15:24:50.326Z","comments":true,"path":"2018/05/06/vue-js初入门-四模板语法/","link":"","permalink":"https://www.hojun.cn/2018/05/06/vue-js初入门-四模板语法/","excerpt":"","text":"文本数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值：1234567891011&lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; msg: '文本文本文本' &#125; &#125;)&lt;/script&gt; 无论何时，绑定的数据对象上 msg 属性发生了改变，插值处的内容都会更新。通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。1234567891011121314&lt;div id=\"app\"&gt; &lt;div&gt;&#123;&#123; html &#125;&#125;&lt;/div&gt; &lt;div v-once&gt;&#123;&#123; html &#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; html: '初始值' &#125; &#125;) //更新值 vm._data.html = '更新值'&lt;/script&gt; 效果： 输出html双大括号会将数据解释为纯文本，而非 HTML 。为了输出真正的 HTML ，你需要使用 v-html 指令：123456789101112&lt;div id=\"app\"&gt; &lt;div v-html=\"html\"&gt;&lt;/div&gt; &lt;div&gt;&#123;&#123; html &#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; html: '&lt;h1&gt;这是h1&lt;/h1&gt;' &#125; &#125;)&lt;/script&gt; 效果： 属性双大括号不能在 HTML 属性中使用，该使用 v-bind 指令：123456789101112&lt;div id=\"app\"&gt; &lt;div id=\"&#123;&#123; dynamicId &#125;&#125;\"&gt;&lt;/div&gt; &lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#app', data: &#123; dynamicId: 'divId' &#125; &#125;)&lt;/script&gt; 效果：这对布尔值的属性也有效 —— 如果条件被求值为 false 的话该属性会被移除 使用 JavaScript 表达式12345678910111213141516&lt;div id=\"app\"&gt; &#123;&#123;512*2&#125;&#125;&lt;br&gt; &#123;&#123; ok ? 'YES' : 'NO' &#125;&#125;&lt;br&gt; &#123;&#123; message.split('').reverse().join('') &#125;&#125; &lt;div v-bind:id=\"'list-' + id\"&gt;JavaScript 表达式&lt;/div&gt;&lt;/div&gt;&lt;script&gt; new Vue(&#123; el: '#app', data: &#123; ok: true, message: 'VUE', id : 1 &#125; &#125;)&lt;/script&gt; 有个限制就是，每个绑定都只能包含单个表达式，所以下面的例子都不会生效。1234&lt;!-- 这是语句，不是表达式 --&gt;&#123;&#123; var a = 1 &#125;&#125;&lt;!-- 流控制也不会生效，请使用三元表达式 --&gt;&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 过滤器Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。过滤器应该被添加在双大括号插值的尾部，由“管道符”指示：1&#123;&#123; message | capitalize &#125;&#125; 如下过滤器代码实现大写首字母：123456789101112131415161718&lt;div id=\"app\"&gt; &#123;&#123; message | capitalize &#125;&#125;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app', data: &#123; message: 'vue' &#125;, filters: &#123; capitalize: function (value) &#123; if (!value) return '' value = value.toString() return value.charAt(0).toUpperCase() + value.slice(1) &#125; &#125;&#125;)&lt;/script&gt; 过滤器可以串联：1&#123;&#123; message | filterA | filterB &#125;&#125; 过滤器是 JavaScript 函数，因此可以接受参数：1&#123;&#123; message | filterA('arg1', arg2) &#125;&#125; 这里，字符串 ‘arg1’ 将传给过滤器作为第二个参数， arg2 表达式的值将被求值然后传给过滤器作为第三个参数。 指令指令 (Directives) 是带有 v- 前缀的特殊特性。指令特性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。回顾我们在vue.js初入门二中看到的例子：1234567891011&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;if为真的时候才渲染我或者说为真的时候我才存在&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;)&lt;/script&gt; 这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 &lt;p&gt; 元素。一些指令能够接收一个“参数”，在指令名称之后以冒号表示。例如，v-bind 指令可以用于响应式地更新 HTML 特性：1&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt; 在这里 href 是参数，告知 v-bind 指令将该元素的 href 特性与表达式 url 的值绑定。 另一个例子是 v-on 指令，它用于监听 DOM 事件：1&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt; v-bind和v-on,详见vue.js初入门二。 缩写v-bind 缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=\"url\"&gt;...&lt;/a&gt; v-on 缩写1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=\"doSomething\"&gt;...&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=\"doSomething\"&gt;...&lt;/a&gt; 修饰符修饰符（Modifiers）是以半角句号 . 指明的特殊后缀，用于指出一个指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()： 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;&lt;/form&gt;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"2018立夏","slug":"2018立夏","date":"2018-05-05T15:59:48.000Z","updated":"2018-08-11T15:24:48.014Z","comments":true,"path":"2018/05/05/2018立夏/","link":"","permalink":"https://www.hojun.cn/2018/05/05/2018立夏/","excerpt":"","text":"差点超时了……","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"千秋令","slug":"千秋令","date":"2018-05-05T14:47:13.000Z","updated":"2018-08-11T15:24:45.437Z","comments":true,"path":"2018/05/05/千秋令/","link":"","permalink":"https://www.hojun.cn/2018/05/05/千秋令/","excerpt":"","text":"千秋令 一曲唱遍千古风流人物","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"图集","slug":"图集","permalink":"https://www.hojun.cn/tags/图集/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"vue.js初入门(三Vue实例)","slug":"vue-js初入门-三Vue实例","date":"2018-05-05T08:10:51.000Z","updated":"2018-08-11T15:24:49.892Z","comments":true,"path":"2018/05/05/vue-js初入门-三Vue实例/","link":"","permalink":"https://www.hojun.cn/2018/05/05/vue-js初入门-三Vue实例/","excerpt":"","text":"创建实例语法123var vm = new Vue(&#123;// 选项&#125;) 在实例化 Vue 时，需要传入一个选项对象，它可以包含数据、模板、挂载元素、方法、生命周期钩子等选项。 属性与方法每个 Vue 实例都会代理其 data 对象里所有的属性：12345678910111213141516171819// 我们的数据对象var data = &#123; a: 1 &#125;// 该对象被加入到一个 Vue 实例中var vm = new Vue(&#123; data: data&#125;)// 获得这个实例上的属性// 返回源数据中对应的字段vm.a == data.a // =&gt; true// 设置属性也会影响到原始数据vm.a = 2data.a // =&gt; 2// ……反之亦然data.a = 3vm.a // =&gt; 3 当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。 值得注意的是:只有当实例被创建时 data 中存在的属性才是响应式的。也就是说如果你添加一个新的属性，比如：1vm.b = 'hi' 那么对 b 的改动将不会触发任何视图的更新。那么如果对var data对象改动会如何呢？1234567891011121314151617&lt;div id=\"app\"&gt; &#123;&#123; c &#125;&#125;&lt;/div&gt; &lt;script&gt; var data = &#123; a: 1, b: 2 &#125; //在实例化之前，页面上能输出3 // data.c = 3 var vm = new Vue(&#123; el: '#app', data: data &#125;) //在实例化之后，报错：c is not defined data.c = 3; console.log(data)&lt;/script&gt; 如果我们需要改变它呢？假设一开始它为空或不存在。我们可以设置一些初始值。比如：1234567data: &#123; a: '', b: 0, c: false, d: [], e: null&#125; 注意：如果使用了Object.freeze()方法，这会阻止修改现有的属性，也意味着响应系统无法再追踪变化。1234567891011121314151617&lt;div id=\"app\"&gt; &lt;p&gt;&#123;&#123; foo &#125;&#125;&lt;/p&gt; &lt;!-- 这里的 `foo` 不会更新！ --&gt; &lt;button v-on:click=\"foo = 'baz'\"&gt;Change it&lt;/button&gt;&lt;/div&gt;&lt;script&gt;var obj = &#123; foo: 'bar'&#125;Object.freeze(obj)new Vue(&#123; el: '#app', data: obj&#125;)&lt;/script&gt; MDN解释如下：Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的可枚举性、可配置性、可写性。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。 除了数据属性，Vue 实例还暴露了一些有用的实例属性与方法。它们都有前缀 $，以便与用户定义的属性区分开来。例如：12345678910111213var data = &#123; a: 1 &#125;var vm = new Vue(&#123; el: '#example', data: data&#125;)vm.$data === data // =&gt; truevm.$el === document.getElementById('example') // =&gt; true// $watch 是一个实例方法vm.$watch('a', function (newValue, oldValue) &#123; // 这个回调将在 `vm.a` 改变后调用&#125;) 实例生命周期 Vue1.0和2.0的对比 vue 1.0 vue 2.0 说明 init beforeCreate 组件实例刚被创建，组件属性计算之前，如data属性等 created created 组件实例化创建完成，属性已绑定，但DOM还未生成，$el属性还不存在 beforeComoile beforeMount 模板编译/挂载之前 compiled mounted 模板编译/挂载之后 ready mounted 模板编译/挂载之后（不保证组件已在document中) - beforeUpdate 组件更新之前 - updated 组件更新之后 - activated for keep-alive,组件被激活时调用 - deactivated for keep-alive,组件被移除时调用 attached - 在 vm.$el 插入 DOM 时调用。必须是由指令或实例方法插入。 detached - 在 vm.$el 从 DOM 中删除时调用。必须是由指令或实例方法删除 beforeDestory beforeDestory 组件销毁前调用 destroyed destroyed 组件销毁后调用","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(二初步认识)","slug":"vue-js初入门-二初步认识","date":"2018-05-02T13:26:35.000Z","updated":"2018-08-11T15:24:49.996Z","comments":true,"path":"2018/05/02/vue-js初入门-二初步认识/","link":"","permalink":"https://www.hojun.cn/2018/05/02/vue-js初入门-二初步认识/","excerpt":"","text":"vue的声明式渲染Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。让我们编辑经典的Hello代码，来尝试第一次使用Vue。123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;Vue初入门&lt;/title&gt; &lt;script src=\"https://cdn.bootcss.com/vue/2.4.2/vue.min.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"app\"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt; &lt;script&gt; var app = new Vue(&#123; el: '#app', data: &#123; message: 'Hello Vue!' &#125; &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 你会在页面上看到Hello Vue！文本。具体的实现原理回在后面的文章详细介绍。 我们还可以采用v-bind的方式绑定 DOM 元素属性(省略了和上一步相同的代码)：12345678910111213&lt;div id=\"app-2\"&gt; &lt;span v-bind:title=\"message\"&gt; 鼠标悬停查看当前时间 &lt;/span&gt;&lt;/div&gt;&lt;script&gt; var app2 = new Vue(&#123; el: '#app-2', data: &#123; message: '当前时间为：' + new Date() &#125; &#125;)&lt;/script&gt; 这里的v-bind属性被称为指令。指令带有前缀 v-，以表示它们是 Vue.js 提供的特殊属性。v-bind将title属性和data中的message绑定在一起，每次刷新页面都会动态的改变title属性的值。 条件与循环有其他相关语言的编程经验的人来说，在页面中使用模板语言来做条件与循环再熟悉不过了，比如java的JSP、FreeMarker。PHP的Smarty，前端模板swig、Jade等等。感觉Vue中很类似。（个人观点）Vue中的if条件：123456789&lt;div id=\"app-3\"&gt; &lt;p v-if=\"seen\"&gt;if为真的时候才渲染我或者说为真的时候我才存在&lt;/p&gt;&lt;/div&gt;var app3 = new Vue(&#123; el: '#app-3', data: &#123; seen: true &#125;&#125;) Vue中的v-for循环:12345678910111213141516171819&lt;div id=\"app-4\"&gt; &lt;ol&gt; &lt;li v-for=\"a in arr\"&gt; &#123;&#123; a.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;var app4 = new Vue(&#123; el: '#app-4', data: &#123; arr: [ &#123; text: '我是第一个元素' &#125;, &#123; text: '我是第二个元素' &#125;, &#123; text: '我是第三个元素' &#125; ] &#125;&#125;)&lt;/script&gt; 处理用户输入v-on 指令绑定一个监听事件用于调用我们 Vue实例中定义的方法：1234567891011121314151617&lt;div id=\"app-5\"&gt; &lt;p&gt;&#123;&#123; index &#125;&#125;&lt;/p&gt; &lt;button v-on:click=\"count\"&gt;加1&lt;/button&gt;&lt;/div&gt;&lt;script&gt;var app5 = new Vue(&#123; el: '#app-5', data: &#123; index: 1 &#125;, methods: &#123; count: function () &#123; this.index = this.index + 1; &#125; &#125;&#125;)&lt;/script&gt; 这段代码实现了每点击一次按钮index都累加1。Vue 也提供了 v-model指令，它使得在表单输入和应用状态中做双向数据绑定变得非常轻巧12345678910&lt;div id=\"app-6\"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model=\"message\"&gt;&lt;/div&gt;var app6 = new Vue(&#123; el: '#app-6', data: &#123; message: 'Hello Vue!' &#125;&#125;) 手动改变input的值会是P标签的值也随之改变。12&lt;input v-model=\"sth\" /&gt;&lt;input v-bind:value=\"sth\" v-on:input=\"sth = $event.target.value\" /&gt; 第一行的代码其实只是第二行的语法糖。这样理解model可能更能接受一些。 用组件构建（应用）组件系统是 Vue 另一个重要概念，因为它提供了一种抽象，让我们可以用独立可复用的小组件来构建大型应用。如果我们考虑到这点，几乎任意类型的应用的界面都可以抽象为一个组件树。举个栗子：12345678910111213&lt;div id=\"example\"&gt; &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;&lt;script&gt;// 注册Vue.component('my-component', &#123; template: '&lt;div&gt;这是一个自定义组件&lt;/div&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#example'&#125;)&lt;/script&gt; 我们在后面再详细介绍它。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"数据恢复练习必备——创建虚拟磁盘","slug":"数据恢复练习必备——创建虚拟磁盘","date":"2018-04-30T13:32:36.000Z","updated":"2018-08-11T15:24:46.215Z","comments":true,"path":"2018/04/30/数据恢复练习必备——创建虚拟磁盘/","link":"","permalink":"https://www.hojun.cn/2018/04/30/数据恢复练习必备——创建虚拟磁盘/","excerpt":"","text":"在看《数据重现》这本书的进行实操安装InsPro Disk的时候，发现有网友反映Win764不能用！？！？原来win7自带有虚拟磁盘工具啊，那win10也应该有了。百度找了篇教程： 此电脑右击——管理 点击磁盘管理眼尖的网友可能会发现怎么会有这么多恢复分区？？（文章最后会做解释） 操作————创建VHD 位置自己选个文件夹————大小随便给个100MB————确定 创建成功如下图 右键初始化磁盘 推荐选择MBR————确定 右键————新建简单卷 进入新建向导 下一步 下一步 这里文件系统选择FAT32（作者学习需要） 完成 好了，win10下创建虚拟磁盘就是这么简单~ 怎么删除删除就直接分离VHD，再手动删除文件夹下的硬盘映像文件即可 现在来聊聊那几个恢复分区的事。我清楚的记得电脑刚到手的时候是亲自为磁盘分的区，怎么会多出这么多多恢复分区？于是上网搜寻到答案： 这个恢复分区是干什么用的？从Vista开始Windows系统中都内置了恢复环境（WinRE），其中包含一些恢复工具，相当于一个微型操作系统环境。恢复环境系统文件都存放在名为WinRE.wim的文件中，没错，这个恢复分区就是用来存放WinRE文件的。 为什么会单独划分一个分区?在Win7中恢复环境与系统在同一分区，到了Win8中，为了保证恢复环境的可用性以及UEFI启动的特殊性，微软默认将其放在了系统保留分区中。于是系统保留分区就从之前Windows7中的100MB增大到了Windows8/Windows 8.1中的350MB，而且WinRE文件体积也增大了不少。到了Win10，WinRE的体积进一步增大，原保留分区已经容纳不下了，于是从Win7/Win8/Win8.1系统升级到Win10之后，(如果之前有保留分区)系统都会自动创建一个额外的分区来存储恢复环境。 什么是恢复环境？“恢复分区”可不可以删除？你可能有印象，安装Win7系统的电脑在开机前按F8会进入高级启动选项，在这里点击“修复计算机”就会进入恢复环境。在Win8/Win8.1/Win10中，打开系统设置中的“高级启动”也会进入恢复环境。在恢复环境中可以执行系统还原点还原、启动修复、系统映像恢复等操作，Win8/Win10中的电脑重置同样依赖于恢复环境，如果你想保留这些功能就不可以删掉“恢复分区”。当你想重装Win10系统时可以将其删除，在重分区时安装程序会自动新建恢复分区或容量更大的保留分区（64位Win10为500MB）来保存恢复环境。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://www.hojun.cn/tags/win10/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"vue.js初入门(一)","slug":"vue-js初入门(一)","date":"2018-04-29T13:20:35.000Z","updated":"2018-08-11T15:24:49.805Z","comments":true,"path":"2018/04/29/vue-js初入门(一)/","link":"","permalink":"https://www.hojun.cn/2018/04/29/vue-js初入门(一)/","excerpt":"","text":"什么是Vue?Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。Vue.js 不支持 IE8 及其以下版本，因为 Vue.js 使用了 IE8 不能实现的ECMAScript 5 特性。 Vue.js 支持所有兼容 ECMAScript 5 的浏览器。 安装(建议在优质的网络环境下的时候进行实践操作。网速不够的可以使用npm的淘宝镜像) 首先要有node环境和npm包管理工具。安装node的时候一般会默认连带安装npm，所以建议直接安装node就行。（这里就不介绍怎么安装node了，自行百度）这里我们使用vue-cli脚手架来安装vue。所以先安装cli:打开cmd命令行工具，输入npm安装命令(我在这里选择全局安装 )1npm install -g vue-cli 安装可能需要一些时间，请耐心等待。安装成功后效果如图： 接下来使用webpack安装vue项目模板，输入命令：(hi-vue是项目名，可以自定义)1vue init webpack hi-vue 默认安装最新稳定版，若需要安装1.0版本则需指定版本号，命令如下：1vue init webpack#1.0 hi-vue 接下来配置一些信息：项目的名称？输入 “y” 回车确认项目说明？输入 “vue-js初入门”作者？输入 “y” 回车确认提供两个模式选项(推荐第二种)Runtime + Compiler: recommended for most users //运行加编译Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specific HTML) are ONLY allowed in .vue files - render functions are required elsewhere //小6kb,但需要使用.vue文件来开发安装vue-router?使用ESlint来规范你的代码？使用哪种规则？Standard安装unit测试？输入 “n” 回车确认安装e2e测试？输入 “n” 回车确认选择安装方式？选择npm请耐心等待安装完成~(建议网速好的时候安装)安装完成效果如图：根据指示运行命令：12cd hi-vuenpm run dev 打开浏览器，在地址栏输入localhost:8080。得到如下效果:","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"vue","slug":"vue","permalink":"https://www.hojun.cn/tags/vue/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"给博客添加图集展示","slug":"给博客添加图集展示","date":"2018-04-24T15:04:40.000Z","updated":"2018-08-11T15:24:47.014Z","comments":true,"path":"2018/04/24/给博客添加图集展示/","link":"","permalink":"https://www.hojun.cn/2018/04/24/给博客添加图集展示/","excerpt":"","text":"嗯。。。。。没想好怎么做 前言拖了这么久，决定用fancybox.js来搞个图集凑合凑合 简单了解fancybox参照官网官网介绍如下：JavaScript lightbox library for presenting various types of media. Responsive, touch-enabled and customizable.看不懂的路过 这里我们使用fancybox3，首页点击下载往下拉可查看demo效果下载至桌面，解压得到该文件夹。浏览器下打开该文件，阅读文档在How to Use下面查阅代码例子1234567891011121314&lt;a href=\"image_1.jpg\" data-fancybox=\"gallery\" data-caption=\"Caption #1\"&gt; &lt;img src=\"thumbnail_1.jpg\" alt=\"\" /&gt;&lt;/a&gt;&lt;a href=\"image_2.jpg\" data-fancybox=\"gallery\" data-caption=\"Caption #2\"&gt; &lt;img src=\"thumbnail_2.jpg\" alt=\"\" /&gt;&lt;/a&gt;//我们需要的基本代码就是这样&lt;script&gt;$('[data-fancybox=\"gallery\"]').fancybox(&#123; // Options will go here&#125;);&lt;/script&gt; 在Options下查看fancybox的一些参数 在hexo博客中使用fancybox方案一在文章.md文件中使用raw标签直接插入如下代码：123456789101112131415&lt;link rel=\"stylesheet\" href=\"jquery.fancybox.min.css\"&gt;&lt;a href=\"image_1.jpg\" data-fancybox=\"gallery\" data-caption=\"Caption #1\"&gt; &lt;img src=\"thumbnail_1.jpg\" alt=\"\" /&gt;&lt;/a&gt;&lt;a href=\"image_2.jpg\" data-fancybox=\"gallery\" data-caption=\"Caption #2\"&gt; &lt;img src=\"thumbnail_2.jpg\" alt=\"\" /&gt;&lt;/a&gt;&lt;script src=\"jquery.fancybox.min.js\"&gt;&lt;/script&gt;&lt;script&gt;$('[data-fancybox=\"gallery\"]').fancybox(&#123; // Options will go here&#125;);&lt;/script&gt; 这种方法有些太麻烦了，于是有了方案二。 方案二在文章.md文件中使用raw标签直接插入如下代码:12345&lt;img class=\"hj_img\" src=\"https://wx1.sinaimg.cn/large/006bYVyvgy1fr0tc3y3avj31kw0vzqv5.jpg\"&gt;&lt;img class=\"hj_img\" src=\"https://wx4.sinaimg.cn/large/006bYVyvgy1fr0ufullbkj31kw0vz4qq.jpg\"&gt;&lt;img class=\"hj_img\" src=\"https://wx4.sinaimg.cn/large/006bYVyvgy1fr0ug1074xj31kw0vr4qp.jpg\"&gt;&lt;img class=\"hj_img\" src=\"https://wx2.sinaimg.cn/large/006bYVyvgy1fr0ugfyw4aj31kw0vue82.jpg\"&gt;&lt;img class=\"hj_img\" src=\"https://wx4.sinaimg.cn/large/006bYVyvgy1fr0ug8ds8xj31kw0vxqv5.jpg\"&gt; 接着使用js给他转换成需要的格式。博主是在footer的模板下插入如下代码12345678910111213141516171819202122//前面需要引入fancybox的css和js，这里省略&lt;secrpt&gt;(function() &#123; //前面部分是判断是标签否为图集的文章，根据需求可以舍弃 var arr = new Array(); var $tags = $('.post-tags').children('a'); $tags.each(function() &#123; arr.push($(this).html()) &#125;) if (arr.indexOf(\"图集\") !== -1) &#123; //如果是图集 $('.hj_img').each(function() &#123; $(this).wrap('&lt;a class=\"fancybox\" data-fancybox=\"gallery\" href=\"' + $(this).prop(\"src\") + '\"&gt;&lt;/a&gt;'); &#125;) //初始化fancybox，padding设为0，loop设为false $('.fancybox').fancybox(&#123; padding: 0, loop: false &#125;); &#125;&#125;)();&lt;/script&gt; 方案三这里只提供个思路，因为方案二版的实现很简便，就没去折腾了。 大致思路即是修改maked.js生成渲染的规则，根据图集图片的特定标志，识别出来，把需要的a标签渲染出来。直接生成文件。 实现过程可参照我之前的两篇文章OwO-可爱的js表情符号插件和Lozad.js学习使用 终·效果预览安利一波 动漫 《K》","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"},{"name":"图集","slug":"图集","permalink":"https://www.hojun.cn/tags/图集/"},{"name":"lab","slug":"lab","permalink":"https://www.hojun.cn/tags/lab/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"八重樱:文雅，你言而不决中的温柔和耐心","slug":"八重樱-文雅，你言而不决中的温柔和耐心","date":"2018-04-23T12:22:43.000Z","updated":"2018-08-11T15:24:44.946Z","comments":true,"path":"2018/04/23/八重樱-文雅，你言而不决中的温柔和耐心/","link":"","permalink":"https://www.hojun.cn/2018/04/23/八重樱-文雅，你言而不决中的温柔和耐心/","excerpt":"","text":"八重樱，别名“丹樱”、“奈良八重樱带草” function sakuraInit() { $(document).snowfall('clear'); if (document.body.clientWidth > 600) { $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:50, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:50, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/2.png\", flakeCount:50, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/4.png\", flakeCount:50, minSpeed:1, minSize:8, maxSize:15,}); } else { $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:30, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:30, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/2.png\", flakeCount:30, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/4.png\", flakeCount:30, minSpeed:1, minSize:8, maxSize:15,}); } } window.onload = sakuraInit();","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"图集","slug":"图集","permalink":"https://www.hojun.cn/tags/图集/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"OwO-可爱的js表情符号插件","slug":"OwO-可爱的js表情符号插件","date":"2018-04-22T13:32:40.000Z","updated":"2018-08-11T15:24:49.170Z","comments":true,"path":"2018/04/22/OwO-可爱的js表情符号插件/","link":"","permalink":"https://www.hojun.cn/2018/04/22/OwO-可爱的js表情符号插件/","excerpt":"","text":"表情图片给我们带来了很多欢乐，我们使用着各种表情表述自己的心情，拉动聊天气氛~（虽然常常聊着聊着就成了斗图大赛）。但是啊，系不系开心就好~ 今天给各位博主带来了一个js表情插件,效果如下： var OwO_OwO = new OwO({ logo: 'OωO表情', container: document.getElementsByClassName('OwO')[0], target: document.getElementsByClassName('OwO-textarea')[0], api: '/OwO/json/OwO.json', position: 'down', width: '100%', maxHeight: '250px' }); 首先感谢OwOde作者DIYgod，项目开源在github上https://github.com/DIYgod/OwO。 使用教程安装1$ npm install owo --save 或者直接去github下载源码 使用HTML12345&lt;link rel=\"stylesheet\" href=\"OwO.min.css\"&gt;&lt;!-- ... --&gt;&lt;div class=\"OwO\"&gt;&lt;/div&gt;&lt;!-- ... --&gt;&lt;script src=\"OwO.min.js\"&gt;&lt;/script&gt; JS123456789var OwO_demo = new OwO(&#123; logo: 'OωO表情', container: document.getElementsByClassName('OwO')[0], target: document.getElementsByClassName('OwO-textarea')[0], api: './OwO.json', position: 'down', width: '100%', maxHeight: '250px'&#125;); 然而这并不是真正的目的，真正目的是为了在文章里添加表情~~~让自己的文章充满画面感，就像现在一样。 怎么实现呢？第一步约定语法我们约定 *@(表情名)* 为插入表情的语法 第二步解析markdown博主使用的是hexo搭建的博客，在node_modules中找到解析markdown的js文件(可以看我的另一篇关于lozad.js文章有介绍)\\node_modules\\_marked@0.3.6@marked\\lib\\marked.js这里偷了一个小懒(其实是新建的搞不定)，直接使用em即斜体的语法，在内部加了个正则匹配，来识别我们的表情语法。具体代码如下：marked.js12345678910111213141516Renderer.prototype.em = function(text) &#123; var match = text.match(/@\\((\\S*?)\\)/g); if(match) &#123; var str = ''; var mlength = match.length; for (var i = 0; i &lt; mlength; i++) &#123; var emoji = match[i].substring(2); emoji = emoji.substring(0, emoji.length-1); //对应的表情图片地址，图片可自定义。表情名=图片名，并统一为png格式 emoji = '&lt;img class=\"owoemoji\" src=\"/OwO/img/' + emoji + '.png\"&gt;'; str += emoji; &#125; return str; &#125; return '&lt;em&gt;' + text + '&lt;/em&gt;';&#125;; 第三步添加hover效果添加表情hover贱贱的抖动css效果123456789101112131415161718192021/*OwO emoji*/.owoemoji &#123; display: inline-block !important; position: relative; top: 10px; margin: 0 !important; padding: 0;&#125;.owoemoji:hover &#123; animation: owo-face 5s infinite ease-in-out;&#125;@keyframes owo-face &#123; 2% &#123; transform: translate(0, 1.5px) rotate(1.5deg); &#125; 4% &#123; transform: translate(0, -1.5px) rotate(-0.5deg); &#125; 太长略过...&#125; 好了，接下来就可以在你的markdown里面使用*@(表情名)*来添加表情，添加你的创作乐趣了！祝大家开心生活，越活越年轻~","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.hojun.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"逗比日记-180422","slug":"逗比日记180422","date":"2018-04-22T13:15:17.000Z","updated":"2018-08-11T15:24:47.870Z","comments":true,"path":"2018/04/22/逗比日记180422/","link":"","permalink":"https://www.hojun.cn/2018/04/22/逗比日记180422/","excerpt":"","text":"右脚烫伤!!!","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"},{"name":"日记","slug":"日记","permalink":"https://www.hojun.cn/tags/日记/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"CSS妙用伪元素before、after","slug":"CSS妙用伪元素before、after","date":"2018-04-19T13:22:48.000Z","updated":"2018-08-11T15:24:48.260Z","comments":true,"path":"2018/04/19/CSS妙用伪元素before、after/","link":"","permalink":"https://www.hojun.cn/2018/04/19/CSS妙用伪元素before、after/","excerpt":"","text":"css——层叠样式表,简单理解就是用来装饰网页的样子，比如颜色，大小，位置等等。总之，你现在能看到美轮美奂的网页就是css的功劳。今天介绍一下css中伪元素before、after的妙用小技巧。首先纠正下写法： 伪类用一个冒号表示 :hover 伪元素则使用两个冒号表示 ::before 小例子一 导航鼠标悬停特效123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;html&gt; &lt;style&gt; ul &#123; padding: 0; margin: 0; font-size: 12px; &#125; li &#123; font-size: 20px; padding: 5px 15px 5px 15px; display: inline-block; position: relative; cursor: pointer; transition: all 0.5s; &#125; /*默认设置left=100%表示在最右边*/ li::before &#123; content: ''; display: block; position: absolute; width: 0%; bottom: 0; left: 100%; border-bottom: 2px solid #999; /*all 0.5秒 表示所有类型的过渡动画都在0.5秒内完成*/ transition: all 0.5s; &#125; /*鼠标hover上去的时候width从0变化至100*/ li:hover::before &#123; left:0; width:100%; &#125; /*表示设置位于hover之后的li的before的left为0。实现向右移动的时候下面的线条从左往右出现*/ li:hover ~ li::before &#123; left:0; &#125; &lt;/style&gt; &lt;ul&gt; &lt;li&gt;第一栏&lt;/li&gt; &lt;li&gt;第二栏&lt;/li&gt; &lt;li&gt;第三栏&lt;/li&gt; &lt;li&gt;第四栏&lt;/li&gt; &lt;li&gt;第五栏&lt;/li&gt; &lt;/ul&gt;&lt;/html&gt; 小例子二：手机滑盖效果123456789101112131415161718192021222324252627282930313233&lt;style type=\"text/css\"&gt; div#phone li:before&#123; content: url(./img/wangwang.jpg); position: relative; display: block; transition: transform 1s; &#125; div#phone li:after&#123; content: url(./img/bujibuji.jpg); position: relative; top: -750px; display: block; transition: transform 1s; &#125; div#phone li:hover:before&#123; transform: translate(-40%,0); &#125; div#phone li:hover:after&#123; transform: translate(40%,0); &#125; li&#123; list-style-type: none; width: 500px; margin: 20px auto; &#125;&lt;/style&gt;&lt;div id=\"phone\"&gt; &lt;li&gt;&lt;/li&gt;&lt;/div&gt; 小例子三 翻转效果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151&lt;html&gt; &lt;style&gt; *, *::after, *::before &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; &#125; nav a &#123; position: relative; display: inline-block; margin: 15px 25px; outline: none; color: #fff; text-decoration: none; text-transform: uppercase; letter-spacing: 1px; font-weight: 400; text-shadow: 0 0 1px rgba(255,255,255,0.3); font-size: 1.35em; &#125; nav a:hover, nav a:focus &#123; outline: none; &#125; .cl-effect-2 a &#123; line-height: 44px; -webkit-perspective: 1000px; -moz-perspective: 1000px; perspective: 1000px; &#125; .cl-effect-2 a span &#123; position: relative; display: inline-block; padding: 0 14px; background: #2195de; -webkit-transition: -webkit-transform 0.3s; -moz-transition: -moz-transform 0.3s; transition: transform 0.3s; -webkit-transform-origin: 50% 0; -moz-transform-origin: 50% 0; transform-origin: 50% 0; -webkit-transform-style: preserve-3d; -moz-transform-style: preserve-3d; transform-style: preserve-3d; text-align: center; &#125; .cl-effect-2 a span::before &#123; position: absolute; top: 100%; left: 0; width: 100%; height: 100%; background: #0965a0; content: attr(data-hover); -webkit-transition: background 0.3s; -moz-transition: background 0.3s; transition: background 0.3s; -webkit-transform: rotateX(-90deg); -moz-transform: rotateX(-90deg); transform: rotateX(-90deg); -webkit-transform-origin: 50% 0; -moz-transform-origin: 50% 0; transform-origin: 50% 0; text-align: center; &#125; .cl-effect-2 a:hover span, .cl-effect-2 a:focus span &#123; -webkit-transform: rotateX(90deg) translateY(-22px); -moz-transform: rotateX(90deg) translateY(-22px); transform: rotateX(90deg) translateY(-22px); &#125; .cl-effect-2 a:hover span::before, .cl-effect-2 a:focus span::before &#123; background: #28a2ee; &#125; .cl-effect-19 a &#123; line-height: 2em; -webkit-perspective: 800px; -moz-perspective: 800px; perspective: 800px; &#125; .cl-effect-19 a span &#123; position: relative; display: inline-block; width: 100%; padding: 0 14px; background: #e35041; -webkit-transition: -webkit-transform 0.4s, background 0.4s; -moz-transition: -moz-transform 0.4s, background 0.4s; transition: transform 0.4s, background 0.4s; -webkit-transform-style: preserve-3d; -moz-transform-style: preserve-3d; transform-style: preserve-3d; -webkit-transform-origin: 50% 50% -60px; -moz-transform-origin: 50% 50% -60px; transform-origin: 50% 50% -60px; text-align: center; &#125; .cl-effect-19 a span::before &#123; position: absolute; top: 0; left: 100%; width: 100%; height: 100%; background: #b53a2d; content: attr(data-hover); -webkit-transition: background 0.4s; -moz-transition: background 0.4s; transition: background 0.4s; -webkit-transform: rotateY(90deg); -moz-transform: rotateY(90deg); transform: rotateY(90deg); -webkit-transform-origin: 0 50%; -moz-transform-origin: 0 50%; transform-origin: 0 50%; pointer-events: none; text-align: center; &#125; .cl-effect-19 a:hover span, .cl-effect-19 a:focus span &#123; background: #b53a2d; -webkit-transform: rotateY(-90deg); -moz-transform: rotateY(-90deg); transform: rotateY(-90deg); &#125; .cl-effect-19 a:hover span::before, .cl-effect-19 a:focus span::before &#123; background: #ef5e50; &#125; &lt;/style&gt; &lt;section class=\"color-4\"&gt; &lt;nav class=\"cl-effect-2\" id=\"cl-effect-2\"&gt; &lt;a href=\"#cl-effect-2\"&gt;&lt;span data-hover=\"上下翻转\"&gt;上下翻转&lt;/span&gt;&lt;/a&gt; &lt;/nav&gt; &lt;nav class=\"cl-effect-19\" id=\"cl-effect-19\"&gt; &lt;a href=\"#cl-effect-19\"&gt;&lt;span data-hover=\"左右翻转\"&gt;左右翻转&lt;/span&gt;&lt;/a&gt; &lt;/nav&gt; &lt;/section&gt;&lt;/html&gt;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.hojun.cn/tags/css/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"python操作word","slug":"python操作word","date":"2018-04-18T15:45:53.000Z","updated":"2018-08-11T15:24:49.489Z","comments":true,"path":"2018/04/18/python操作word/","link":"","permalink":"https://www.hojun.cn/2018/04/18/python操作word/","excerpt":"","text":"python操作word我们需要用到python-docx这个库。 安装命令：1pip install python-docx 官方文档地址http://python-docx.readthedocs.io/en/latest/官方demo:123456789101112131415161718192021222324252627282930313233343536373839404142from docx import Documentfrom docx.shared import Inchesdocument = Document()# 添加标题document.add_heading('Document Title', 0)#添加文本p = document.add_paragraph('A plain paragraph having some ')# 设置粗体p.add_run('bold').bold = Truep.add_run(' and some ')# 设置斜体p.add_run('italic.').italic = True# 添加一级标题document.add_heading('Heading, level 1', level=1)# 添加样式document.add_paragraph('Intense quote', style='IntenseQuote')document.add_paragraph( 'first item in unordered list', style='ListBullet')document.add_paragraph( 'first item in ordered list', style='ListNumber')# 添加图片document.add_picture('monty-truth.png', width=Inches(1.25))# 添加表格table = document.add_table(rows=1, cols=3)hdr_cells = table.rows[0].cellshdr_cells[0].text = 'Qty'hdr_cells[1].text = 'Id'hdr_cells[2].text = 'Desc'for item in recordset: row_cells = table.add_row().cells row_cells[0].text = str(item.qty) row_cells[1].text = str(item.id) row_cells[2].text = item.desc#添加分页符document.add_page_break()#保存文档document.save('demo.docx') 效果如下： 看了上面的官方demo就能直接上手使用了。不过我建议自己可以按需封装一下方法1234567891011121314151617181920212223from docx import Documentfrom docx.shared import Inchesfrom docx.enum.text import WD_ALIGN_PARAGRAPHfrom docx.shared import Ptfrom docx.oxml.ns import qn document = Document()#设置文档默认字体document.styles['Normal'].font.name = u'微软雅黑' document.styles['Normal']._element.rPr.rFonts.set(qn('w:eastAsia'), u'微软雅黑')title = document.add_paragraph()#大标题居中title.paragraph_format.alignment = WD_ALIGN_PARAGRAPH.CENTER# 参数#文档对象，文字内容，文字大小，文字样式（目前就只判断了粗体）def writeP(document, content, size, style = None): p = document.add_paragraph() run = p.add_run(content) font = run.font font.size = Pt(size) if style == 'bold': font.bold = True 好了，python操作word就介绍到这里，大家可以去尝试一下。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hojun.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"简单理解海明校验码","slug":"简单理解海明校验码","date":"2018-04-16T16:26:32.000Z","updated":"2018-08-11T15:24:46.687Z","comments":true,"path":"2018/04/17/简单理解海明校验码/","link":"","permalink":"https://www.hojun.cn/2018/04/17/简单理解海明校验码/","excerpt":"","text":"二进制数据经过传送、存取等环节，会发生误码(1变成0或0变成1)，这就有如何发现及纠正误码的问题。所有解决此类问题的方法就是在原始数据(数码位)基础上增加几位校验位。我们常使用的检验码有三种. 分别是奇偶校验码、海明校验码和循环冗余校验码(CRC)。 海明校验码是由RichardHamming于1950年提出、目前还被广泛采用的一种很有效的校验方法。它的实现原理，是在k个数据位之外加上r个校验位，从而形成一个k+r位的新的码字，使新的码字的码距比较均匀地拉大。把数据的每一个二进制位分配在几个不同的偶校验位的组合中，当某一位出错后，就会引起相关的几个校验位的值发生变化，这不但可以发现出错，还能指出是哪一位出错，为进一步自动纠错提供了依据。但是因为这种海明校验的方法只能检测和纠正一位出错的情况。所以如果有多个错误，就不能查出了。 什么是码距？两个码组对应位上数字的不同位的个数称为码组的距离，简称码距，又称海明（Hamming）距离。例如00110和00100码距为1，12345和13344码距为2，Caus和Daun码距为2。 海明校验码公式（假设为k个数据位设置r个校验位）12^r-1 ≥ k + r 公式怎么得出来的呢？假设有r个校验位，一个位子有0或1两种情况，r个位子就有2^r种排列情况，能表示2^r种状态。其中一个状态用来表示正确（没有错误发生）的这种情况。其余的2^r-1种状态来表示错误发生在哪一位。总共有k+r位，所以2^r-1一定要&gt;=总位子k+r。按照该不等可以得出k与r的对应关系 k值 r值 1 2 2～4 3 5～11 4 12～26 5 27～57 6 58～120 7 … … 注意：海明校验码是放在2的幂次位上的，即“1,2,4,8,16,32······” 实战求1011的海明码第一步：求r的值（即校验位数）直接根据公式代入得：2^r-1 ≥ 4 + r2^r-r ≥ 5得到r最小为3所以海明码的位数是4+3=7位第二步：校验位和信息位对号入座注意： 信息位的位置分配是从高位到低位依次存放注意： 海明校验码是放在2的幂次位上的 位数 1 2 3 4 5 6 7 信息位 1 1 0 1 校验位 r1 r2 r3 第三步：确定校验位的值校验原则：被校验的海明位的下标等于所有参与校验该为的校验位的下标之和 海明码 海明码下标 校验位组 信息位 1 1 r1 2 2 r2 3 3=2+1 r1,r2 1 4 4 r3 5 5=4+1 r3,r1 1 6 6=4+2 r3,r2 0 7 7=4+3 r3,r2,r1 1 然后将校验码校验的信息位的位置记录下来： r1: 3, 5, 7 r2: 3, 6, 7 r3: 5, 6, 7 然后做对应信息位的异或运算(异或的运算法则为：0⊕0=0，1⊕0=1，0⊕1=1，1⊕1=0（同为0，异为1）) r1: 1 xor 1 xor 1 = 1 r2: 1 xor 0 xor 1 = 0 r3: 1 xor 0 xor 1 = 0 代入表格得到 位数 1 2 3 4 5 6 7 信息位 1 1 0 1 校验位 1 0 0 注意：按照从低位到高位的排列顺序得到海明码：1010101","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"软考","slug":"软考","permalink":"https://www.hojun.cn/tags/软考/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Thinkphp3.2.3发现SQL注入漏洞！","slug":"Thinkphp3-2-3发现SQL注入漏洞！","date":"2018-04-16T11:40:40.000Z","updated":"2018-08-11T15:24:49.760Z","comments":true,"path":"2018/04/16/Thinkphp3-2-3发现SQL注入漏洞！/","link":"","permalink":"https://www.hojun.cn/2018/04/16/Thinkphp3-2-3发现SQL注入漏洞！/","excerpt":"","text":"安全客文章报道发现Thinkphp3.2.3最新版SQL注入漏洞！还使用Thinkphp3.2.3版本的小伙伴赶紧去github上更新补丁！ 漏洞详情由于框架实现安全数据库过程中在update更新数据的过程中存在SQL语句的拼接，并且当传入数组未过滤时导致出现了SQL注入。 thinkphp系列框架过滤表达式注入多半采用I函数去调用think_filter12function think_filter(&amp;$value)&#123; if(preg_match('/^(EXP|NEQ|GT|EGT|LT|ELT|OR|XOR|LIKE|NOTLIKE|NOT BETWEEN|NOTBETWEEN|BETWEEN|NOTIN|NOT IN|IN)$/i',$value)) 有没有相关tips来达到I函数绕过呢？是可以的。一般按照官方的写法，thinkphp提供了数据库链式操作，其中包含连贯操作和curd操作，在进行数据库CURD操作去更新数据的时候：举例update数据操作。直接看框架的where子单元函数，之前网上公开的exp表达式注入就是从这里分析出来的结论:Thinkphp/Library/Think/Db/Driver.class.php其中除了exp能利用外还有一处bind，而bind可以完美避开了think_filter： 1234elseif('bind' == $exp )&#123; // 使用表达式 $whereStr .= $key.' = :'.$val[1];&#125;elseif('exp' == $exp )&#123; // 使用表达式 $whereStr .= $key.' '.$val[1]; 这里由于拼接了$val参数的形式造成了注入，但是这里的bind表达式会引入:符号参数绑定的形式去拼接数据，通过白盒对几处CURD操作函数进行分析定位到update函数，insert函数会造成sql注入，于是回到上面的updateh函数。Thinkphp/Library/Think/Db/Driver.class.php接着跟进execute函数，这里有处对$this-&gt;queryStr进行字符替换的操作： 1$this-&gt;queryStr = strtr($this-&gt;queryStr,array_map(function($val) use($that)&#123; return '''.$that-&gt;escapeString($val).'''; &#125;,$this-&gt;bind)); 具体是什么，我这里写了一个实例：常规的跟新数据库用户信息的操作：Application/Home/Controller/UserController.class.php12345678910111213&lt;?phpnamespace HomeController;use ThinkController;class UserController extends Controller &#123; public function index()&#123; $User = M(\"member\"); $user['id'] = I('id'); $data['money'] = I('money'); $data['user'] = I('user'); $valu = $User-&gt;where($user)-&gt;save($data); var_dump($valu); &#125;&#125; 根据进来的id更新用户的名字和钱，构造一个简单一个pocid[]=bind&amp;id[]=1’&amp;money[]=1123&amp;user=liao当走到execute函数时sql语句为：1UPDATE `member` SET `user`=:0 WHERE `id` = :1' 然后$that = $this然后下面的替换操作是将”:0”替换为外部传进来的字符串，这里就可控了。替换后：明显发现之前的user参数为:0然后被替换为了liao，这样就把:替换掉了。后面的:1明显是替换不掉的：那么我们将id[1]数组的参数变为0呢？id[]=bind&amp;id[]=0%27&amp;money[]=1123&amp;user=liao果然造成了注入：POC:money[]=1123&amp;user=liao&amp;id[0]=bind&amp;id[1]=0%20and%20(updatexml(1,concat(0x7e,(select%20user()),0x7e),1)) 修复方式更新最新补丁https://github.com/top-think/thinkphp/原文地址www.anquanke.com/post/id/104847","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.hojun.cn/tags/php/"},{"name":"thinkphp","slug":"thinkphp","permalink":"https://www.hojun.cn/tags/thinkphp/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"网页图片实现层次+旋转的3D展示效果","slug":"网页图片实现层次-旋转的3D展示效果","date":"2018-04-15T13:25:41.000Z","updated":"2018-08-11T15:24:47.195Z","comments":true,"path":"2018/04/15/网页图片实现层次-旋转的3D展示效果/","link":"","permalink":"https://www.hojun.cn/2018/04/15/网页图片实现层次-旋转的3D展示效果/","excerpt":"","text":"今天在学习vue的时候发了一个简单的banner效果图：如下（来源） * { padding: 0; margin: 0; box-sizing: border-box; } .banner { -webkit-perspective: 3000px; perspective: 3000px; position: relative; z-index: 19 } .bg { position: relative; width: 100%; height: 250px; margin: 20px auto; background: url(https://wx4.sinaimg.cn/large/006bYVyvgy1fqdnxdzbizj30v40csn2k.jpg) 50% no-repeat; background-size: 100% 100%; border-radius: 10px; -webkit-transform-style: preserve-3d; transform-style: preserve-3d; -webkit-transform-origin: 50% 50%; -webkit-transform: rotateY(0deg) rotateX(0deg); } .img { display: block; position: absolute; width: 100%; height: 100%; bottom: 5px; left: 0; background: url(\"/images/2018/banner-3d.png\") center no-repeat; background-size: 95% 100%; } .text { position: absolute; top: 20%; right: 10%; font-size: 20px; color: #fff; text-align: right; font-weight: lighter; } .copyright { position: absolute; bottom: 10%; right: 10%; font-size: 10px; color: #fff; text-align: right; font-weight: lighter; } .a { -webkit-transform: translateZ(40px); } .b { -webkit-transform: translateZ(20px); } .c { -webkit-transform: translateZ(0px); } 以傲慢与偏执 回敬傲慢与偏见 code by qingjin.me | picture from t.tt var bindEvent = function(dom, eventName, listener){ if(dom.attachEvent) { dom.attachEvent('on'+eventName, listener); } else { dom.addEventListener(eventName, listener); } } var bg = document.getElementById('bg'); bindEvent(bg, 'mousemove', function(e){ let x = e.offsetX - (bg.offsetWidth / 2) let y = bg.offsetHeight / 2 - e.offsetY bg.style['-webkit-transform'] = `rotateY(${x / 100}deg) rotateX(${y / 100}deg)` bg.style.transform = `rotateY(${x / 100}deg) rotateX(${y / 100}deg)` }) bindEvent(bg, 'mouseout', function(e){ bg.style['-webkit-transform'] = `rotateY(0deg) rotateX(0deg)` bg.style.transform = `rotateY(0deg) rotateX(0deg)` }) 感觉挺有意思，于是就给它实现一波。(html和css是扒的)实现原理就是两张图片在3d中显示前后位置，通过透视图perspective属性实现（透视图和我们的眼睛看到的是一样的，越远的物体看上去越小。还有种正交视图，不会根据距离收缩。）代码如下:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;style&gt;* &#123; padding: 0; margin: 0; box-sizing: border-box;&#125;.banner &#123; -webkit-perspective: 3000px; perspective: 3000px; position: relative; z-index: 19&#125;.bg &#123; position: relative; width: 1220px; height: 500px; margin: 20px auto; background: url(banner-3d-item.png) 50% no-repeat; background-size: 100% 100%; border-radius: 10px; -webkit-transform-style: preserve-3d; transform-style: preserve-3d; -webkit-transform-origin: 50% 50%; -webkit-transform: rotateY(0deg) rotateX(0deg);&#125;.img &#123; display: block; position: absolute; width: 100%; height: 100%; bottom: 5px; left: 0; background: url(\"banner-3d.png\") center no-repeat; background-size: 95% 100%;&#125;.text &#123; position: absolute; top: 20%; right: 10%; font-size: 30px; color: #fff; text-align: right; font-weight: lighter;&#125;.copyright &#123; position: absolute; bottom: 10%; right: 10%; font-size: 10px; color: #fff; text-align: right; font-weight: lighter;&#125;.a &#123; -webkit-transform: translateZ(40px);&#125;.b &#123; -webkit-transform: translateZ(20px);&#125;.c &#123; -webkit-transform: translateZ(0px);&#125;&lt;/style&gt;&lt;div class=\"banner\"&gt; &lt;div class=\"bg\" id=\"bg\" style=\"transform: rotateY(0deg) rotateX(0deg);\"&gt; &lt;span class=\"img a\"&gt; &lt;/span&gt; &lt;span class=\"text b\"&gt; 以傲慢与偏执&lt;br&gt; 回敬傲慢与偏见&lt;/span&gt; &lt;span class=\"copyright c\"&gt; code by qingjin.me | picture from t.tt&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt;var bindEvent = function(dom, eventName, listener)&#123; if(dom.attachEvent) &#123; dom.attachEvent('on'+eventName, listener); &#125; else &#123; dom.addEventListener(eventName, listener); &#125; &#125; var bg = document.getElementById('bg'); bindEvent(bg, 'mousemove', function(e)&#123; let x = e.offsetX - (bg.offsetWidth / 2) let y = bg.offsetHeight / 2 - e.offsetY bg.style['-webkit-transform'] = `rotateY($&#123;x / 100&#125;deg) rotateX($&#123;y / 100&#125;deg)` bg.style.transform = `rotateY($&#123;x / 100&#125;deg) rotateX($&#123;y / 100&#125;deg)`&#125;)bindEvent(bg, 'mouseout', function(e)&#123; bg.style['-webkit-transform'] = `rotateY(0deg) rotateX(0deg)` bg.style.transform = `rotateY(0deg) rotateX(0deg)`&#125;) &lt;/script&gt; 扒好后发现动画很卡，一开始我还以为是demo的服务器比较差带不动动画，可在本地运行也贼卡。 于是去找原因：最终发现问题出在transition: all .3s这个css属性。transition是过渡属性，这句话的含义是所有的变换(位子，宽高，透明度，旋转等等)在0.3秒内过渡完成。可是我们js实现的时候是实时根据鼠标位置修改rotate的角度的，而且鼠标移动触发的频率贼高。每次都使用0.3秒过渡，就导致每次动画过渡还没执行结束又开始新的动画。所以导致卡顿。 解决方法就是把它改成0秒或直接删除这个属性就OK了 小技巧：添加CSS3样式-webkit-transform:transition3d(0,0,0)或-webkit-transform:translateZ(0);，这两个属性都会开启GPU硬件加速模式","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"自动上传博客图片至新浪微博相册之Headless版","slug":"自动上传博客图片至新浪微博相册之Headless版","date":"2018-04-14T11:37:44.000Z","updated":"2018-08-11T15:24:47.282Z","comments":true,"path":"2018/04/14/自动上传博客图片至新浪微博相册之Headless版/","link":"","permalink":"https://www.hojun.cn/2018/04/14/自动上传博客图片至新浪微博相册之Headless版/","excerpt":"","text":"之前实现了一波Python+selenium自动上传博客图片至新浪微博相册，每次都会自动打开浏览器，再巴拉巴拉一波操作。后来在爬取网页动态页面的时候发现可以使用浏览器自带的headless(无头)模式，可以实现浏览器在后台巴拉巴拉一波操作，桌面上不显示。使用起来更加方便。直接使用chrome自带的headless的时候，一样的代码却老出问题，估计是chrome的bug，于是弃坑使用的Firefox浏览器。首先需要安装Firefox的webdriver下载地址。接下来直接改代码就OK~注意executable_path就是你的geckodriver的安装路径代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import osimport timefrom selenium import webdriverfrom selenium.webdriver.firefox.options import Options# from selenium.webdriver.chrome.options import Optionsclass Connect(): def __init__(self): self.UserName = '你的账号' self.PassWord = '你的密码' self.URL = 'https://weibo.com/login.php?url=http://photo.weibo.com/5673857615/albums' def upload(self): firefox_options = Options() firefox_options.add_argument('--headless') self.driver = webdriver.Firefox(firefox_options=firefox_options, executable_path='E:\\python\\webdriver\\geckodriver.exe') # self.driver = webdriver.Chrome(chrome_options=chrome_options, executable_path='C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe') self.driver.get(self.URL) self.driver.find_element_by_xpath('//*[@id=\"loginname\"]').send_keys(self.UserName) self.driver.find_element_by_xpath('//*[@id=\"pl_login_form\"]/div/div[3]/div[2]/div/input').send_keys(self.PassWord) self.driver.find_element_by_xpath('//*[@id=\"pl_login_form\"]/div/div[3]/div[6]/a').click() time.sleep(6) self.driver.find_element_by_xpath('//*[@id=\"user_info\"]/div/a').click() time.sleep(4) self.driver.find_element_by_xpath('//*[@id=\"flash_upload\"]/p/a').click() fr = open(\"E:\\python\\pySinaAutoUpload\\imgsPath.txt\", \"r\") content = fr.readlines() for index,val in enumerate(content): imgPath = val.strip() #去掉每行头尾空白 time.sleep(4) i = index + 1 if i == 1: self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/ul/li/form/input').send_keys(imgPath) time.sleep(4) self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/ul/li/form/a').click() else: self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/ul/li[' + str(i) + ']/form/input').send_keys(imgPath) time.sleep(4) self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/ul/li[' + str(i) + ']/form/a').click() # 关闭文件 fr.close() time.sleep(6) self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/div/a').click() time.sleep(4) self.driver.find_element_by_xpath('//*[@id=\"uploadPanel\"]/div[2]/div[4]/a').click() time.sleep(4) count = len(content); fw = open(\"E:\\python\\pySinaAutoUpload\\imgsUrl.txt\", \"w\") for j in range(count): imgsUrl = self.driver.execute_script('return document.getElementsByClassName(\"m_photoItem m_photoItem_a\")[' + str(j) + '].getElementsByTagName(\"img\")[0].src') time.sleep(4) imgsUrl = imgsUrl.replace(\"small\", \"large\") imgsUrl = '![](' + imgsUrl + ')' fw.write(imgsUrl + '\\n') fw.flush() fw.close()Connect().upload()","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hojun.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"逗比日记","slug":"逗比日记","date":"2018-04-13T15:47:40.000Z","updated":"2018-08-11T15:24:47.825Z","comments":true,"path":"2018/04/13/逗比日记/","link":"","permalink":"https://www.hojun.cn/2018/04/13/逗比日记/","excerpt":"","text":"说起来你可能不信。。。我的两只耳朵都受伤了","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"},{"name":"日记","slug":"日记","permalink":"https://www.hojun.cn/tags/日记/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"python模拟登陆入门教程","slug":"python模拟登陆入门教程","date":"2018-04-11T17:25:19.000Z","updated":"2018-08-11T15:24:49.526Z","comments":true,"path":"2018/04/12/python模拟登陆入门教程/","link":"","permalink":"https://www.hojun.cn/2018/04/12/python模拟登陆入门教程/","excerpt":"","text":"找了一个不带验证码登陆的简单网站（图床001网）做python的模拟登陆入门教程： 第一步首先打开浏览器，按F12打开开发人员工具 ，切换到network,勾选Preserve log和Disable cache。切换Application，右键clear网站cookie。然后人工登录一遍 第二步分析每个步骤,可以得出2点重要信息 在访问首页还未登录的时候，服务器就给我们传递了一个名为PHPSESSIONID的cookie。（后台99%是php开发的）。 在登录表单中含有一个隐藏域，名为auth_token，在登录的时候需要post过去 第三步知道这两点注意事项就可以开始撸代码了: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# coding=utf-8from urllib import requestfrom urllib import errorfrom urllib import parsefrom http import cookiejarimport sslimport retry: _create_unverified_https_context = ssl._create_unverified_contextexcept AttributeError: # Legacy Python that doesn't verify HTTPS certificates by default passelse: # Handle target environment that doesn't support HTTPS verification ssl._create_default_https_context = _create_unverified_https_contextif __name__ == '__main__': try: #首页地址 index_url = 'https://www.tuchuang001.com/' #User-Agent信息 user_agent = r'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36' #Headers信息 head = &#123;'User-Agnet': user_agent, 'Connection': 'keep-alive'&#125; #声明一个CookieJar对象实例来保存cookie cookie = cookiejar.CookieJar() #利用urllib.request库的HTTPCookieProcessor对象来创建cookie处理器,也就CookieHandler cookie_support = request.HTTPCookieProcessor(cookie) #通过CookieHandler创建opener 此opener中所有通信的cookie都会在cj对象中记录。这个cookie是没有域限制的，也就是全局cookie opener = request.build_opener(cookie_support) #创建Request对象 req1 = request.Request(url=index_url, headers=head) #使用自己创建的opener的open方法 response1 = opener.open(req1) html = response1.read().decode('utf-8') # 匹配auth_token reg = r'name=\"auth_token\" value=\"(.*?)\"' auth_token = re.compile(reg) auth_token = re.findall(auth_token, html) #登陆地址 login_url = 'https://www.tuchuang001.com/login' #登陆Form_Data信息 Login_Data = &#123;&#125; Login_Data['auth_token'] = auth_token[0] Login_Data['login-subject'] = '你的账号' Login_Data['password'] = '你的密码' #使用urlencode方法转换标准格式 loginPostData = parse.urlencode(Login_Data).encode('utf-8') req2 = request.Request(url=login_url, data=loginPostData, headers=head) response2 = opener.open(req2) html2 = response2.read().decode('utf-8') # 匹配用户名 reg = r'&lt;span class=\"text phone-hide\"&gt;(.*?)&lt;/span&gt;' userName = re.compile(reg) userName = re.findall(userName, html2) print(userName) except error.URLError as e: if hasattr(e, 'code'): print(\"HTTPError:%d\" % e.code) elif hasattr(e, 'reason'): print(\"URLError:%s\" % e.reason) 看注释基本能看懂代码了，我这里就不再讲解","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hojun.cn/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://www.hojun.cn/tags/爬虫/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"图片种子制作原来这么简单—老司机快上车","slug":"图片种子制作原来这么简单—老司机快上车","date":"2018-04-10T16:32:37.000Z","updated":"2018-08-11T15:24:45.604Z","comments":true,"path":"2018/04/11/图片种子制作原来这么简单—老司机快上车/","link":"","permalink":"https://www.hojun.cn/2018/04/11/图片种子制作原来这么简单—老司机快上车/","excerpt":"","text":"司机们是不是在某吧或一些论坛里看到其他人提供的图片种子？只要把图片保存下来，重命名成压缩文件格式（rar或zip），然后解压缩，就能得到隐藏在其中的种子文件。那么图片种子是怎么制作的呢？其实很简单：第一步先准备一张图片和一份txt文件（相当于种子文件）然后把txt文件压缩成zip或rar接下来win+r打开运行对话框，输入cmd打开windows命令行程序cd到保存图片的文件夹下（dir命令查看目录文件）最后运行命令copy /b girl.jpg + 种子文件.zip 种子.jpg(/b参数表示二进制文件)其中种子.jpg这个图片就是图片种子了。我们试着把它重命名为rar格式，在用压缩工具打开：就能得到种子文件.txt现在就能把这种图片种子分享出去啦~","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"小技巧","slug":"小技巧","permalink":"https://www.hojun.cn/tags/小技巧/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"整理好过去, 重新出发! 《怦然心动的人生整理魔法》记","slug":"整理好过去，重新出发！《怦然心动的人生整理魔法》记","date":"2018-04-08T16:52:23.000Z","updated":"2018-08-11T15:24:46.248Z","comments":true,"path":"2018/04/09/整理好过去，重新出发！《怦然心动的人生整理魔法》记/","link":"","permalink":"https://www.hojun.cn/2018/04/09/整理好过去，重新出发！《怦然心动的人生整理魔法》记/","excerpt":"","text":"这本书无论是内容还是深度，都秒杀上一本《超级整理术》。超级类似于别人家的孩子，看似很有道理，但却像一些洗脑的演讲，振奋人心却不贴合实际。而怦然心动却是从简单的房屋整理折射出很多人生哲理。 下面是一些书中走心的美句（喜欢的读者强烈推荐去读这本书，文章的最后是收纳法图解（教你叠衣服）） 你替房子排毒，房子也会替你的身心灵排毒。 只留下令自己「怦然心动」的物品。 这本书要说的是「一旦收拾整齐，就绝对不会再乱的方法」。 但若用一句话来总结的话，就是因为这些人靠着整理家里，顺便「整理了自己的过去」，而且也从中明确地了解到人生中什么是必要、什么是不必要，什么该做、什么又该戒。 整理方法不需要艰涩的分类。整理时的必须作业就只有「丢东西」与「决定收纳 场所」这两项而已，重要的只有「要先‘丢东西’」这个顺序而已 整理要一次就结束。 正确地说，应该一次就把它做完。 只留下让你怦然心动的，其他统统「丢掉」！ 在丢东西前，先思考「理想的生活」 「您说少女的生活…….可以请教一下，具体来说是什么样的生活吗？」 我这么问S小姐，她想了一下后，如此回答：比如说，下班回到家之后，晚上睡觉之前地板上干干净净，视线范围内什么东西都没有，房间像饭店一样整洁。粉红色的床单，配上复古情调的白色柜灯。洗完澡后，点上精油。放着钢琴或者小提琴演奏的古典乐。边喝花草茶，边做瑜伽。在轻松舒服的心情下入眠。接下来要做的是思考「为什么你想要过这样的生活？」请回顾自己理想生活的形象，再重新思考一次。 为什么睡觉前会想要点上精油？为什么想要边听古典乐，边做瑜伽？ 「因为睡前想要放松……」「因为想靠瑜伽减肥……」 那么，为什么睡前想要放松呢？为什么想要减肥呢？对于自己说出的回答，请反复追问自己「为什么？」至少三次最好能多达五次。 「希望工作的疲惫不要延续到第二天……」「因为想要变瘦，变漂亮……」 碰触到的瞬间，是否感觉「怦然心动」？ ，如果整理是只考虑「丢东西」，就会变得不开心。因为整理时应该选择的，本来就不是「要丢掉的东西」，而是「要留下来的东西」。（丢掉的都是伤心的东西，留下的都是美好的东西） 「碰触时是否怦然心动？」 把东西一个一个拿在手里，留下令你心动的东西，丢掉不心动的东西。这样就是判断是最简单又正确的方法。 还是会觉得:「我懂是懂，但就是丢不下手啊！」这也是人之常情。实际上最困扰的问题，应该是「不觉得心动，但就是没办法丢掉」的东西吧？ 因此，对于「虽不心动，但就是没办法丢掉」的东西，请一一思考它们的任务。 然后你就会发现，出乎意料地，很多东西其实已经完成它们的任务了。唯有好好地面对物品为我们完成的任务，表示感谢然后放手，在物品与我们的关系中，才算是完成了「整理」的动作。 只是一定要遵守顺序。一开始是衣服，接下来是书籍、文件、小东西、最后才是纪念品。若按照这个顺序进行物品减量，就能以惊人地速度顺利进行整理。因为比较容易判断该留该丢、分类明确的物品开始整理，才会比较轻松。「直立」是收纳最基本的原则。 就让我来为各位介绍一个为了完美维持「吊挂收纳」的独门绝招。 那就是，把衣服按「往右上方」的排列方式来吊挂。请试着在纸上画一个往右上方走的箭头，和一个往右下方走的箭头。用手指在空中画线也可以。 有什么感觉吗？相信各位会感觉到，当箭头往右上方走时，胸部附近有~种微微心动的感觉。因为往右上方的线条会让人觉得舒服。把这个原理应用在衣柜的收纳上，就能随时把这种「心动的感觉」带进衣置里。 换句话说在面对衣柜时，左边要收纳重的，右边要收纳轻的衣物。具体来说，左边最好放衣长较长、质料较厚、颜色较深的衣服，然后愈往右就愈要收纳衣长较短、质料较轻、颜色较淡的衣物。 我再清楚地说一次：丝袜，绝对不可以绑起来。还有，袜子绝对不可以翻过来卷成一团。 被绑在一起，或是被翻过来卷成一团的袜子，却时时被撑开，松紧带的部分承受着压力，一直都处于紧绷的状态。结果，一直被撑开的袜口变得又松又垮，寿命一下子就缩短了不说，好不容易被穿上时，还得换来主人一句「啊！这松掉了啦！」的抱怨。 没错。透过用手触摸带着回忆的物品，才能与过去面对面。若是一直放在衣柜抽屉或纸箱里，不管过了多久，都还是会被过去的回忆所牵制，而这些东西或许就会在不知不觉之间变成现在的「包袱」。 所谓的整理，就是整理每一个过去。整理纪念品，也可说是为了人生重新出发、踏出下一步的「节庆整理的总结算」。 比起收藏回忆，不如爱惜现在的自己！ 透过与一件一件的物品面对面，整理告诉我们，重要的不是过去的回忆，而是经历了过往而存在于当下的自己。 我相信，空间的使用不该是为了过去的自己，而应该是为了将来的自己。 不堆叠，「直立收纳」才是王道！ 把东西直立起来，是为了避免堆叠，理由有二。首先，因为堆叠可以无止尽地使用空间。能够无止尽地把东西往上堆，就意味着即使东西无止尽地增加，你也不会发现。如果采直立收纳，东西一增加就会使用到收纳空间，总有一天会面临极限，如此一来就会发现：「啊！东西增加了啊！」 另外一个理由则是，被堆在下面的东西会很难受。把东西堆叠在上面，意味着下面的东西理所当然地会被压扁。就好像我们长时间拿着很重的行李时会感到吃不消一样，物品一直处于上面有东西压着的状态时，就会逐渐衰弱。 于是，下面的东西就愈来愈没有存在感。不知不觉中，你甚至会忘记自己拥有这样东西。实际上，衣服堆叠收纳时，愈是下面的衣服，拿起来穿的频率就会愈来愈低。在整理衣服时，有些衣服让你觉得「买的时候明明很喜欢，为什么不让人心动了呢……」，往往是因为长期被收纳在一大堆衣服底下的缘故。 这个道理同样适用于文件。堆叠文件时，下面的文件就顿时失去了存在感。于是很容易一不留神就忘了处理被压在下面的文件，或是不知不觉地往后拖延。 最常使用的收纳圣品，就是空的鞋盒。虽然我尝试遇各式各样的收纳商品，但说到免费就能取得的万用收纳道具，真的无人能出其右。 「浴室」和「厨房水槽」什么都不要放 正如S女士所言，「整理魔法」的效果之一,就是开始能对自己的判断有自信。 是「对过去的执着」？还是「对未来的不安」？ 「这个烹饪器具虽然今年不用，但或许有一天会用到啊……」 「啊！是前个男朋友送我的首饰，当时我们感情真好啊。」 但是 ,如果深入追究就会发现，无法丢东西的原因其实只有两个，那就是「对过去的执著」与「对未来的不安」。 为了能够及早掌握这种感觉，有一个秘诀，那就是回家时对屋子说声「我回来了」。 你拥有的物品，想帮助你更幸福 真正的人生，从「整理之后」开始 到目前为止，我写了那么多关于整理的事，但其实不整理房间也没什么关系。因为，不整理也不会死啊！ 实际上，这世上应该有很多人根本就不在乎自己到底会不会整理。但是，那种人应该连这本书都不会拿起来看吧！ 因为某种缘分而拿起这本书的你，(看到这篇文章也是吧)一定有相当强烈的意识，想要改变现状、想要重整人生、想要发光发热、想要改善现在的生活、想要变得更幸福。 我保证，这样的你绝对能够变成会整理的人。 当你想要整理，然后拿起这本书时，你已经踏出了第一步。如果你已经读到这里，相信你也已经明白自己接下来该做什么。 人无法重视、珍惜那么多的东西。像我就是个超怕麻烦又糊里糊涂的人，根本没办法好好爱护大量的物品。因此，我才想至少要能够珍惜对自己而言重要的东西，所以这一路以来都如此执着于整理一事。 不过，我觉得整理房屋最好要迅速完成，因为整理并不是人生的目的。「整理是每天都必须做的事，是一生都会跟随着我们的事。」请赶快从这样的想法中觉醒吧。我敢断言，整理是可以一口气在短时间内彻底完成的。 只要「判断该丢该留」，以及「珍惜决定留下的东西」，就能一次彻底地完成整理，一辈子都在自己心动的物品围绕下生活。 对整理怀抱高度热忱，像我一样真正对整理本身感到心动，想藉由整理改善这世界的人，才需要像这样一年到头都在思考整理的事，而且只要有极少数这样的人就够了。 请你把更多的时间和热忱，投注在「真正心动的事」上。或许，那也可以说是你的使命。 我想大声地告诉大家，整理非常有助于找出让你打从心底心动的使命。 所以，真正的人生在「整理之后」才开始。 文章的最后为什么要直立竖放短袖&amp;奇异服装的折叠方法质地柔软&amp;针织衫羊毛衫的折叠方法长袖衣的折叠方法连帽大衣&amp;吊带衫的折叠方法胸罩衫&amp;文胸的折叠方法大摆裙&amp;内裤的折叠方法裤子&amp;短裤的折叠方法丝袜&amp;袜子的折叠方法 抽屉壁橱厨房","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://www.hojun.cn/tags/悦读/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"《超级整理术》记","slug":"《超级整理术》记","date":"2018-04-05T06:59:06.000Z","updated":"2018-08-11T15:24:51.170Z","comments":true,"path":"2018/04/05/《超级整理术》记/","link":"","permalink":"https://www.hojun.cn/2018/04/05/《超级整理术》记/","excerpt":"","text":"写在前面：说实话，我看这本书的初衷是为了整理自己那乱的不行房间。可惜的是，整本书整理的范围仅限个人办公区域（关于工作）（很可能只是一张办公桌）。下面就是书中一些走心的句子（差不多就是整理了整本书个人觉得好的内容） 整理的目的是为了提高工作效率一句话，我整理不是为了环境整洁，而是为了提高工作效率。整理术还有一项原则就是:可干可不干的事就应尽可能地偷懒。（赞同~233333） 关于文件和办公桌的整理不要花时间去记”东西放在哪里了”我们应当记住的不是：”东西放哪儿”，而是”什么东西该放哪里”这一规则。而且这规则越简单越好，太复杂的话，容易把自己搞糊涂了。 学会扔东西吧判断该不该处理掉一份文件，有以下三条准则 : 是不是已办文件? 是不是重复的文件? 是不是今后不再用到的文件? 当无法判断文件今后是否还有用时，我推荐”暂且保留”。当然，大多数文件，我建议还是要么处理掉，要么保管起来。 用后归还原位很重要先准备下列几样工具吧 ①托盘 ②透明文件夹 ③口袋式的透明文件夹 ④小文件柜(或抽屉式的小信箱) ⑤大纸盒 文件分为”正在办理状态”和”保存状态” 文件一般可分为两类: 正在办理状态:与目前手头作有关的或是看过后决定保留的文件 已办、需保存状态:已处理完毕、但仍需要保存的文件，如合同、发票等。 关于”已办好、需保存”的文件，我也把它们大致分为三类: ①近期需要用到的 ②需要存放起来的 ③不知以后是否需要，暂且保存起来的 实在有大尺寸的资料，就把它复印成A4尺寸再保存吧。从杂志上剪下来的信息、或是写在小记事本上的内容，如果比A4小，我建议要么把它们输入电脑，要么用订书机订在A4纸上。（嗯，订的方法不错）我还建议，把大文件夹的颜色也统一起来吧。比如说，蓝色的用于存放”预算”类的，黑色的用于存放 “资料”类的， 把正在操作中的文件放进透明文件夹中给透明文件夹加上封面所谓封面，也就是夹进此文件夹最上面的那张纸，用WORD文档的固定格式打出来放进去就可以了。 把透明文件夹放进大文件夹时，如果数量不多，也就无所谓什么顺序如果数量比较多的话，为了免日后找起来麻烦，就需要进行适当的分类。比如说，有一种方法叫作”使用频度分类法“，此分类法很有名，野口悠纪雄先生的《超整理法》一书中也介绍过。其实做起来很简单。就是”凡取出一份文件，还原时都从左侧摆放”，其结果是，使用频率高的文件，都集中在左侧。 托盘的使用方法 重要的已办文件用大文件夹保管 (1) 放进大文件夹的替换用纸，我推荐使用一 些著名品牌的”半袋”系列 (2) 在大文件夹的侧面加上标签 使办公桌成为舒适的工作场所 常用的东西放在桌上 东西摆放在固定的位置 抽屉里摆放的东西也应有固定位置 有时可以不收拾。我认为，如果安全条件允许的话，最好不要收拾，就那样把东西摊在桌子上直接离开好了。因为第二天上班后，又要把昨天收拾好的文件一一取出来，这也是时间上的浪费。已读完的书，做好摘录。所谓摘录阅读法，就是带着目的去读一本书仅仅把书中对自己有用的信息挑选出来，一边读一边作笔记，算是一种比较高效的阅读方法吧。(哈哈，已经在这么做了)把有用的内容剪下来后杂志就可以扔了杂志也一样，把有用的信息保留下来后就可以丢掉了。自己觉得有价值的内容，最好输入到文档中保存在电脑里，实在舍不得丢掉的某些内容，就把它们剪下来保存吧。 关于电脑与电子邮件的整理设一个名为”工作”的文件夹，与工作有关的文件都存进去”工作”文件夹下按不同的公司和领域再设”大分类文件夹”③”大分类文件央”下再按照不同 的项目进一步设”小分类文件夹”文件的命名很重要给文件起名时要加上日期通过日期、内容、公司名都能搜索到文件夹只要大致分类就可以了，但为了便于搜索，文件名称还是要详细一些才好。最好制定一定的规则，所有文件都按此规则执行，这样比较便于管理。也有一些小诀窍，如为了能迅速知道哪份文件是最新的，最好在所有文件名称中加上日期，以及”项目名称”等关键词。有的人把文件名起得很短，看上去很简洁，但是一旦找起来就费时费力了二为了减少这种不必要的麻烦，还是把关键词放进文件名称中去吧。即使是客户发来的文件，最好也要重新命名，把时间和关键词都放进去，日后想要的时候就很容易搜索到了。 桌面要整理清爽电脑桌面上的文件夹数量最多不应起过 10 个，而且要放”大分类”型的文件夹，用快捷方式保存，总之按鼠标不超过三下就应该能找到想要的文件。 为正在办理的文件设一个文件夹放在桌面上 ①正在办理中的文件，按不同项目设文件夹，放在电脑桌面上。如果文件每次都能用快捷方式打开的话，有利于提高工作效率。 ②文件一旦处理完毕，就保存进已进行分类的文件夹里。 ③设一个名为”其他”的文件夹，把那些看上去不易分类的文件保存进去，日后有时间时再研究到底该如何分类 这个时代， IT 知识很重要把电脑当作自己的”外脑” 市场规律中有一条”20/80 法则”，就是说往往20% 的商品的销售额占总销售额的80%,20%的顾客购买了80%的商品。这条法则的深层含义就是:重要的东西往往只有那么一点点。对于信息来说，”20/80法则”依然适用。 邮件也用”超级整理术”迅速处理 争取把工作委托给他人将工作委托他人时的参考基准是”小时工资”【算一下自己的小时工资】年收入 500 万日元的人:500 万日元+ 240 夭(平均工作天数) +10(工作时间) =2083 日元因此 ，如果将这些工作花钱外包出去，自己就可以利用这段空闲时间从事重要的”思考类”工作，从长远角度来看，这无疑会产生更大的收益。譬如，可以利用这段时间来思考新的商务计划，也可以用来学习英语或用来准备各种资格考试，也可以将这段时间用来旅行。作为提高自身感性认识的投资。况且，如果花钱雇佣他人的话您便会产生这样一种感觉：这段空余时间是自己特意花钱才得到的，因此一定要好好利用才行! 我个人并不是很喜欢开会，因为我认为，在同一时间内许多人聚集在一起开会是一种浪费。（boss喜欢233333） 规则要彻底执行并持续遵守 如何才能彻底执行并持续遵守规则规则制定出来后，如何才能被长期遵守呢?我的做法是创建一种”让规则自己冒出来”的方法。我要提一个建议:尽量在自己喜欢的地方工作吧。 关于时间的整理以往的时间使用方法，我把工作分为”操作类”和”思考类”，我建议，(说的这么高大上，脑力活/体力活)”操作类”的工作应尽量集中在早晨完成;同时，将”操作类”工作中可以委托给他人的部分尽量委托给他人，可以由电脑完成的尽量用电脑完成。创意也要保存进TODO为了改善这种状况，托林浦公司引入了”能够努力工作的时间段“这一概念，规定”每天十二点半到十四点半两个小时内，禁止同事之间进行交谈，禁止员工在办公室内走动，也不准传达外部打来的电话”。这并不是要否定让员工愉快工作的重要性时让他们大声交谈也是很重要的。但我认为任何事情都应张弛有度，能够努力工作的时间段”这一概念就能很好地体现这个度。 与制定”能够努力工作的时间段”制度一样，我们公司还引入了”无加班日“制度。这个制度现在比较热门，引人这一制度的公司应该很多。（百度了一下 仅搜索到一篇文章 ————“日本企业“无加班日”为何形同虚设？”笑哭） 不要把工作日与休息日分开考虑我们的一生中工作时间与私人时间几乎各占一半，无论哪方面都很重要。我觉得，没有必要硬是将两者分开来考虑，因为这样的话，临近周末我们会变得很开心，而到了周一又会变得意志消沉如此一来，我们的工作状态也会发生波动。 估计有不少人因为时间不够用而会发出这样的感慨:如果再有点时间就好了!但是，除非您认真思考过”如果有了可支配的时间，我将去做什么”这个问题，否则，就算有了自由时间也不知道该做什么的大有人在。（赞同）所以说，关键是要确立目标，明确自己想要做什么。然后再考虑该怎样挤出时间，做自己想做的事情。（到最后了，boss跟你谈理想了233333~前提是boss鼓励员工做自己的事。《黑客与画家》的作者是这么做的）（本书作者是好几个公司的boss） 后记：在豆瓣看书评的时候又发现一半《怦然心动的人生整理魔法》————233333~这本书是教你整理房子的了。下期再会~","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://www.hojun.cn/tags/悦读/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"python+Chrome爬取动态异步生成的页面内容","slug":"python-Chrome爬取动态异步生成的页面内容","date":"2018-04-04T11:41:20.000Z","updated":"2018-08-11T15:24:49.337Z","comments":true,"path":"2018/04/04/python-Chrome爬取动态异步生成的页面内容/","link":"","permalink":"https://www.hojun.cn/2018/04/04/python-Chrome爬取动态异步生成的页面内容/","excerpt":"","text":"背景需求，发送一个中文，返回拼音+声调。 解决之道一百度一下 “汉字转拼音api”，是否有相关免费的api，还真的找到个“showapi易源接口”。可惜它不带声调。百度一下“python汉字转拼音+声调”，找到一篇“Python: 汉字转拼音（带声调）”的文章。哈哈，按照功能实现需求了。咳咳，有些跑题。为了贴近标题，提供解决之道二。 解决之道二百度一下某个汉字，比如“我”，打开百度汉字，如图：发现会有很多资源，拼音、部首、笔画、五行、基本释义等等。准备用python爬。直接用urllib.request爬取，发现得到的刚好没有这些资源，怎么回事？在浏览器下发现有这么一串js1&lt;script&gt;window.basicInfo = &#123;\"name\":\"\\u6211\",\"type\":\"wo、rd\",\"radical\":null,\"strokes\":\"7\",\"definition\":\"w\\u01d2#wo3#\\u81ea\\u79f0\\uff0c\\u81ea\\u5df1\\uff0c\\u4ea6\\u6307\\u81ea\\u5df1\\u4e00\\u65b9\\uff1a\\uff5e\\u4eec\\u3002\\uff5e\\u89c1\\uff08\\u6211\\u81ea\\u5df1\\u7684\\u770b\\u6cd5\\uff09\\u3002\\uff5e\\u8f88\\u3002\\uff5e\\u4faa\\uff08\\u6211\\u4eec\\uff09\\u3002\\u81ea\\uff5e\\u3002\\uff5e\\u76c8\\u5f7c\\u7aed\\u3002\"&#125;;&lt;/script&gt; 将unicode转中文后得到： 1name&quot;:&quot;我&quot;,&quot;type&quot;:&quot;word&quot;,&quot;radical&quot;:null,&quot;strokes&quot;:&quot;7&quot;,&quot;definition&quot;:&quot;wǒ#wo3#自称，自己，亦指自己一方：～们。～见（我自己的看法）。～辈。～侪（我们）。自～。～盈彼竭。&quot; 说明对应的这些内容是由js动态生成的。 我们需要能爬到动态的内容，可以使用selenium+chrome得到。 为什么不用PhantomJS？ 一、PhantomJS暂停开发 二、新版本的Selenium不再支持PhantomJS 我们可以用chrome的headless模式，当然对chrome有要求，版本需要&gt;=60（windows）&gt;=59(linux)。还需要对应的chromeDriverchromeDriver要求和配置可以参照我的另一篇文章《Python+selenium自动上传博客图片至新浪微博相册》 上代码~123456789from selenium import webdriverfrom selenium.webdriver.chrome.options import Optionschrome_options = Options()chrome_options.add_argument('--headless')chrome_options.add_argument('--disable-gpu')driver = webdriver.Chrome(chrome_options=chrome_options, executable_path='C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe')driver.get(\"http://hanyu.baidu.com/s?wd=%E4%BD%A0&amp;from=zici\")print(driver.page_source) duang~duang~duang~就这么成功爬取到了js动态生成的内容","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hojun.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"python+wget轻松爬取MP3音乐文件","slug":"python-wget轻松爬取MP3音乐文件","date":"2018-04-03T12:10:28.000Z","updated":"2018-08-11T15:24:49.415Z","comments":true,"path":"2018/04/03/python-wget轻松爬取MP3音乐文件/","link":"","permalink":"https://www.hojun.cn/2018/04/03/python-wget轻松爬取MP3音乐文件/","excerpt":"","text":"在搞拼音学习的时候，需要对应的文字的读音。发现XX汉语上面有需要的MP3文件。如图，红框框起来的就是MP3的url地址。分析一下url，我们大致已经能得出“你”字的MP3文件对应名称为 ni3.mp3。在地址栏输入ni3.mp3，结果证实了我们的猜测。接下来就是怎么下载资源了，糟糕的是需要读音挺多，如果你手动一个一个下载，工作量非常大！人生苦短，我用python。哈哈当然这不是主要原因，由于python胶水语言成就了他在爬虫领域的爸爸地位。再加上wget,就可以轻松实现下载。python安装自行百度，这里重点讲下wget安装。首先，不要使用免安装或绿色版的，绿色版会少功能，相当于阉割版，免安装少dll文件，自己去找更烦。推荐使用wget-1.11.4安装版（及Setup）。安装完成后在环境变量中Path配置wget路径，到bin目录。如：D:\\Program Files (x86)\\GnuWin32\\bin准备工作做好了，接下来就是准备python代码：123456789#coding=utf-8from urllib import request, parseimport subprocessimport osname = 'wo3.mp3'url = 'https://appcdn.fanyi.baidu.com/zhdict/mp3/' + name;path = 'mp3/' + namecmd='wget --no-check-certificate -O %s %s ' % (path, url)subprocess.call(cmd,shell=True) 代码解释：subprocess 用来生成子进程，并可以通过管道连接他们的输入/输出/错误，以及获得他们的返回值。call执行命令，返回状态码，shell=True允许shell命令时字符串形式wget –no-check-certificate 不检查证书选项，多用于下载https的资源-O /home/index http://www.baidu.com 将下载的文件存放到指定的文件夹下，同时重命名下载的文件， 当然这里的代码只是简单的测试，接下来自要运行python脚本就可以下载到MP3文件。附：若是你想下载github上的资源，需要release版的","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hojun.cn/tags/python/"},{"name":"wget","slug":"wget","permalink":"https://www.hojun.cn/tags/wget/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"python备份hexo博客图片","slug":"python备份hexo博客图片","date":"2018-03-29T14:27:19.000Z","updated":"2018-08-11T15:24:49.449Z","comments":true,"path":"2018/03/29/python备份hexo博客图片/","link":"","permalink":"https://www.hojun.cn/2018/03/29/python备份hexo博客图片/","excerpt":"","text":"使用hexo搭建博客的小伙伴们，你们的博客图片资源存放在哪里呢？有的直接存在博客网站中(github,coding或自己的服务器)；有的存在云存储上；有的存在不知名的第三方图床上等等。这些方案存在以下问题：放github上访问速度太卡，云存储要收费，免费的怕运营不了多长时间。图床，容易GG。慎重提醒大家：不要保存在不知名的第三方图床上。一开始作者就是存在第三方图床，后来图床停止服务了，导致博客图片全GG,花了一整夜从新上传图片。接着我使用了某浪微博相册来保存图片（自动上传图片请参考我另一篇文章），然而一朝被蛇咬，十年怕井绳。万一某浪也GG不玩了或图片禁止外部访问了。那博客图片不是又炸了。于是一直想备份图片到自己本地，机缘巧合看见某大神已经用python实现过这个功能（github.com/wangshub/markdown-img-backup玩跳一跳的程序员也许会眼熟）。身为一个python新手，秉着大无畏精神，勇于和bug相爱相杀，clone了代码，因为电脑上是py3版本的环境，略微修改了py3版本的代码，使用过程中顺带修复了一个正则贪婪匹配的bug。详见作者的debug分支github.com/honjun/markdown-img-backup/tree/debug。 使用说明：第一步：在代码中修改你的markdown文件路径第二步：在py脚本的同路径下建立“img”文件夹保存图片，或修改保存图片路径的代码第三步：cmd运行脚本 python md_image_backup_py3.py参数说明： 不传默认备份所有 md文件名（仅备份该文件）","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"},{"name":"python","slug":"python","permalink":"https://www.hojun.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"《不能承受的生命之轻》记","slug":"《不能承受的生命之轻》记","date":"2018-03-28T15:53:09.000Z","updated":"2018-08-11T15:24:50.682Z","comments":true,"path":"2018/03/28/《不能承受的生命之轻》记/","link":"","permalink":"https://www.hojun.cn/2018/03/28/《不能承受的生命之轻》记/","excerpt":"","text":"这本书，说实在的，我没看懂。或许是自身还不够成熟，或许是还有太多事情没有经历过，不能切身体会。其中唯一有点同感的就是“es muss sein”非此不可。但是每个人都有“es muss sein”之外的生活，很多时候的非此不可也许只是你自己给自己立下的flag，过去之后也就没啥非此不可了。还有允许我吐槽下托马斯那无语的交际关系······以及特蕾莎那扭曲的爱。（一个弱者，渴望强者变弱变老，而不是自己变强） 还是收录了一些走心句子：es muss sein //非此不可一个不断要求“出人头地”的人，应该料到总有一天会感到发晕。发晕是怎么回事？是害怕摔下去？但是，站在有结实的护栏的平台，我们怎么还发晕呢？发晕，并非害怕摔下来，而是另一回事。是我们身下那片空虚里发出的声音，它在引诱我们，迷惑我们；是往下跳的渴望，我们往往为之而后怕，拼命去抗拒这种渴望。正因为弱才应该知道要强，才应该在强者也弱得不能伤害弱者的时刻离开。生命中有太多事，看似轻如鸿毛，却让人难以承受。","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://www.hojun.cn/tags/悦读/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"《黑客与画家》读后感：你对技术一无所知","slug":"《黑客与画家》读后感：你对技术一无所知","date":"2018-03-27T14:31:52.000Z","updated":"2018-08-11T15:24:51.204Z","comments":true,"path":"2018/03/27/《黑客与画家》读后感：你对技术一无所知/","link":"","permalink":"https://www.hojun.cn/2018/03/27/《黑客与画家》读后感：你对技术一无所知/","excerpt":"","text":"年后那段时间在群里看见有人在有聊《黑客与画家》这本书。正好上本书看完，直接入手看。阮一峰老师翻译的。整本书读下来有料有趣，感受到作者本人的真实、接地气、走心的文字。黑客兼画家的作者在————《设计者的品位》这章对好设计的总结很棒！然后作者本人也没逃掉“XXX语言，是世界上最好的语言！”这个梗(笑~)以下此书当中整理出来的比较走心的句子： 为什么书呆子不受欢迎，他们的心思在别的地方。要是不受欢迎，仅仅意味着不受到关注。书呆子们可能觉得还能忍受，不幸的是在学校里不受欢迎，等同于被歧视被欺负。为什么会被歧视和欺负？所以现在还在学校里读书的人可能会又一次觉得怎么会有人问出这么蠢的问题。怎么可能会有其他结果呢？当然会有其他结果，一般来说，成年人就不会去欺负书呆子。为什么小孩子会这样做呢？一部分原因是青少年在心理上还没有摆脱儿童状态，许多人都会残忍的对待他人，他们折磨书呆子的原因就像拔掉一条蜘蛛腿一样，觉得好玩。在一个人产生良知之前，折磨是一种娱乐。孩子们欺负书呆子的另一个原因是为了让自己感到好受一些，同样在任何社会等级制度中。那些对自己没自信的人，就会通过虐待他们眼中的下等人来突显自己的身份。孩子们欺负书呆子的主要原因也与追求受欢迎的心理有关，怎样才能让自己更受欢迎？个人魅力是很小的一方面，你应该更多地考虑如何结盟。秘诀就是不停的设法使自己与其它受欢迎的人变得关系更密切，没有什么比一个共同的敌人，更能使人们团结起来了。这就好比一个政客，他想让选民忘记糟糕的国内局势，方法就是为国家找出一个敌人，哪怕敌人并不真的存在，他也可以创造一个出来。 不能说的话，守口如瓶，但永远质疑。良好的坏习惯，即适当的不服从管教黑客与画家黑客这个词不仅是一流能力的象征，还包含着求解问题过程中 产生的精神愉悦或享受。也就是说，从一开始黑客就是有精神追求的，自由软件基金会创始人理查德·斯托尔曼说：出于兴趣而而解决某个难题，不管它有没有用？这就是黑客。根据理查德·斯托尔曼的说法，黑客行为必须包含三个特点：好玩、高智商、探索精神，只有其行为同时满足这三个标准才能被称为黑客。另一方面他们也构成了黑客的价值观，黑客追求的就是这三种价值，而不是实用性或金钱。黑客如何才能做自己喜欢的事情，我认为这个问题的解决方法是一个几乎所有创作者都知道的方法找一份养家糊口的白天工作。这个词是从音乐家身上来的，他们晚上表演音乐，所以白天可以找一份其他工作，更一般的说，白天工作的意思是你有一份为了赚钱的工作，还有一份为了爱好的工作。因为如果你不爱一件事，你不可能把他做的真正优秀，要是你很热爱编程，你就不可避免的会开发你自己的项目。 设计者的品位哥白尼不认同托勒密的体系一个极其重要的原因是他觉得特罗密提出的偏心等距点毫无美感 ————托马斯库恩《哥白尼革命》我们所有人都受到凯丽·利约翰逊的影响，狂热的相信外观优美的飞机，一定会飞的同样漂亮。 ——————本·李奇《臭鼬计划》美感是第一道关卡，丑陋的数学在世界上无法生存。 ——————G·H·哈代《一个数学家的道歉》 好的设计是简单的设计当你被迫把东西做得简单时，你就被迫直接面对真正的问题，当你不能把表面的装饰交差时，你就不得不做好真正的本质部分。 好设计师解决主要问题的设计许多坏设计做的很辛苦，但是从一开始方向就错了。答案可以不断改进，同样问题，本身也可以不断改进。 好设计是永不过时的设计如果解决方法是丑陋的，那就肯定还有更好的解决方法，只是还没有发现而已。 好设计师启发性的设计英国女作家简奥斯汀的作品，几乎不带有任何描述，他不告诉读者每件东西看上去是什么样子？只是把故事讲得非常生动，让读者自己把一切想象出来。同样绘画作品也分为描述性废话和启发性会或者玩玩比前者更引人入胜每个人看到蒙娜丽莎都有自己的理解。 好设计通常是有点趣味性的设计我想这是因为幽默一定程度上反映了力量。幽默感是强壮的一种表现，始终拥有幽默感就代表了你对厄运一笑了之，而丧失幽默感，则表示你被厄运深深伤到。所以强壮的标志（或者至少是特点）就是轻松面对自己的人生，充满自信的人，常常像燕子一样以一种居高临下的姿态轻盈地看待周围的一切。好的设计并非一定要有趣，但是很难想象，完全无趣的设计怎么会是好的设计？ 好设计师艰苦的设计如果观察那些做出伟大作品的人，你会发现他们的共同点就是工作得非常艰苦，如果你工作的不艰苦，你可能正在浪费时间。好 好设计是看似容易的设计优秀运动员比赛时，让人觉得他轻轻松松就获胜了。优秀设计师也是如此，他们的工作看上去很容易。大多数时候，这是一种错觉。作家的文章读起来流畅自如，但是背后其实经过了反复修改。 好设计是对称的设计对称，也许只是间接性的一种表现，但是它十分重要，值得单独列为一点.自然界的对称大量存在，这就说明了对称的重要性。 好设计是模仿大自然的设计我不是说模仿大自然这种行为本身有多么好，不是说大自然在长期的演化中已经解决了很多设计问题，所以如果你的设计与大自然很接近，那么它基本上不会很差。 好设计是一种再设计很少有人一次就把事情做对，专家的做法是先完成一个早期原型，然后提出修改计划，最后把早期原型扔掉。 好设计是能够复制的设计我们对待复制的态度经常是一个否定之否定的过程，刚入门的新手，不知不觉地模仿他人逐渐熟悉之后才开始创作原创性作品，最后才会意识到把事情做对比原创更重要。等到你逐渐对一件事产生热情的时候，就不会满足于模仿了，你的品位就进入第二阶段开始自觉地进行原创。 好设计常常是奇特的设计某些最出色的作品，堪称不可思议， 好设计是成批出现的好设计常常是大胆的设计在任何一段历史中，人们都会把某些荒诞的东西当做正确，并且深信不疑，以至于一到你出言质疑就被排挤或者被暴力伤害的危险。只有在成为某个领域的专家之后，你才会听到心里有一种细微的声音，说这样解决太糟糕了，有更好的选择，不要忽视这种声音，要培育他们。优秀作品的秘诀是非常严格的品味，再加上实现这种品味的能力。 还有就是吐槽管理层（书呆子的复仇：两种很常见，但很难结合在一起的特点。对技术一无所知，对技术有强烈的个人观点）以及Lisp大法好（梦寐以求的编程语言）","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"悦读","slug":"悦读","permalink":"https://www.hojun.cn/tags/悦读/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"ES6之Promise","slug":"ES6之Promise","date":"2018-03-26T12:39:36.000Z","updated":"2018-08-11T15:24:48.293Z","comments":true,"path":"2018/03/26/ES6之Promise/","link":"","permalink":"https://www.hojun.cn/2018/03/26/ES6之Promise/","excerpt":"","text":"Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及其返回的值。 语法1new Promise( function(resolve, reject) &#123;...&#125; /* executor */ ); 参数executorexecutor是带有 resolve 和 reject 两个参数的函数 。Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回新建对象前被调用）。resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled，或者在发生错误时将它的状态改为rejected。如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略 描述Promise 对象是一个代理对象（代理一个值），被代理的值在Promise对象创建时可能是未知的。它允许你为异步操作的成功和失败分别绑定相应的处理方法（handlers）。 这让异步方法可以像同步方法那样返回值，但并不是立即返回最终执行结果，而是一个能代表未来出现的结果的promise对象一个 Promise有以下几种状态: pending: 初始状态，既不是成功，也不是失败状态。 fulfilled: 意味着操作成功完成。 rejected: 意味着操作失败。 pending 状态的 Promise 对象可能触发fulfilled 状态并传递一个值给相应的状态处理方法，也可能触发失败状态（rejected）并传递失败信息。当其中任一种情况出现时，Promise 对象的 then 方法绑定的处理方法（handlers ）就会被调用（then方法包含两个参数：onfulfilled 和 onrejected，它们都是 Function 类型。当Promise状态为fulfilled时，调用 then 的 onfulfilled 方法，当Promise状态为rejected时，调用 then 的 onrejected 方法， 所以在异步操作的完成和绑定处理方法之间不存在竞争）。 因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回promise 对象， 所以它们可以被链式调用。 属性Promise.lengthlength属性，其值总是为 1 (构造器参数的数目).Promise.prototype表示 Promise 构造器的原型. 方法Promise.all(iterable)这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。（可以参考jQuery.when方法—译者注）Promise.race(iterable)当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。Promise.reject(reason)返回一个状态为失败的Promise对象，并将给定的失败信息传递给对应的处理方法Promise.resolve(value)返回一个状态由给定value决定的Promise对象。如果该值是一个Promise对象，则直接返回该对象；如果该值是thenable(即，带有then方法的对象)，返回的Promise对象的最终状态由then方法执行决定；否则的话(该value为空，基本类型或者不带then方法的对象),返回的Promise对象状态为fulfilled，并且将该value传递给对应的then方法。通常而言，如果你不知道一个值是否是Promise对象，使用Promise.resolve(value) 来返回一个Promise对象,这样就能将该value以Promise对象形式使用。 Promise 原型属性Promise.prototype.constructor返回被创建的实例函数. 默认为 Promise 函数. 方法Promise.prototype.catch(onRejected)添加一个拒绝(rejection) 回调到当前 promise, 返回一个新的promise。当这个回调函数被调用，新 promise 将以它的返回值来resolve，否则如果当前promise 进入fulfilled状态，则以当前promise的完成结果作为新promise的完成结果.Promise.prototype.then(onFulfilled, onRejected)添加解决(fulfillment)和拒绝(rejection)回调到当前 promise, 返回一个新的 promise, 将以回调的返回值来resolve.Promise.prototype.finally(onFinally)添加一个事件处理回调于当前promise对象，并且在原promise对象解析完毕后，返回一个新的promise对象。回调会在当前promise运行完毕后被调用，无论当前promise的状态是完成(fulfilled)还是失败(rejected) 创建PromisePromise 对象是由关键字 new 及其构造函数来创建的。该构造函数会?把一个叫做“处理器函数”（executor function）的函数作为它的参数。这个“处理器函数”接受两个函数——resolve 和 reject ——作为其参数。当异步任务顺利完成且返回结果值时，会调用 resolve 函数；而当异步任务失败且返回失败原因（通常是一个错误对象）时，会调用reject 函数。1234567const myFirstPromise = new Promise((resolve, reject) =&gt; &#123; // ?做一些异步操作，最终会调用下面两者之一: // // resolve(someValue); // fulfilled // ?或 // reject(\"failure reason\"); // rejected&#125;); 想要某个函数?拥有promise功能，只需让其返回一个promise即可。123456789function myAsyncFunction(url) &#123; return new Promise((resolve, reject) =&gt; &#123; const xhr = new XMLHttpRequest(); xhr.open(\"GET\", url); xhr.onload = () =&gt; resolve(xhr.responseText); xhr.onerror = () =&gt; reject(xhr.statusText); xhr.send(); &#125;);&#125;; 示例非常简单的例子12345678910111213?let myFirstPromise = new Promise(function(resolve, reject)&#123; //当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...) //在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法. setTimeout(function()&#123; resolve(\"成功!\"); //代码正常执行！ &#125;, 250);&#125;);myFirstPromise.then(function(successMessage)&#123; //successMessage的值是上面调用resolve(...)方法传入的值. //successMessage参数不一定非要是字符串类型，这里只是举个例子 console.log(\"Yay! \" + successMessage);&#125;); 高级一点的例子本例展示了 Promise 的一些机制。 testPromise() 方法在每次点击 &lt;button&gt; 按钮时被调用，该方法会创建一个promise 对象，使用 window.setTimeout() 让Promise等待 1-3 秒不等的时间来填充数据（通过Math.random()方法）。 Promise 的值的填充过程都被日志记录（logged）下来，这些日志信息展示了方法中的同步代码和异步代码是如何通过Promise完成解耦的。 12345678910111213141516171819202122232425262728293031323334353637383940'use strict';var promiseCount = 0;function testPromise() &#123; let thisPromiseCount = ++promiseCount; let log = document.getElementById('log'); log.insertAdjacentHTML('beforeend', thisPromiseCount +') 开始 (&lt;small&gt;同步代码开始&lt;/small&gt;)&lt;br/&gt;'); // 新构建一个 Promise 实例：使用Promise实现每过一段时间给计数器加一的过程，每段时间间隔为1~3秒不等 let p1 = new Promise( // resolver 函数在 Promise 成功或失败时都可能被调用 (resolve, reject) =&gt; &#123; log.insertAdjacentHTML('beforeend', thisPromiseCount + ') Promise 开始 (&lt;small&gt;异步代码开始&lt;/small&gt;)&lt;br/&gt;'); // 创建一个异步调用 window.setTimeout( function() &#123; // 填充 Promise resolve(thisPromiseCount); &#125;, Math.random() * 2000 + 1000); &#125; ); // Promise 不论成功或失败都会调用 then // catch() 只有当 promise 失败时才会调用 p1.then( // 记录填充值 function(val) &#123; log.insertAdjacentHTML('beforeend', val + ') Promise 已填充完毕 (&lt;small&gt;异步代码结束&lt;/small&gt;)&lt;br/&gt;'); &#125;) .catch( // 记录失败原因 (reason) =&gt; &#123; console.log('处理失败的 promise ('+reason+')'); &#125;); log.insertAdjacentHTML('beforeend', thisPromiseCount +') Promise made (&lt;small&gt;Sync code terminated&lt;/small&gt;)&lt;br/&gt;');&#125; 常用栗子Promise链式调用在过去，做多重的异步操作，会导致经典的回调地狱，我们把回调附加到被返回的promise上代替以往的做法，形成一个promise 链：1234567891011121314151617181920// 回调地狱doSomething(function(result) &#123; doSomethingElse(result, function(newResult) &#123; doThirdThing(newResult, function(finalResult) &#123; console.log('Got the final result: ' + finalResult); &#125;, failureCallback); &#125;, failureCallback);&#125;, failureCallback);//采用Promise链式调用之后doSomething().then(function(result) &#123; return doSomethingElse(result);&#125;).then(function(newResult) &#123; return doThirdThing(newResult);&#125;).then(function(finalResult) &#123; console.log('Got the final result: ' + finalResult);&#125;).catch(failureCallback); then里的参数是可选的，catch(failureCallback) 是 then(null, failureCallback) 的缩略形式。如下所示，也可以用 arrow functions（箭头函数）来表示：1234567doSomething().then(result =&gt; doSomethingElse(result)).then(newResult =&gt; doThirdThing(newResult)).then(finalResult =&gt; &#123; console.log(`Got the final result: $&#123;finalResult&#125;`);&#125;).catch(failureCallback); catch之后的链式操作在一个失败操作（即一个 catch）之后可以继续使用链式操作，即使链式中的一个动作失败之后还能有助于新的动作继续完成。请阅读下面的例子：12345678910111213141516new Promise((resolve, reject) =&gt; &#123; console.log('Initial'); resolve();&#125;).then(() =&gt; &#123; throw new Error('Something failed'); console.log('Do this');&#125;).catch(() =&gt; &#123; console.log('Do that');&#125;).then(() =&gt; &#123; console.log('Do this whatever happened before');&#125;);","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://www.hojun.cn/tags/es6/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Github","slug":"Github","date":"2018-03-24T13:00:24.000Z","updated":"2018-08-11T15:24:48.424Z","comments":true,"path":"2018/03/24/Github/","link":"","permalink":"https://www.hojun.cn/2018/03/24/Github/","excerpt":"","text":"PR1.github网页上fork源仓库2.git clone 自己fork的项目3.git remote add upstream 源仓库4.git remote -v5.git checkout -b 新的分支6.change code7.git status8.git add .9.git commit -m “说明”10.git push origin 分支名11.github网页上提交pr(New pull request)","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"github","slug":"github","permalink":"https://www.hojun.cn/tags/github/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Win10小技巧之创建不可删除文件夹，还能保护隐私哦~","slug":"Win10小技巧之创建不可删除文件夹，还能保护隐私哦","date":"2018-03-24T11:50:37.000Z","updated":"2018-08-11T15:24:50.650Z","comments":true,"path":"2018/03/24/Win10小技巧之创建不可删除文件夹，还能保护隐私哦/","link":"","permalink":"https://www.hojun.cn/2018/03/24/Win10小技巧之创建不可删除文件夹，还能保护隐私哦/","excerpt":"","text":"首先使用快捷键WIN+R打开“运行”对话框。并输入cmd 打开WINDOWS命令行程序CD进入到你想要创建文件夹路径输入命令md 文件夹名..\\创建不可删除文件夹1C:\\Users\\hj531\\Desktop&gt;md hojun..\\ 你会发现该路径下 已经建好一个文件夹你可以尝试删除这个文件夹，会发现它会报找不到该项目那要怎么删除这个文件夹呢？还是使用cmd命令行程序。在对应的路径下输入命令rd 文件夹名即可删除该文件夹1C:\\Users\\hj531\\Desktop&gt;rd hojun..\\ 我们试着往该文件夹中拖放其他文件夹，接着你会发现：啊咧！文件夹呢？？！！，还自动多了一个不带点点的文件夹？？是不是觉得很坑爹？先不要着急，就在有点点的文件下搜索你刚刚放入的文件夹名你会发现可以搜索到。那要怎么打开这个文件夹呢？只需要在地址栏中输入\\文件夹名，即可打开若是前一步没有记住该文件夹名怎么办？别急，只要删除掉那个自动生成的文件夹(不带点点的那个)。就可以让内部文件夹现行。 总结：这个小技巧实用性挺强，有以下优点 不可删除 防止自己误删 内部文件不可见可以保护自己的隐私 感谢大家阅读","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"win10","slug":"win10","permalink":"https://www.hojun.cn/tags/win10/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"SVG深入浅出","slug":"SVG深入浅出","date":"2018-03-14T16:36:54.000Z","updated":"2018-08-11T15:24:49.693Z","comments":true,"path":"2018/03/15/SVG深入浅出/","link":"","permalink":"https://www.hojun.cn/2018/03/15/SVG深入浅出/","excerpt":"","text":"什么是SVG？ SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 SVG 的历史和优势在 2003 年一月，SVG 1.1 被确立为 W3C 标准。参与定义 SVG 的组织有：太阳微系统、Adobe、苹果公司、IBM 以及柯达。与其他图像格式相比，使用 SVG 的优势在于： SVG 可被非常多的工具读取和修改（比如记事本） SVG 与 JPEG 和 GIF 图像比起来，尺寸更小，且可压缩性更强。 SVG 是可伸缩的 SVG 图像可在任何的分辨率下被高质量地打印 SVG 可在图像质量不下降的情况下被放大 SVG 图像中的文本是可选的，同时也是可搜索的（很适合制作地图） SVG 可以与 Java 技术一起运行 SVG 是开放的标准 SVG 文件是纯粹的 XML SVG 的主要竞争者是 Flash。 与 Flash 相比，SVG 最大的优势是与其他标准（比如 XSL 和 DOM）相兼容。而 Flash 则是未开源的私有技术。 SVG 实例下面的例子是一个简单的 SVG 文件的例子。SVG 文件必须使用 .svg 后缀来保存： 123456789101112&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\"stroke-width=\"2\" fill=\"red\"/&gt;&lt;/svg&gt; 代码解释：第一行包含了 XML 声明。请注意 standalone 属性！该属性规定此 SVG 文件是否是“独立的”，或含有对外部文件的引用。 standalone=”no” 意味着 SVG 文档会引用一个外部文件 - 在这里，是 DTD 文件。 第二和第三行引用了这个外部的 SVG DTD。该 DTD 位于 “http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd”。该 DTD 位于 W3C，含有所有允许的 SVG 元素。 SVG 代码以 &lt;svg&gt; 元素开始，包括开启标签 &lt;svg&gt; 和关闭标签 &lt;/svg&gt; 。这是根元素。width 和 height 属性可设置此 SVG 文档的宽度和高度。version 属性可定义所使用的 SVG 版本，xmlns 属性可定义 SVG 命名空间。 SVG 的 &lt;circle&gt; 用来创建一个圆。cx 和 cy 属性定义圆中心的 x 和 y 坐标。如果忽略这两个属性，那么圆点会被设置为 (0, 0)。r 属性定义圆的半径。 stroke 和 stroke-width 属性控制如何显示形状的轮廓。我们把圆的轮廓设置为 2px 宽，黑边框。 fill 属性设置形状内的颜色。我们把填充颜色设置为红色。 关闭标签的作用是关闭 SVG 元素和文档本身。 SVG 形状SVG 有一些预定义的形状元素，可被开发者使用和操作： 矩形 &lt;rect&gt; 圆形 &lt;circle&gt; 椭圆 &lt;ellipse&gt; 线 &lt;line&gt; 折线 &lt;polyline&gt; 多边形 &lt;polygon&gt; 路径 &lt;path&gt; rect例子123456789101112&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,255);stroke-width:1; stroke:rgb(0,0,0)&quot;/&gt;&lt;/svg&gt;代码解释：rect 元素的 width 和 height 属性可定义矩形的高度和宽度style 属性用来定义 CSS 属性CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）CSS 的 stroke-width 属性定义矩形边框的宽度CSS 的 stroke 属性定义矩形边框的颜色 CSS 的 fill 属性定义矩形的填充颜色（rgb 值、颜色名或者十六进制值）CSS 的 stroke-width 属性定义矩形边框的宽度CSS 的 stroke 属性定义矩形边框的颜色 CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1）CSS 的 stroke-opacity 属性定义笔触颜色的透明度（合法的范围是：0 - 1） 让我们看一下另一个包含新属性的例子：123456789101112&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;rect x=\"20\" y=\"20\" width=\"250\" height=\"250\"style=\"fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9\"/&gt;&lt;/svg&gt; 例子解释：x 属性定义矩形的左侧位置（例如，x=”0” 定义矩形到浏览器窗口左侧的距离是 0px）y 属性定义矩形的顶端位置（例如，y=”0” 定义矩形到浏览器窗口顶端的距离是 0px）CSS 的 fill-opacity 属性定义填充颜色透明度（合法的范围是：0 - 1）CSS 的 stroke-opacity 属性定义笔触颜色的透明度（合法的范围是：0 - 1）rx 和 ry 属性可使矩形产生圆角。 &lt;circle&gt; 标签&lt;circle&gt; 标签可用来创建一个圆。 请把下面的代码拷贝到记事本，然后把文件保存为 “circle1.svg”。把此文件放入您的web目录：1234567891011&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;circle cx=\"100\" cy=\"50\" r=\"40\" stroke=\"black\"stroke-width=\"2\" fill=\"red\"/&gt;&lt;/svg&gt; 代码解释：cx 和 cy 属性定义圆点的 x 和 y 坐标。如果省略 cx 和 cy，圆的中心会被设置为 (0, 0)r 属性定义圆的半径。 &lt;ellipse&gt; 标签&lt;ellipse&gt; 标签可用来创建椭圆。椭圆与圆很相似。不同之处在于椭圆有不同的 x 和 y 半径，而圆的 x 和 y 半径是相同的。 请把下面的代码拷贝到记事本，然后把文件保存为 “ellipse1.svg”。把此文件放入您的 web 目录：123456789101112&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;ellipse cx=\"300\" cy=\"150\" rx=\"200\" ry=\"80\"style=\"fill:rgb(200,100,50);stroke:rgb(0,0,100);stroke-width:2\"/&gt;&lt;/svg&gt; 代码解释：cx 属性定义圆点的 x 坐标cy 属性定义圆点的 y 坐标rx 属性定义水平半径ry 属性定义垂直半径 &lt;line&gt; 标签&lt;line&gt; 标签用来创建线条。 请把下面的代码拷贝到记事本，然后把文件保存为 “line1.svg”。把此文件放入您的 web 目录：1234567891011&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;line x1=\"0\" y1=\"0\" x2=\"300\" y2=\"300\"style=\"stroke:rgb(99,99,99);stroke-width:2\"/&gt;&lt;/svg&gt; 代码解释：x1 属性在 x 轴定义线条的开始y1 属性在 y 轴定义线条的开始x2 属性在 x 轴定义线条的结束y2 属性在 y 轴定义线条的结束 &lt;polygon&gt; 标签&lt;polygon&gt; 标签用来创建含有不少于三个边的图形。 请把下面的代码拷贝到记事本，然后把文件保存为 “polygon1.svg”。把此文件放入您的 web 目录：123456789101112&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;polygon points=\"220,100 300,210 170,250\"style=\"fill:#cccccc;stroke:#000000;stroke-width:1\"/&gt;&lt;/svg&gt; 代码解释：points 属性定义多边形每个角的 x 和 y 坐标 &lt;polyline&gt; 标签&lt;polyline&gt; 标签用来创建仅包含直线的形状。 请把下面的代码拷贝到记事本，然后把文件保存为 “polyline1.svg”。把此文件放入您的 web 目录：1234567891011&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;polyline points=\"0,0 0,20 20,20 20,40 40,40 40,60\"style=\"fill:white;stroke:red;stroke-width:2\"/&gt;&lt;/svg&gt; &lt;path&gt; 标签&lt;path&gt; 标签用来定义路径。 下面的命令可用于路径数据： M moveto 移动到 (x y)+ Z closepath 关闭路径 (none) L lineto 画线到 (x y)+ H horizontal lineto 水平线到 x+ V vertical lineto 垂直线到 y+ C curveto 三次贝塞尔曲线到 (x1 y1 x2 y2 x y)+ S smooth curveto 光滑三次贝塞尔曲线到 (x2 y2 x y)+ Q quadratic Bézier curveto 二次贝塞尔曲线到 (x1 y1 x y)+ T smooth quadratic Bézier curveto 光滑二次贝塞尔曲线到 (x y)+ A elliptical arc 椭圆弧 (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+ R Catmull-Rom curveto* Catmull-Rom曲线 x1 y1 (x y)+ 请把下面的代码拷贝到记事本，然后把文件保存为 “path1.svg”。把此文件放入您的 web 目录：12345678910&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;path d=\"M250 150 L150 350 L350 350 Z\" /&gt;&lt;/svg&gt; 上面的例子定义了一条路径，它开始于位置 250 150，到达位置 150 350，然后从那里开始到 350 350，最后在 250 150 关闭路径。 SVG 滤镜在 SVG 中，可用的滤镜有： feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feFlood feGaussianBlur feImage feMerge feMorphology feOffset feSpecularLighting feTile feTurbulence feDistantLight fePointLight feSpotLight 必须在 &lt;defs&gt; 标签中定义 SVG 滤镜。 高斯模糊（Gaussian Blur）&lt;filter&gt; 标签用来定义 SVG 滤镜。&lt;filter&gt; 标签使用必需的 id 属性来定义向图形应用哪个滤镜？ &lt;filter&gt; 标签必须嵌套在 &lt;defs&gt; 标签内。&lt;defs&gt; 标签是 definitions 的缩写，它允许对诸如滤镜等特殊元素进行定义。 请把下面的代码拷贝到记事本，然后把文件保存为 “filter1.svg”。把此文件放入您的 web 目录：123456789101112131415161718&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;defs&gt;&lt;filter id=\"Gaussian_Blur\"&gt;&lt;feGaussianBlur in=\"SourceGraphic\" stdDeviation=\"3\" /&gt;&lt;/filter&gt;&lt;/defs&gt;&lt;ellipse cx=\"200\" cy=\"150\" rx=\"70\" ry=\"40\"style=\"fill:#ff0000;stroke:#000000;stroke-width:2;filter:url(#Gaussian_Blur)\"/&gt;&lt;/svg&gt; 代码解释：&lt;filter&gt; 标签的 id 属性可为滤镜定义一个唯一的名称（同一滤镜可被文档中的多个元素使用）filter:url 属性用来把元素链接到滤镜。当链接滤镜 id 时，必须使用 # 字符滤镜效果是通过 &lt;feGaussianBlur&gt; 标签进行定义的。fe 后缀可用于所有的滤镜&lt;feGaussianBlur&gt; 标签的 stdDeviation 属性可定义模糊的程度in=”SourceGraphic” 这个部分定义了由整个图像创建效果 SVG 渐变必须在 标签中进行定义。 SVG 渐变渐变是一种从一种颜色到另一种颜色的平滑过渡。另外，可以把多个颜色的过渡应用到同一个元素上。 在 SVG 中，有两种主要的渐变类型： 线性渐变 放射性渐变 线性渐变 &lt;linearGradient&gt; 可用来定义 SVG 的线性渐变。 &lt;linearGradient&gt; 标签必须嵌套在 &lt;defs&gt; 的内部。&lt;defs&gt; 标签是 definitions 的缩写，它可对诸如渐变之类的特殊元素进行定义。 线性渐变可被定义为水平、垂直或角形的渐变： 当 y1 和 y2 相等，而 x1 和 x2 不同时，可创建水平渐变当 x1 和 x2 相等，而 y1 和 y2 不同时，可创建垂直渐变当 x1 和 x2 不同，且 y1 和 y2 不同时，可创建角形渐变请把下面的代码拷贝到记事本，然后把文件保存为 “linear1.svg”。把此文件放入您的 web 目录：1234567891011121314151617181920&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;defs&gt;&lt;linearGradient id=\"orange_red\" x1=\"0%\" y1=\"0%\" x2=\"100%\" y2=\"0%\"&gt;&lt;stop offset=\"0%\" style=\"stop-color:rgb(255,255,0);stop-opacity:1\"/&gt;&lt;stop offset=\"100%\" style=\"stop-color:rgb(255,0,0);stop-opacity:1\"/&gt;&lt;/linearGradient&gt;&lt;/defs&gt;&lt;ellipse cx=\"200\" cy=\"190\" rx=\"85\" ry=\"55\"style=\"fill:url(#orange_red)\"/&gt;&lt;/svg&gt; 代码解释：&lt;linearGradient&gt; 标签的 id 属性可为渐变定义一个唯一的名称fill:url(#orange_red) 属性把 ellipse 元素链接到此渐变&lt;linearGradient&gt; 标签的 x1、x2、y1、y2 属性可定义渐变的开始和结束位置渐变的颜色范围可由两种或多种颜色组成。每种颜色通过一个 &lt;stop&gt; 标签来规定。offset 属性用来定义渐变的开始和结束位置。（水平渐变） 另一个例子：1234567891011121314151617181920&lt;?xml version=\"1.0\" standalone=\"no\"?&gt;&lt;!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"&gt;&lt;svg width=\"100%\" height=\"100%\" version=\"1.1\"xmlns=\"http://www.w3.org/2000/svg\"&gt;&lt;defs&gt;&lt;linearGradient id=\"orange_red\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\"&gt;&lt;stop offset=\"0%\" style=\"stop-color:rgb(255,255,0);stop-opacity:1\"/&gt;&lt;stop offset=\"100%\" style=\"stop-color:rgb(255,0,0);stop-opacity:1\"/&gt;&lt;/linearGradient&gt;&lt;/defs&gt;&lt;ellipse cx=\"200\" cy=\"190\" rx=\"85\" ry=\"55\"style=\"fill:url(#orange_red)\"/&gt;&lt;/svg&gt; （垂直渐变） 参考手册","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://www.hojun.cn/tags/svg/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"anime.js实现logo动画","slug":"anime-js实现logo动画","date":"2018-03-14T12:34:51.000Z","updated":"2018-08-11T15:24:48.082Z","comments":true,"path":"2018/03/14/anime-js实现logo动画/","link":"","permalink":"https://www.hojun.cn/2018/03/14/anime-js实现logo动画/","excerpt":"","text":"之前无聊浏览特效的时候，发现了anime.js的logo动画特效，于是也想整个自己的logo动画。着手coding的时候，发现没那么简单(｡•ˇ‸ˇ•｡) 第一个难点 SVG之前接触到的SVG一直都是“不失真的矢量图”这么一个概念，但是这次的特效需要用到svg的&lt;path&gt;标签 w3c介绍：123456789101112131415161718192021222324252627&lt;path&gt; 标签用来定义路径。下面的命令可用于路径数据： M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Belzier curve T = smooth quadratic Belzier curveto A = elliptical Arc Z = closepath注释：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。请把下面的代码拷贝到记事本，然后把文件保存为 &quot;path1.svg&quot;。把此文件放入您的 web 目录：&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;&lt;path d=&quot;M250 150 L150 350 L350 350 Z&quot; /&gt;&lt;/svg&gt;上面的例子定义了一条路径，它开始于位置 250 150，到达位置 150 350，然后从那里开始到 350 350，最后在 250 150 关闭路径。 通过以上介绍能够稍微理解path作用，了解更多请浏览作者的另一篇文章SVG深入浅出 第二个难点 贝赛尔曲线在我了解了SVG的大致原理后，自以为已经接近成功的大门。于是用ps做了一幅png格式的logo图片接着把png转svg格式图片，在线转换工具最后把SVG的path数据插入代码。Σ(っ °Д °;)っ发现并不是自己想要的效果。通过阅读官方文档和特效代码发现anime.js的动画是根据路径来呈现的，所以我应该提供的SVG的&lt;path&gt;只是一条线段就够了。 又回到起点，从新开始使用&lt;path&gt;提供的命令画logo。第一个h，好办的，只要把n的左边那条直线的Y坐标改长点就行。第二个o,没有现成的o，只能在a上面动手脚，可是&lt;path&gt;的C命令就是三次贝塞尔曲线。表示不太会画，肿么办(/ω＼)?上网找资料呗~ 找到张鑫旭大牛的一片文章深度掌握SVG路径path的贝塞尔曲线指令还有dayu提供的任意二次、三次贝塞尔曲线呈现工具已知a的三条弧线即需要求红框里的两个点。需要求甚解的童鞋请参照这篇文章使用贝塞尔曲线拟合圆不需要的童鞋可以发挥一下自带的我看看看看看出来，上图已经很明显了，o即圆形是上下左右对称的，通过对称的特性就可以得到那两个点的坐标。第三个j,自由发挥了o(￣︶￣)o第四个u,参考n把它给倒过来(⌒▽⌒)第五个n,现成的有，大功告成ヾ(^▽^*))) 效果预览感谢anime.js以及51web提供的特效代码","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"js","slug":"js","permalink":"https://www.hojun.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"使用disqus评论","slug":"使用disqus评论","date":"2018-03-07T15:07:28.000Z","updated":"2018-08-11T15:24:51.277Z","comments":true,"path":"2018/03/07/使用disqus评论/","link":"","permalink":"https://www.hojun.cn/2018/03/07/使用disqus评论/","excerpt":"","text":"Disqus网址：https://disqus.com/ Disqus配置使用注册步骤省略(注意要科学上网) WebsiteName 是 hojun，所以主题配置文件(_config.yml)的disqus_shortname就填 hojun (就填你自己的) 以下是我的配置和comment部分代码：1disqus_shortname: hojun 123456789101112131415161718&lt;% if (config.disqus_shortname &amp;&amp; page.comments) &#123; %&gt;&lt;div id=\"disqus_thread\"&gt;&lt;/div&gt;&lt;script&gt; /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ var disqus_config = function () &#123; this.page.url = '&lt;%- post.permalink %&gt;'; this.page.identifier = '&lt;%- post.path %&gt;'; &#125;; (function() &#123; // DON'T EDIT BELOW THIS LINE var d = document, disqus_shortname = '&lt;%= config.disqus_shortname %&gt;',s = d.createElement('script'); s.src = 'https://'+disqus_shortname+'.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); &#125;)();&lt;/script&gt; 参考https://www.jianshu.com/p/d68de067ea74?open_source=weibo_search","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"拼音学习StudyPinYin","slug":"拼音学习StudyPinYin","date":"2018-02-22T15:00:38.000Z","updated":"2018-08-11T15:24:46.093Z","comments":true,"path":"2018/02/22/拼音学习StudyPinYin/","link":"","permalink":"https://www.hojun.cn/2018/02/22/拼音学习StudyPinYin/","excerpt":"","text":"趁着年后空闲时间，做了一个拼音学习的网页2333333~~~ 源码地址[目前拼音教程更新完毕，打字教程还没实现待老妈学会拼音在追加~~~]demo 使用说明 使用电脑打开网页，或者手机打开网页并使用OTG转接线连接键盘~ 功能介绍 自动播放：点击自动播放按钮，网页会自动按顺序或乱序播放拼音读音。再次点击，播放暂停。 全部练习：练习所有的拼音，包括多个和单个。 练习单个：练习单个的拼音，不包括多个。 联系多个：练习多个的拼音，不包括单个。 顺序练习：按英文字母ABCD的顺序播放练习 。 乱序练习：随机顺序播放练习。 自由模式：自由按键，后发音。比如你在键盘上打个C，页面上再显示出C并播放读音 声音控制：按钮彩色表示会播放声音，点击按钮变灰表示不播放声音。再次点击按钮会切换成彩色并播放声音。 关注以下微信公众号获取更多拼音学习的内容~","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"搞事","slug":"搞事","permalink":"https://www.hojun.cn/tags/搞事/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"live2d-看板娘小埋","slug":"live2d-看板娘小埋","date":"2018-02-19T13:10:03.000Z","updated":"2018-08-30T15:40:53.555Z","comments":true,"path":"2018/02/19/live2d-看板娘小埋/","link":"","permalink":"https://www.hojun.cn/2018/02/19/live2d-看板娘小埋/","excerpt":"","text":"最近群里有人在耍live2d看板娘，于是默默地跑去get到了一个小埋~ 第一步 准备代码和工具(注意：代码要在服务器环境下跑)[代码百度云公众号回复demo002获取][AdobeAIRInstaller同上][live2dViewer同上]你也可以去官网下载官网小埋和薇尔莉特live2d模型资源使用资源可跳过第二步 第二步 get资源(注意:apk和lpk都可以用压缩工具打开)寻找资源，安利贴吧大佬的提供的资源乖离性ma吧或者嘿嘿嘿，使用某电或某神模拟器去得到live2d萌宠里面的资源(root过的手机也行)。这里用某电模拟器示范：安装live2d萌宠-&gt;商店-&gt;下载稀饭的萌宠-&gt;打开文件管理器-&gt;找到对应的model(在Android/data下面)-&gt;移动到模拟器和电脑的共享文件夹中接着把json文件拖动到Live2dViewer中,得到如下图： 第三步 修改代码这一步假设你已经跑的起来第一步那份代码了…把得到的model资源放到model文件夹下打开demo.html修改上你自己的路径接下来就是放入博客页面，调调大小，挪挪位置。duangduangduang~效果预览 在这里感谢：乖离性ma吧 dalao提供的资源live2d萌宠后宫学长提供的代码代码EYHN如何给自己的博客添加一个萌萌的看板娘！live2d给博客添加能动的看板娘(Live2D)-将其添加到网页上吧 隐藏 var message_Path = '/live2d/' var home_Path = 'https://www.hojun.com/' $(function(){ loadlive2d(\"live2d\", \"/live2d/model/xiaomai/xiaomai.json\"); })","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"live2d","slug":"live2d","permalink":"https://www.hojun.cn/tags/live2d/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"喜欢的音乐","slug":"喜欢的音乐","date":"2018-02-18T03:12:14.000Z","updated":"2018-08-11T15:24:45.570Z","comments":true,"path":"2018/02/18/喜欢的音乐/","link":"","permalink":"https://www.hojun.cn/2018/02/18/喜欢的音乐/","excerpt":"","text":"古风 千秋令 整首歌是比照“通史”的写法一条线贯通下来。歌曲中所涉及的具体历史时期包括：夏、商、西周、春秋、战国、秦、西汉、东汉、三国、西晋、东晋、南朝、北朝、隋、唐、南唐（五代十国）、北宋、南宋、明。 国语 日漫 紫罗兰永恒花园 我们仍未知道那天所看见的花的名字 四月是你的谎言 外语 其他","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"music","slug":"music","permalink":"https://www.hojun.cn/tags/music/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"Python+selenium自动上传博客图片至新浪微博相册","slug":"Python-selenium自动上传博客图片至新浪微博相册","date":"2018-02-12T12:57:04.000Z","updated":"2018-08-11T15:24:49.382Z","comments":true,"path":"2018/02/12/Python-selenium自动上传博客图片至新浪微博相册/","link":"","permalink":"https://www.hojun.cn/2018/02/12/Python-selenium自动上传博客图片至新浪微博相册/","excerpt":"","text":"Why?写博客的时候每次使用图片都得先上传到新浪微博，然后在得到链接插入到markdown中。这样操作多来几次就受不了，于是就使用python+selenium自动上传博客图片。 第一步 安装环境Python3python3百度云selenium12//打开cmd运行pip install selenium 安装chromedriver - 各版本下载地址 chromedriver版本 支持的Chrome版本 v2.35 v62-64 v2.34 v61-63 v2.33 v60-62 v2.32 v59-61 v2.31 v58-60 v2.30 v58-60 v2.29 v56-58 v2.28 v55-57 v2.27 v54-56 v2.26 v53-55 v2.25 v53-55 v2.24 v52-54 v2.23 v51-53 v2.22 v49-52 v2.21 v46-50 v2.20 v43-48 v2.19 v43-47 v2.18 v43-46 v2.17 v42-43 v2.13 v42-45 v2.15 v40-43 v2.14 v39-42 v2.13 v38-41 v2.12 v36-40 v2.11 v36-40 v2.10 v33-36 v2.9 v31-34 v2.8 v30-33 v2.7 v30-33 v2.6 v29-32 v2.5 v29-32 v2.4 v29-32 第二步 获取XPath首先打开登录页面，得到需要的账号、密码、登录的XPath(按F12打开开发者工具)得到账号的XPath如下图(其他同理,注意是input标签哦)：得到上传照片按钮的XPath得到普通上传的XPath得到选择图片的Xpath以下省略1000字…… 第三步 撸代码调试代码如下(简单易懂吧)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import osfrom selenium import webdriverimport timeclass Connect(): def __init__(self): self.UserName = '你的账号' self.PassWord = '你的密码' # 微相册的登录地址 self.URL = 'https://weibo.com/login.php?url=http://photo.weibo.com/5673857615/albums' def upload(self): # chromedriver的安装地址(默认) self.driver = webdriver.Chrome('C:\\Program Files (x86)\\Google\\Chrome\\Application\\chromedriver.exe') # 最大化浏览器窗口 self.driver.maximize_window() self.driver.get(self.URL) # 输入账号 self.driver.find_element_by_xpath('//*[@id=\"loginname\"]').send_keys(self.UserName) # 输入密码 self.driver.find_element_by_xpath('//*[@id=\"pl_login_form\"]/div/div[3]/div[2]/div/input').send_keys(self.PassWord) # 点击登录(我这里忽略需要验证码的情况 可以用打码平台解决，或手动输入) self.driver.find_element_by_xpath('//*[@id=\"pl_login_form\"]/div/div[3]/div[6]/a').click() # 等待3秒 time.sleep(3) # 点击上传照片 self.driver.find_element_by_xpath('//*[@id=\"user_info\"]/div/a').click() time.sleep(3) # 点击普通上传 self.driver.find_element_by_xpath('//*[@id=\"flash_upload\"]/p/a').click() # 打开需要记录上传的图片地址的txt fr = open(\"E:\\python\\pySinaAutoUpload\\imgsPath.txt\", \"r\") content = fr.readlines() # 循环上传图片 for index,val in enumerate(content): imgPath = val.strip() #去掉每行头尾空白 time.sleep(3) i = index + 1 if i == 1: self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/ul/li/form/input').send_keys(imgPath) time.sleep(3) self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/ul/li/form/a').click() else: self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/ul/li[' + str(i) + ']/form/input').send_keys(imgPath) time.sleep(3) self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/ul/li[' + str(i) + ']/form/a').click() # 关闭文件 fr.close() time.sleep(3) # 点击下一步 self.driver.find_element_by_xpath('//*[@id=\"common_upload\"]/div/a').click() time.sleep(3) # 点击保存并发布 self.driver.find_element_by_xpath('//*[@id=\"uploadPanel\"]/div[2]/div[4]/a').click() time.sleep(3) # 得到上传文件的个数 count = len(content); # 打开记录上传图片的URL的txt fw = open(\"E:\\python\\pySinaAutoUpload\\imgsUrl.txt\", \"w\") # 循环得到图片Url for j in range(count): imgsUrl = self.driver.execute_script('return document.getElementsByClassName(\"m_photoItem m_photoItem_a\")[' + str(j) + '].getElementsByTagName(\"img\")[0].src') time.sleep(3) imgsUrl = imgsUrl.replace(\"small\", \"large\"); fw.write(imgsUrl + '\\n') fw.flush() fw.close()Connect().upload() 第四步 编写bat批处理文件简化操作为什么用bat? 一开始是想直接拖到.py文件上运行的，可以改了注册表重启什么的还是不管用getPath.bat // 得到图片路径12345678@Echo Off&amp;Setlocal EnabledelayedexpansionDel /q E:\\python\\pySinaAutoUpload\\imgsPath.txtFor /l %%a in (1,1,9) do (Call Set \"f=%%%%~a\"(If defined f Dir /a-d /b /s !f!)&gt;&gt;E:\\python\\pySinaAutoUpload\\imgsPath.txt)For /f \"tokens=*\" %%i in (imgsPath.txt) do (Ren \"%%~dpni_New%%~xi\" \"%%~nxi\")exit upload.bat //运行py12cd E:\\python\\pySinaAutoUpload\\python uploadImgs.py 好了，到此告一段落了，等有时间补上使用py模拟登陆的解决方案 参考：http://blog.csdn.net/justheretobe/article/details/50939021","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hojun.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"sublime使用技巧","slug":"sublime使用技巧","date":"2018-02-09T11:49:59.000Z","updated":"2018-08-11T15:24:49.659Z","comments":true,"path":"2018/02/09/sublime使用技巧/","link":"","permalink":"https://www.hojun.cn/2018/02/09/sublime使用技巧/","excerpt":"","text":"设置默认打开的文件类型","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"https://www.hojun.cn/tags/sublime/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"博客小人","slug":"博客小人","date":"2018-02-04T16:11:09.000Z","updated":"2018-08-11T15:24:45.471Z","comments":true,"path":"2018/02/05/博客小人/","link":"","permalink":"https://www.hojun.cn/2018/02/05/博客小人/","excerpt":"","text":"加完特效顺带把自己之前玩过的博客小人也搬过来(原来在蚂蚁笔记的博客上，博客到期了)，不过把小人换成了可爱的小埋~使用说明：(改成了xiaomai.js和xiaomai.css)，在页面上引入，并加上以下代码12345678&lt;div id=\"spig\" class=\"spig\"&gt; &lt;div id=\"message\"&gt;&lt;/div&gt; &lt;div id=\"xiaomai\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"fixed-xm\"&gt; &lt;img src=\"/images/xiaomai/xm.png\"&gt; &lt;audio src=\"/images/xiaomai/xm.mp3\" id=\"xm_audio\" preload=\"auto\" style=\"display:none;\"&gt;&lt;/audio&gt;&lt;/div&gt; 图片是百度上下载，在用ps抠的。使用： spig.js完…","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.hojun.cn/tags/blog/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"打字特效","slug":"打字特效","date":"2018-02-04T15:58:10.000Z","updated":"2018-08-11T15:24:46.056Z","comments":true,"path":"2018/02/04/打字特效/","link":"","permalink":"https://www.hojun.cn/2018/02/04/打字特效/","excerpt":"","text":"早些时候，见识并体验过atom编译器插件activate-power-mode的打字特效。简直是一路火花加闪电，牛逼的不要不要的。可惜还是喜欢用sublime，玩了一会就不耍了。后来在其他博主哪里看见了有js版的activate-power-mode,走过路过不要错过，于是给自己博客也加了该效果。特效demo请去搜索打字。js版activate-power-mode使用说明：123456&lt;script src=\"activate-power-mode.js\"&gt;&lt;/script&gt;&lt;script&gt;POWERMODE.colorful = true; // make power mode colorfulPOWERMODE.shake = false; // turn off shakedocument.body.addEventListener('input', POWERMODE);&lt;/script&gt; 完…","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.hojun.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"github博客迁移至coding并提交百度收录","slug":"github博客迁移至coding并提交百度收录","date":"2018-01-25T14:44:09.000Z","updated":"2018-08-11T15:24:48.471Z","comments":true,"path":"2018/01/25/github博客迁移至coding并提交百度收录/","link":"","permalink":"https://www.hojun.cn/2018/01/25/github博客迁移至coding并提交百度收录/","excerpt":"","text":"因为度娘的蜘蛛被github拉小黑屋了，为了提高访问量，决定把博客迁移至coding(github共存)。 第一步：注册codinghttps://coding.net/注册流程略。。。。注册完成后先别急，如果你有自己购买的域名。需要把账号升级至银牌会员(只需完善信息，不收money) 第二步：新建项目升级成功后新建项目注意事项: 项目名要和用户名一致 要选择公开 第三步：配置创建好项目后在个人设置里面添加SSH公钥，可以参照帮助文档配置 SSH 公钥访问代码仓库然后复制项目的https或git到hexo的配置文件_config.yml(注意，冒号后面要有个空格)如：123456deploy: type: git repo: github: https://github.com/honjun/honjun.github.io.git coding: https://git.coding.net/hojun/hojun.git branch: master 第四步：开启Pages服务cmd运行hexo g,hexo d在Coding的项目中打开Pages服务-&gt;静态Pages,部署来源-master分支就可以在coding.yourname.me看到你部署好的博客了 第五步：绑定自定义域名在域名解析添加一条CNAME记录即可，如绑定二级域名xxx.你的域名.xx等待生效，一般12小时左右回到项目代码下，新建CNAME文件，内容为1xxx.你的域名.xx 再在Coding Pages服务里面绑定自定义域名接下来在hexo模板的footer下放置「Hosted by Coding Pages」迁移完毕…… 第六步：提交百度收录登录百度搜索资源平台-&gt;网站支持-&gt;数据引入-&gt;链接提交。即可，没有绑定过的需要先新增站点并验证。注意https和http有区别，需要自己选择，选错了会验证不了推荐使用sitemap方式提交，推荐一个hexo的sitemap生成插件：hexo-generator-baidu-sitemap","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Hexo博客备份—妈妈再也不用担心你使用hexo写博客","slug":"Hexo博客备份—妈妈再也不用担心你使用hexo写博客","date":"2018-01-25T14:06:39.000Z","updated":"2018-08-11T15:24:48.604Z","comments":true,"path":"2018/01/25/Hexo博客备份—妈妈再也不用担心你使用hexo写博客/","link":"","permalink":"https://www.hojun.cn/2018/01/25/Hexo博客备份—妈妈再也不用担心你使用hexo写博客/","excerpt":"","text":"今天搜了下hexo博客备份，发现好多都是用git命令备份的，于是推荐款好用的hexo备份插件：hexo-git-backup git-backup使用说明(翻译至README)：安装如果您的hexo版本是2.xx，则应安装如下：1$ npm install hexo-git-backup@0.0.91 --save 如果版本是3.xx，你应该安装如下：1$ npm install hexo-git-backup --save 更新(windows不需要$符)如果使用–save进行安装，则在更新时必须先删除。12$ npm remove hexo-git-backup$ npm install hexo-git-backup --save 配置你应该配置这个文件_config.yml如下。12345backup: type: git repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchName 比如博主就新建了个backup分支用于备份博主的配置如下12345backup: type: git message: backup my blog of https://honjun.github.io/ repository: github: https://github.com/honjun/honjun.github.io.git,backup 使用1hexo backup or1hexo b Options 如果你要备份你的主题，只需添加theme: your theme name,your theme name在_config.yml。123456backup: type: git theme: coney,landscape,xxx repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchName 注意：如果您按照上述方式操作，themes/coney/.git则会删除目录 如果你想DIY提交消息，只需添加“消息：更新xxx”。123456backup: type: git message: update xxx repository: github: git@github.com:xxx/xxx.git,branchName gitcafe: git@github.com:xxx/xxx.git,branchName 现在你可以备份所有的博客！ 问题您的计算机许可可能会造成一些麻烦。 错误：EISDIR，打开是由权限引起的。只要做’sudo hexo b’1sudo hexo b 参考hexo 的备份插件","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"tesseract-OCR字库练习","slug":"tesseract-OCR字库练习","date":"2018-01-24T08:18:47.000Z","updated":"2018-08-11T15:24:49.725Z","comments":true,"path":"2018/01/24/tesseract-OCR字库练习/","link":"","permalink":"https://www.hojun.cn/2018/01/24/tesseract-OCR字库练习/","excerpt":"","text":"第一步：需要用到的安装包jdk-8u101-windows-x64tesseract-ocr-setup-3.05.01jTessBoxEditor-1.7.3简体中文chi_sim注意 tesseract需要编译器(安装包没提供)Supported Compilers are: GCC 4.8 and above Clang 3.4 and above MSVC 2015, 2017 安装略… 第二步：tesseract-OCR初认识-l lang 使用的语言。如果没有指定，则采用英文。可以指定多种语言，由加号字符分隔。Tesseract使用3个字符的ISO 639-2语言代码。（请参阅语言） –psm N将Tesseract设置为只运行布局分析的一个子集并假定某种形式的图像。N的选项是： 0 =只有方向和脚本检测（OSD）。 1 =使用OSD自动分页。 2 =自动分页，但没有OSD或OCR。 3 =全自动页面分割，但没有OSD。（默认） 4 =假设一列可变大小的文本。 5 =假设一个统一的垂直排列文本块。 6 =假设一个统一的文本块。 7 =将图像作为单个文本行处理。 8 =将图像视为一个单词。 9 =将图像视为一个圆圈中的单个单词。 10 =将图像视为单个字符。 基本的命令行用法：1tesseract imagename outputbase [-l lang] [--oem ocrenginemode] [--psm pagesegmode] [configfiles...] 第三步：jTessBoxEditor训练字库之前玩冲顶大会的时候用过tesseract-OCR识别中文，可惜准确率很不理想，如下图：使用tesseract-OCR识别会得到1tesseract question.jpg result -l chi_sim --psm 6 result.txt18.手木几生产商诺墓亚最子刀是L又生产&#123;十么为主? 发现错了好多，机、基、初、以都没有识别出来，有的还识别成两个字。这个时候就需要我们来训练中文字库 准备好要识别的图片question.jpg第一步：1、将图片转换成tif格式，用于后面生成box文件。可以通过画图，然后另存为tif即可。tif文面命名格式是有要求的：1[lang].[fontname].exp[num].tif lang 语言名(这可自定义，不要与现有的相同 eng、chi_sim等)fontname 字体(就是字体名字，比如normal、italic、bold)num 序号 把question.jpg用自带的画图另存为hojun.normal.exp0.jpg和hojun.normal.exp0.tif(注意，重命名改后缀不行)，放在E:\\TessBox\\下接着打开cmd进入到该文件下，输入以下命令：123E:\\TessBox&gt;tesseract hojun.normal.exp0.tif hojun.normal.exp0 -l chi_sim --psm 6 batch.nochop makeboxTesseract Open Source OCR Engine v3.05.01 with LeptonicaPage 1 会得到hojun.normal.exp0.box文件，右键使用记事本打开效果如下图 打开jTessBoxEditor目录，双击train.bat打开(可能要等待5-6秒，耐心等待程序响应)打开软件后点击Box Editor-&gt;Open-&gt;选择对应的tif文件打开得到如下效果如果右边字体没有框框，左边没有内容是因为java8没安装好，或者安装了两个java版本，使用的是其他java版本可以在控制台输入1234E:&gt;java -versionjava version \"1.8.0_101\"Java(TM) SE Runtime Environment (build 1.8.0_101-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.101-b13, mixed mode) 来查看java版本。如果使用其他版本的，一般在环境变量Path里面把java8的路径写在最前面就行。接下来就是调整了。删删改改如下：然后点击save保存即可。接着在E:\\TessBox\\下新建一个font_properties文件，注意没有后缀里面内容写入normal 0 0 0 0 0 表示默认普通字体再接着新建一个txt文件，里面内容写入123456789101112131415161718192021echo Run Tesseract for Training.. tesseract.exe hojun.normal.exp0.tif hojun.normal.exp0 nobatch box.train echo Compute the Character Set.. unicharset_extractor.exe hojun.normal.exp0.boxshapeclustering -F font_properties -U unicharset hojun.normal.exp0.trmftraining -F font_properties -U unicharset -O unicharset hojun.normal.exp0.tr echo Clustering.. cntraining.exe hojun.normal.exp0.tr echo Rename Files.. rename normproto hojun.normproto rename inttemp hojun.inttemp rename pffmtable hojun.pffmtable rename shapetable hojun.shapetable echo Create Tessdata.. combine_tessdata.exe hojun. echo. &amp; pause 保存，修改文件名为Train.bat。(为了偷懒，你也可以在命令里一句一句命令的敲)双击批处理文件生成！成功结果如下把hojun.traineddata复制到C:\\Program Files (x86)\\Tesseract-OCR\\tessdata下试着识别1tesseract hojun.normal.exp0.jpg result -l hojun --psm 6 得到正确的结果 参考:https://github.com/tesseract-ocr/tesseract/wiki/Training-Tesseract训练TesseractTesseract-OCR的简单使用与训练Tesseract-OCR识别中文与训练字库实例JAVA_HOME无效，java版本保持不变的问题解决","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Python玩转冲顶大会","slug":"Python玩转冲顶大会","date":"2018-01-11T13:59:56.000Z","updated":"2018-08-11T15:24:49.559Z","comments":true,"path":"2018/01/11/Python玩转冲顶大会/","link":"","permalink":"https://www.hojun.cn/2018/01/11/Python玩转冲顶大会/","excerpt":"","text":"在玩跳一跳的时候，发现有人用python+Tesseract-ORC开发了冲顶大会的辅助。由于之前折腾过验证码识别安装过Tesseract，于是就花点时间玩了下这个冲顶大会的辅助。代码及安装包:github地址tesseract-ocr-setup-3.05.01简体中文chi_sim 第一步：安装下载代码pc上装有git的可以使用git clone代码到本地或者点击DownloadZIP下载压缩包到本地(解压到哪看自己喜欢) 第二步，配置环境安装python，推荐安装python3，会带有pip。python2可能会没有pip,需要自己安装(至于怎么安装请自行百度)。python3百度云接着安装adb - adb百度云配置path变量，在我的电脑(此电脑)上右键属性或控制面板\\系统和安全\\系统点击高级系统设置-&gt;环境变量-&gt;系统变量里找到path-&gt;编辑-&gt;添加分别加入这三个(对应的是软件安装的位置，装在哪填的就是那里，可能和博主的会有出入)，其中第二个是pip的地址 可以在cmd(怎么打开cmd请自行百度)里输出如下命令测试是否安装成功1234C:\\&gt;python --versionPython 3.6.4C:\\&gt;adb versionAndroid Debug Bridge version 1.0.31 最后一步进入项目根目录执行pip install -r requirements.txt1E:\\gitR\\wechat_jump_game&gt;pip install -r requirements.txt 安装可能会有点慢，还会卡住，卡住需要敲敲回车才能继续下载，否则会下载失败。建议使用pip的国内镜像下载(自行百度) 第三步：安装Tesseract-ORC 3.05.01这里可以选择安装中文语言包也可以不勾选（建议不勾选，下载速度慢。）自行下载语言包放到安装目录(C:\\Program Files (x86)\\Tesseract-OCR\\tessdata)下即可 第四步：运行代码 1.安卓手机打开 USB 调试，设置 &gt; 开发者选项 &gt; USB 调试 2.电脑与手机 USB 线连接，确保执行 adb devices 可以找到设备 ID 3.打开cmd，并进入项目目录，运行python GetQuestionAndroid.py 效果如下 第五步：调整截图位置当然，因为大家的设备不一致，屏幕大小不一，所以一般是不会成功的，还需要调整截图位置可以在TopSup\\common\\ocr.py里保存截图来调试保存截图的代码如下 1234567891011121314question_im = image.crop((50, 320, 1450, 550))choices_im = image.crop((140, 550, 1000, 1070))if os.path.isfile('question.png'): try: os.remove('question.png') except Exception: passif os.path.isfile('choices.png'): try: os.remove('choices.png') except Exception: passquestion_im.save('question.png')choices_im.save('choices.png') 截图如下(二值化过的) 新版将需要配置的参数统一调整到 config/configure.conf中，可以在这个文件中直接改[region] 题目与选项区域question_region = 50, 350, 1000, 560choices_region = 75, 535, 1000, 1200 题目和选项一起的区域combine_region = 50, 350, 1000, 1200 [tesseract] windows tesseract 安装路径tesseract_cmd = C:\\Program Files (x86)\\Tesseract-OCR\\tesseract 语言包目录和参数tessdata_dir_config = –tessdata-dir “C:\\Program Files (x86)\\Tesseract-OCR\\tessdata” –psm 6 mac 环境, 文件夹分割请使用 / 代替 \\ 如 ‘/usr/local/Cellar/tesseract/3.05.01/bin/tesseract’","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"snowfall.jquery.js实现樱花飘落效果","slug":"snowfall-jquery-js实现樱花飘落效果","date":"2018-01-10T15:01:54.000Z","updated":"2018-08-23T12:34:42.585Z","comments":true,"path":"2018/01/10/snowfall-jquery-js实现樱花飘落效果/","link":"","permalink":"https://www.hojun.cn/2018/01/10/snowfall-jquery-js实现樱花飘落效果/","excerpt":"","text":"前几天圣诞节玩了把雪花飘落的jquery插件结果一不小心又想搞个樱花飘落效果。。。不幸晚睡————猝献上jquery雪花插件snowfall.jquery.js该插件的参数有： flakeCount|number 雪花数量 flakeColor|#RGB 雪花颜色 flakeIndex|??? 不清楚 minSize|number 雪花最小体积 maxSize|number 雪花最大体积 minSpeed|number 雪花最小速度 maxSpeed|number 雪花最大速度 round|boolean true雪花圆形|false方形(笑哭) shadow|boolean true雪花有阴影|false无阴影 image|url 雪花图片 使用demo//css部分 12345678910&lt;style&gt;.snowfall-flakes&#123;animation:sakura 1s linear 0s infinite;&#125;@keyframes sakura&#123;0% &#123;transform:rotate3d(0, 0, 0, 0deg);&#125;25%&#123;transform:rotate3d(1, 1, 0, 60deg);&#125;50%&#123;transform:rotate3d(1, 1, 0, 0deg);&#125;75%&#123;transform:rotate3d(1, 0, 0, 60deg);&#125;100% &#123;transform:rotate3d(1, 0, 0, 0deg);&#125;&#125;&lt;/style&gt; //js部分 1234567&lt;script&gt;$(document).snowfall('clear');$(document).snowfall(&#123;image:\"1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,&#125;);$(document).snowfall(&#123;image:\"2.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,&#125;);$(document).snowfall(&#123;image:\"3.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,&#125;);$(document).snowfall(&#123;image:\"4.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,&#125;);&lt;script&gt; 飘落的时候添加了css的3D翻转效果，使之更加逼真图片是用ps一个一个扣下来的。扣好发现jpg格式不能带透明度，然后又心酸的重新扣png格式的。。。 function sakuraInit() { $(document).snowfall('clear'); if (document.body.clientWidth > 600) { $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/2.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/4.png\", flakeCount:20, minSpeed:1, minSize:8, maxSize:15,}); } else { $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/1.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/2.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); $(document).snowfall({image:\"/images/sakura/4.png\", flakeCount:10, minSpeed:1, minSize:8, maxSize:15,}); } } window.onload = sakuraInit();","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.hojun.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"python玩转跳一跳","slug":"python玩转跳一跳","date":"2018-01-08T14:24:34.000Z","updated":"2018-08-11T15:24:49.593Z","comments":true,"path":"2018/01/08/python玩转跳一跳/","link":"","permalink":"https://www.hojun.cn/2018/01/08/python玩转跳一跳/","excerpt":"","text":"2018年刚来就发生了很多事，咳咳。微信的跳一跳上线到python辅助工具出现到今天github上的star数量就达到了11万！(估计大部分都是为了玩游戏来的)。元旦时候就想使用这个工具顺带接触下python,有事一直拖到现在。github传送门官方教程点这里这里只介绍windows系统的Android教程…mac请自力更生(不难的) 博主采用的是方法一： 第一步，下载代码pc上装有git的可以使用git clone代码到本地 或者点击DownloadZIP下载压缩包到本地(解压到哪看自己喜欢) 第二步，配置环境安装python，推荐安装python3，会带有pip。python2可能会没有pip,需要自己安装(至于怎么安装请自行百度)。python3百度云接着安装adb - adb百度云配置path变量，在我的电脑(此电脑)上右键属性或控制面板\\系统和安全\\系统点击高级系统设置-&gt;环境变量-&gt;系统变量里找到path-&gt;编辑-&gt;添加分别加入这三个(对应的是软件安装的位置，装在哪填的就是那里，可能和博主的会有出入)，其中第二个是pip的地址 可以在cmd(怎么打开cmd请自行百度)里输出如下命令测试是否安装成功1234C:\\&gt;python --versionPython 3.6.4C:\\&gt;adb versionAndroid Debug Bridge version 1.0.31 最后一步进入项目根目录执行pip install -r requirements.txt1E:\\gitR\\wechat_jump_game&gt;pip install -r requirements.txt 安装可能会有点慢，还会卡住，卡住需要敲敲回车才能继续下载，否则会下载失败。建议使用pip的国内镜像下载(自行百度) 第三步，手机连接usb开始测试 安卓手机打开 USB 调试，设置 &gt; 开发者选项 &gt; USB 调试 电脑与手机 USB 线连接，确保执行 adb devices 可以找到设备 ID 界面转至微信跳一跳游戏，点击开始游戏 以管理员身份打开cmd，并进入项目目录，运行 python wechat_jump_auto.py ，如果手机弹出界面显示 USB 授权，请点击确认 请按照你的机型或手机分辨率从 ./config/ 文件夹找到相应的配置，把对应的 config.json里面的内容 拷贝到default.json 如果屏幕分辨率能成功探测，会直接调用 config 目录的配置，不需要复制 优先按机型去找，找不到再按分辨率 如果都没有请找一个接近的自己的分辨率，或者调节一下找到合适的参数 如果运行很完美请忽略以下内容，尽量不要刷到1000分以上，容易被微信关小黑屋 接下来讲解怎么调参数，用记事本或其他编译器打开wechat_jump_auto.py读完开头就能大概了解参数配置1234567891011121314# DEBUG 开关，需要调试的时候请改为 True，不需要调试的时候为 FalseDEBUG_SWITCH = True //记得改True哦，会记录截图和log(不过一般截图识别的中心点是没问题的)。调好了在改回false# Magic Number，不设置可能无法正常执行，请根据具体截图从上到下按需# 设置，设置保存在 config 文件夹中config = config.open_accordant_config()under_game_score_y = config['under_game_score_y']# 长按的时间系数，请自己根据实际情况调节 这里就是关键了press_coefficient = config['press_coefficient']# 二分之一的棋子底座高度，可能要调节piece_base_height_1_2 = config['piece_base_height_1_2']# 棋子的宽度，比截图中量到的稍微大一点比较安全，可能要调节piece_body_width = config['piece_body_width'] 知道该怎么做后在去修改default.json。如果你的机型有对应的配置文件，请改对应的那个。1234567&#123; \"under_game_score_y\": 300, \"press_coefficient\": 1.392, // 这个就是我们要调整的参数了 \"piece_base_height_1_2\": 20, \"piece_body_width\": 70&#125;修改press_coefficient的值，调的小跳的近，调的大跳的远。边改边测试哦。对了，结束python脚本运行是Ctrl+C哦。 适度游戏，健康生活，快去学习！","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"python","slug":"python","permalink":"https://www.hojun.cn/tags/python/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"每日签到","slug":"每日签到","date":"2017-12-30T04:08:23.000Z","updated":"2018-08-11T15:24:46.369Z","comments":true,"path":"2017/12/30/每日签到/","link":"","permalink":"https://www.hojun.cn/2017/12/30/每日签到/","excerpt":"","text":"You can either travel or read,but either your body or soul must be on the way读书是为了心平气和地跟傻逼说话,健身是为了让傻逼心平气和的和你说话穿衣瘦，脱衣肉坚持！一切成就都缘于一个梦想和毫无根据的自信。 18/5/10 没锻炼。。。 18/5/9 哑铃侧平举-20 哑铃推举-20 哑铃前平举-20 18/5/8 俯卧撑-240 平板支撑-3m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/5/7 没锻炼。。。 18/5/6 俯卧撑-240 平板支撑-3m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/5/5 没锻炼。。。 18/5/4 没锻炼。。。 18/5/3 没锻炼。。。 18/5/2 俯卧撑-240 平板支撑-3m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/5/1 俯卧撑-240 平板支撑-3m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/30 俯卧撑-240 平板支撑-3m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/29 俯卧撑-240 平板支撑-3m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/28 没锻炼。。。 18/4/27 温州出差 18/4/26 温州出差 18/4/25 休息 18/4/24 俯卧撑-240 平板支撑-3m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/23 烫伤休息 18/4/22 锻炼 烫伤休息 18/4/21 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/20 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/19 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/18 锻炼 俯卧撑-240 平板支撑-3m 18/4/17 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/16 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/15 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/14 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/13 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/11 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/10 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/9 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/8 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/7 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/6 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-2 18/4/5 锻炼 俯卧撑-240 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/4 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/3 锻炼 哈哈哈，晚八点半小憩一会睡过头了，没有锻炼 18/4/2 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/4/1 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/31 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/30 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/29 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/28 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/27 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/26 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/25 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/24 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/23 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/21 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/18 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/17 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/16 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/15 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/14 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/13 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/12 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/11 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/10 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/9 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/8 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/7 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/6 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/5 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/4 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/3 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/2 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/3/1 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/28 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/27 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/26 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/25 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/24 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/23 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/22 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/21 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/20 锻炼 俯卧撑-210 平板支撑-3m 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/19 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/18 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/17 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/16 哑铃增加到6KG 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/15 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/14 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/13 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/12 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/11 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/10 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/9 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/8 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/7 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/6 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/5 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/4 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/3 锻炼 俯卧撑-200 平板支撑-3m 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/2 锻炼 俯卧撑-200 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/2/1 锻炼 俯卧撑-200 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 曲臂伸-20 18/1/31 锻炼 俯卧撑-200 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 18/1/30 锻炼 俯卧撑-200 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 18/1/29 锻炼 俯卧撑-200 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 18/1/28 锻炼 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 18/1/27 锻炼 暂停哑铃耸肩，影响美 俯卧撑-200 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 锤式弯举-20 哑铃前平举-20 哑铃划船-20 18/1/26 锻炼 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-20 锤式弯举-20 哑铃前平举-20 18/1/25 锻炼 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-20 锤式弯举-20 哑铃前平举-20 18/1/24 锻炼 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-20 锤式弯举-20 哑铃前平举-20 18/1/23 锻炼 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-20 锤式弯举-20 哑铃前平举-20 18/1/22 锻炼 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-20 锤式弯举-20 哑铃前平举-20 18/1/21 锻炼 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-20 锤式弯举-20 哑铃前平举-20 18/1/20 锻炼 俯卧撑-200 18/1/19 锻炼 坚持 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-20 锤式弯举-20 哑铃前平举-20 18/1/18 锻炼 坚持 俯卧撑-200 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-20 锤式弯举-20 直立拉举哑铃-20 交替前平举-10 18/1/17 锻炼 俯卧撑-150 慢跑-5m 哑铃侧平举-20 交替哑铃弯举-30 哑铃推举-20 哑铃耸肩-20 锤式弯举-10 直立拉举哑铃-20 交替前平举-10 18/1/16 锻炼 俯卧撑-150 慢跑-5m 哑铃侧平举-10 交替哑铃弯举-30 哑铃推举-20 哑铃耸肩-20 锤式弯举-10 直立拉举哑铃-20 交替前平举-10 俯卧侧平举-10 哑铃划船-10 哑铃飞鸟-10 18/1/15 锻炼 俯卧撑-150 哑铃侧平举-10 交替哑铃弯举-30 哑铃推举-10 哑铃耸肩-10 锤式弯举-10 直立拉举哑铃-10 交替前平举-10 18/1/14 锻炼 俯卧撑-150 慢跑-5m 哑铃侧平举-10 交替哑铃弯举-30 哑铃推举-20 哑铃耸肩-30 锤式弯举-10 直立拉举哑铃-20 交替前平举-10 18/1/13 锻炼 俯卧撑-150 慢跑-8m 哑铃侧平举-10 交替哑铃弯举-20 哑铃推举-20 哑铃耸肩-30 锤式弯举-10 直立拉举哑铃-20 18/1/12 锻炼 腿好软 俯卧撑-150 深蹲-40 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-10 哑铃耸肩-10 锤式弯举-20 交替前平举-10 直立拉举哑铃-10 18/1/11 锻炼 感冒还没好 俯卧撑-150 深蹲-40 慢跑-8m 哑铃侧平举-20 交替哑铃弯举-20 哑铃推举-10 哑铃耸肩-20 锤式弯举-20 交替前平举-10 18/1/10 锻炼 俯卧撑-150 深蹲-40 慢跑-8m 哑铃侧平举-10 交替哑铃弯举-20 哑铃推举-10 哑铃耸肩-10 锤式弯举-10 交替前平举-10 直立拉举哑铃-10 18/1/9 锻炼 俯卧撑-100 深蹲-40 慢跑-8m 哑铃侧平举-10 交替哑铃弯举-10 哑铃推举-20 附身侧平举-10 哑铃划船-10 锤式弯举-10 18/1/8 锻炼 哑铃到了 俯卧撑-100 深蹲-40 慢跑-8m 哑铃侧平举-10 哑铃前平举-10 哑铃弯举-20 18/1/7 锻炼 俯卧撑-100 深蹲-80 18/1/6 锻炼 俯卧撑-100 深蹲-50 慢跑-5m 18/1/5 锻炼 俯卧撑-100 深蹲-50 慢跑-5m 18/1/4 锻炼 俯卧撑-100 深蹲-50 慢跑-5m 18/1/3 锻炼 俯卧撑-100 深蹲-50 慢跑-5m 18/1/2 锻炼 俯卧撑-100 深蹲-40 慢跑-5m 18/1/1 锻炼 俯卧撑-100 深蹲-40 慢跑-5m 17/12/31 锻炼 俯卧撑-100 深蹲-40 慢跑-5m 17/12/30 锻炼 俯卧撑-100 深蹲-30 慢跑-5m 17/12/29 锻炼 俯卧撑-100 17/12/28 锻炼 俯卧撑-100 深蹲-40 慢跑-5m 17/12/27 锻炼 俯卧撑-100 深蹲-30 慢跑-5m 17/12/26 锻炼 俯卧撑-100 深蹲-30 慢跑-5m 17/12/25 锻炼 俯卧撑-100 慢跑-5m 17/12/24 锻炼 俯卧撑-100 深蹲40 慢跑-5m","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"锻炼","slug":"锻炼","permalink":"https://www.hojun.cn/tags/锻炼/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"圣诞快乐！","slug":"圣诞快乐！","date":"2017-12-25T14:26:28.000Z","updated":"2018-08-11T15:24:45.637Z","comments":true,"path":"2017/12/25/圣诞快乐！/","link":"","permalink":"https://www.hojun.cn/2017/12/25/圣诞快乐！/","excerpt":"","text":"$(document).snowfall('clear'); $(document).snowfall({round:true, minSize:1, maxSize:5, flakeCount:100}); 献上jquery雪花插件snowfall.jquery.js","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"Lozad.js学习使用","slug":"Lozad-js学习使用","date":"2017-11-15T10:39:54.000Z","updated":"2018-08-11T15:24:48.948Z","comments":true,"path":"2017/11/15/Lozad-js学习使用/","link":"","permalink":"https://www.hojun.cn/2017/11/15/Lozad-js学习使用/","excerpt":"","text":"github地址lozad.js前几天在公众号上看到github上一些受欢迎的项目，其中就有lozad.js,据说碾压jquery.lazyload.js。而自己也一直想给自己博客添加惰性加载以提高页面打开速度（没办法，git略卡，aplayer音乐播放器和cnzz统计都被舍弃了） 介绍使用请参照github上的README.md中的Usage，英文实在看不懂可以参照sf的这篇文章《lozad.js：懒加载神器》，以及阮老师的文章 实战-给主题添加首先给列表页面（category-items.ejs）加上了对应的class和data-src，然后在layout.ejs里面加上了1234$(function () &#123; const observer = lozad(); observer.observe();&#125;); 测试通过。 实战-修改代码使hexo生成的img加上class和data-src列表页是在模板（themes）来编写的，自然能找到对应的img元素代码，给其加上class和data-src并不是难事。接下来遇到了个问题，要给文章中的图片也加上对应的class和data-src就不容易了。因为文章的内容是在hexo的变量中, 全局变量 变量 描述 site 网站变量 page 针对该页面的内容以及 front-matter 所设定的变量。 config 网站配置 theme 主题配置。继承自网站配置。 _ (单下划线) Lodash 函数库 path 当前页面的路径（不含根路径） url 当前页面的完整网址 env 环境变量 页面变量 变量 描述 page.title 页面标题 page.date 页面建立日期（Moment.js 对象） page.updated 页面更新日期（Moment.js 对象） page.comments 留言是否开启 page.layout 布局名称 page.content 页面的完整内容 page.excerpt 页面摘要 page.more 除了页面摘要的其余内容 page.source 页面原始路径 page.full_source 页面的完整原始路径 page.path 页面网址（不含根路径）。我们通常在主题中使用 url_for(page.path)。 page.permalink 页面的完整网址 page.prev 上一个页面。如果此为第一个页面则为 null。 page.next 下一个页面。如果此为最后一个页面则为 null。 page.raw 文章的原始内容 page.photos 文章的照片（用于相簿） page.link 文章的外部链接（用于链接文章） 其中page.content就是文章的内容了，接下来就是找到hexo是在哪里把markdown解释成html了。推荐一篇《hexo是怎么工作的》，可惜没有讲到对应的源代码，不过受他启发，去找对应的源代码。一开始觉得大概率是在生成的时候解析的，于是在这几个generator的文件夹中找？怎么找，sublime中右键[图片上传失败…(image-67a3c5-1510805619540)]选择Find in Folder就行，我选择查找的关键字是&lt;img src=,可惜没有找到对应的源码。接着在渲染的这几个renderer文件夹中找,其实看文件夹名就能看出端倪，hexo-renderer-ejs对应ejs,hexo-renderer-stylus对应syl,hexo-renderer-marked对应markdown咯。打开对应的README.md就看见你这么一句1Add support for [Markdown]. This plugin uses [marked] as render engine. 看来是找到了。查找发现真正的位置在这里，\\node_modules\\_marked@0.3.6@marked\\lib\\marked.js在这个js中解析的markdown,接下来就好办了，把对应解析图片那段代码添加class和data-src即可。修改好记得12hexo cleanhexo g 清空重新生成一下。ok,文章图片也实现了惰性加载","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"},{"name":"js","slug":"js","permalink":"https://www.hojun.cn/tags/js/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"hexo 使用说明","slug":"hexo-使用说明","date":"2017-10-22T16:04:35.000Z","updated":"2018-08-11T15:24:48.515Z","comments":true,"path":"2017/10/23/hexo-使用说明/","link":"","permalink":"https://www.hojun.cn/2017/10/23/hexo-使用说明/","excerpt":"","text":"//新建文章hexo n “文章名”//重新生成hexo g//提交hexo d//备份hexo b","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"PHP模拟登陆","slug":"PHP模拟登陆","date":"2017-10-22T15:53:05.000Z","updated":"2018-08-11T15:24:49.270Z","comments":true,"path":"2017/10/22/PHP模拟登陆/","link":"","permalink":"https://www.hojun.cn/2017/10/22/PHP模拟登陆/","excerpt":"","text":"//保持一个会话//F12中的preserve log记得勾选，（页面刷新不会清空Network）//打码可以使用打码兔12345678910111213141516171819202122232425262728293031323334353637function login_get($url, $httpHeader)&#123; $curl = curl_init();//初始化curl模块 curl_setopt($curl, CURLOPT_URL, $url);//登录提交的地址 curl_setopt($curl,CURLOPT_HEADER,1); //显示响应头header信息 curl_setopt($curl, CURLOPT_NOBODY, 1); //不显示显示文档document信息 curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); //返回数据不直接输出 curl_setopt($curl, CURLOPT_ENCODING, \"gzip\"); //指定gzip压缩，返回乱码时使用 $Cookie = 'Cookie:name=1;session_id=2;'; $header4 = array( 'Accept:image/webp,image/*,*/*;q=0.8', 'Accept-Encoding:gzip, deflate, sdch, br', 'Accept-Language:zh-CN,zh;q=0.8', 'Connection:keep-alive', $Cookie, 'Host:www.xxx.com', 'Referer:www.xxx.com', 'User-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36', ); curl_setopt($curl, CURLOPT_HTTPHEADER, $httpHeader); //指定请求头 // curl_setopt($curl, CURLOPT_COOKIEJAR, dirname(__FILE__).'/cookie_xm.cookie');//连接结束后，比如，调用 curl_close 后，保存 cookie 信息在指定的文件中。 // curl_setopt($curl, CURLOPT_COOKIEFILE, $cookieFile); //读取cookie 参数为文件地址 // curl_setopt($curl, CURLOPT_COOKIE, $cookieStr); //读取cookie 参数为字符串 curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); //SSL 报错时使用 curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); //SSL 报错时使用 $rs = curl_exec($curl);//执行cURL // curl_setopt($curl, CURLINFO_HEADER_OUT, TRUE); //打印请求头 // $request= curl_getinfo($curl); //得到请求头 // file_put_contents(\"./request.txt\", $request['request_header'].PHP_EOL, FILE_APPEND); //要提交的信息 file_put_contents(\"./login.txt\", $rs.PHP_EOL, FILE_APPEND); preg_match('/cookiename=(.*);/iU',$rs,$pass_trace);//正则匹配到需要的cookie // file_put_contents(\"./rs.txt\", $str.PHP_EOL, FILE_APPEND); curl_close($curl);//关闭cURL资源，并且释放系统资源 return cookiename[0];&#125; 分离curl header和body123456789...$rs = curl_exec($curl);//执行cURL//CURLINFO_HEADER_SIZE获取header的size去截取if (curl_getinfo($curl, CURLINFO_HTTP_CODE) == '200') &#123; $headerSize = curl_getinfo($curl, CURLINFO_HEADER_SIZE); $header = substr($rs, 0, $headerSize); $body = substr($rs, $headerSize);&#125;... post方式提交1234567$post2 = array ( 'user' =&gt; 'hojun', 'pwd' =&gt; '123456',);curl_setopt($curl, CURLOPT_POST, 1);//post方式提交 //http_build_query 使用给出的关联（或下标）数组生成一个经过 URL-encode 的请求字符串curl_setopt($curl, CURLOPT_POSTFIELDS, http_build_query($post));","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.hojun.cn/tags/php/"},{"name":"模拟登陆","slug":"模拟登陆","permalink":"https://www.hojun.cn/tags/模拟登陆/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"excel笔记","slug":"excel笔记","date":"2017-10-15T18:21:34.000Z","updated":"2018-08-11T15:24:48.326Z","comments":true,"path":"2017/10/16/excel笔记/","link":"","permalink":"https://www.hojun.cn/2017/10/16/excel笔记/","excerpt":"","text":"最近学了一波excel两表查询2.使用公式 VLOOKUP 填好点确定 内容如下： 查找值：选择’所属渠道’列 数据表：选择关联表 列序数：10(对应 xxxxcccc字段) 匹配条件：0(0:精确查找 1:模糊查找) 快捷操作1.选中两列，ctrl+shift+↓2.ctrl+G -&gt; 空值 -&gt; =ctrl+上一个单元格 -&gt; ctrl+Enter","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"给博客添加APlayer音乐播放器^-^","slug":"给博客添加APlayer音乐播放器","date":"2017-09-12T17:09:56.000Z","updated":"2018-08-11T15:24:46.903Z","comments":true,"path":"2017/09/13/给博客添加APlayer音乐播放器/","link":"","permalink":"https://www.hojun.cn/2017/09/13/给博客添加APlayer音乐播放器/","excerpt":"","text":"传送门效果如右下角，稍微改了下作者的css。 略卡，作用不大，已弃用","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"网页引导-Jquerypagewalkthrough.js","slug":"网页引导-Jquerypagewalkthrough-js","date":"2017-09-06T15:23:16.000Z","updated":"2018-08-11T15:24:47.227Z","comments":true,"path":"2017/09/06/网页引导-Jquerypagewalkthrough-js/","link":"","permalink":"https://www.hojun.cn/2017/09/06/网页引导-Jquerypagewalkthrough-js/","excerpt":"","text":"效果预览碰见网页引导功能的需求，于是收到了Jquerypagewalkthrough.js这个插件，在github上下载到源码，英文渣很尴尬，找啊找啊找。终于找到篇中文的博客教程：来源helloweba.com 作者：月光光 第一步 在需要引导的页面head部分加入css和js12345&lt;link rel=\"stylesheet\" href=\"./css/jquery.pagewalkthrough.css\"&gt;&lt;!-- jQuery --&gt;&lt;script type=\"text/javascript\" src=\"./jquery-2.1.1.js\"&gt;&lt;/script&gt;&lt;!-- Page walkthrough plugin（插件） --&gt;&lt;script type=\"text/javascript\" src=\"./jquery.pagewalkthrough.min.js\"&gt;&lt;/script&gt; 第二步 在body的最后加上引导的内容123456789101112131415161718192021222324&lt;style type=\"text/css\"&gt; #walkthrough-content&#123;display:none&#125;&lt;/style&gt;&lt;div id=\"walkthrough-content\"&gt; &lt;div id=\"walkthrough-1\"&gt; &lt;h3&gt;jquerypagewalkthrough&lt;br&gt;简单使用&lt;/h3&gt; &lt;/div&gt; &lt;div id=\"walkthrough-2\"&gt; &lt;h3&gt;下,博客的导航栏&lt;/h3&gt; &lt;h3&gt;bottom,blog navigation bar&lt;/h3&gt; &lt;/div&gt; &lt;div id=\"walkthrough-3\"&gt; &lt;h3&gt;右,博客的logo&lt;/h3&gt; &lt;h3&gt;right,bolg logo&lt;/h3&gt; &lt;/div&gt; &lt;div id=\"walkthrough-4\"&gt; &lt;h3&gt;上,博客的底部&lt;/h3&gt; &lt;h3&gt;top,blog footer&lt;/h3&gt; &lt;/div&gt; &lt;div id=\"walkthrough-5\"&gt; &lt;h3&gt;左,博客切换白天还是黑夜模式&lt;/h3&gt; &lt;h3&gt;left,blog sun and moon switch&lt;/h3&gt; &lt;/div&gt; &lt;/div&gt; 第三步 jquery调用pagewalkthroughsteps是一个数组，定义每一步引导调用的内容，参数wrapper定义了当前引导对应的元素位置(wrapper中的值就是css选择器)，参数popup定义弹出提示引导层，参数content定义关联的内容元素，参数type定义弹出方式，包括tooltip和modal以及nohighlight三种方式，参数position定义了弹出层位置，包括top,left, right or bottom。12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; $(function() &#123; $('body').pagewalkthrough(&#123; name: 'introduction', steps: [&#123; popup: &#123; content: '#walkthrough-1', type: 'modal' &#125; &#125;, &#123; wrapper: '.page-title ul', popup: &#123; content: '#walkthrough-2', type: 'tooltip', position: 'bottom' &#125; &#125;, &#123; wrapper: '.avatar', popup: &#123; content: '#walkthrough-3', type: 'tooltip', position: 'right' &#125; &#125;, &#123; wrapper: '.footer-inner', popup: &#123; content: '#walkthrough-4', type: 'tooltip', position: 'top' &#125; &#125;, &#123; wrapper: '.fa.fa-sun-o', popup: &#123; content: '#walkthrough-5', type: 'tooltip', position: 'left' &#125; &#125;] &#125;); $('body').pagewalkthrough('show'); &#125;);&lt;/script&gt; 代码下载demo.zip","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://www.hojun.cn/tags/jquery/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"浏览器的同源策略","slug":"浏览器的同源策略","date":"2017-08-14T15:47:36.000Z","updated":"2018-08-11T15:24:46.482Z","comments":true,"path":"2017/08/14/浏览器的同源策略/","link":"","permalink":"https://www.hojun.cn/2017/08/14/浏览器的同源策略/","excerpt":"","text":"转自MDN同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。 一个源的定义如果协议，端口（如果指定了一个）和域名对于两个页面是相同的，则两个页面具有相同的源。 下表给出了相对http://store.company.com/dir/page.html同源检测的示例: URL 结果 原因 http://store.company.com/dir2/other.html 成功 http://store.company.com/dir/inner/another.html 成功 https://store.company.com/secure.html 失败 不同协议 ( https和http ) http://store.company.com:81/dir/etc.html 失败 不同端口 ( 81和80) http://news.company.com/dir/other.html 失败 不同域名 ( news和store ) 另请参见文件的源定义: URLs. 源的继承来自about：blank和javascript：URL的内容从加载URL的文档继承原始文档，因为URL本身不提供任何有关原点的信息。 data：URLs获得一个新的，空的安全上下文。 注意：在Gecko 6.0之前，如果用户在位置栏中输入data URLs，data URLs 将继承当前浏览器窗口中网页的安全上下文。 IE 例外当涉及到同源策略时，Internet Explorer有两个主要的例外 授信范围（Trust Zones）：两个相互之间高度互信的域名，如公司域名（corporate domains），不遵守同源策略的限制。 端口：IE未将端口号加入到同源策略的组成部分之中，因此 http://company.com:81/index.html和http://company.com/index.html 属于同源并且不受任何限制。这些例外是非标准的，其它浏览器也未做出支持，但会助于开发基于window RT IE的应用程序。 源的更改页面可能会更改其自己的来源，但有一些限制。脚本可以将 document.domain 的值设置为其当前域或其当前域的超级域。如果将其设置为其当前域的超级域，则较短的域将用于后续原始检查。例如，假设文档中的一个脚本在 http://store.company.com/dir/other.html 执行以下语句：1document.domain = \"company.com\"; 这条语句执行之后，页面将会成功地通过对 http://company.com/dir/page.html 的同源检测。而同理，company.com 不能设置 document.domain 为 othercompany.com. 浏览器单独保存端口号。任何的赋值操作，包括document.domain = document.domain都会以null值覆盖掉原来的端口号。因此company.com:8080页面的脚本不能仅通过设置document.domain = “company.com”就能与company.com通信。赋值时必须带上端口号，以确保端口号不会为null。 注意：使用document.domain允许子域安全访问其父域时，您需要设置document.domain在父域和子域中具有相同的值。这是必要的，即使这样做只是将父域设置回其原始值。否则可能会导致权限错误。 跨源网络访问同源策略控制了不同源之间的交互，例如在使用XMLHttpRequest 或 标签时则会受到同源策略的约束。交互通常分为三类： 通常允许进行跨域写操作（Cross-originwrites）。例如链接（links），重定向以及表单提交。特定少数的HTTP请求需要添加 preflight。 通常允许跨域资源嵌入（Cross-origin embedding）。之后下面会举例说明。 通常不允许跨域读操作（Cross-originreads）。但常可以通过内嵌资源来巧妙的进行读取访问。例如可以读取嵌入图片的高度和宽度，调用内嵌脚本的方法，或availabilityof an embedded resource. 以下是可能嵌入跨源的资源的一些示例：123456789&lt;script src=\"...\"&gt;&lt;/script&gt;标签嵌入跨域脚本。语法错误信息只能在同源脚本中捕捉到。 &lt;link rel=\"stylesheet\" href=\"...\"&gt;标签嵌入CSS。由于CSS的松散的语法规则，CSS的跨域需要一个设置正确的Content-Type消息头。不同浏览器有不同的限制： IE, Firefox, Chrome, Safari (跳至CVE-2010-0051)部分 和 Opera。 &lt;img&gt;嵌入图片。支持的图片格式包括PNG,JPEG,GIF,BMP,SVG,... &lt;video&gt; 和 &lt;audio&gt;嵌入多媒体资源。 &lt;object&gt;, &lt;embed&gt; 和 &lt;applet&gt;的插件。@font-face引入的字体。一些浏览器允许跨域字体（ cross-origin fonts），一些需要同源字体（same-origin fonts）。 &lt;frame&gt; 和 &lt;iframe&gt;载入的任何资源。站点可以使用X-Frame-Options消息头来阻止这种形式的跨域交互。如何允许跨源访问使用 CORS 允许跨源访问。 如何阻止跨源访问 阻止跨域写操作，只要检测请求中的一个不可测的标记(CSRF token)即可，这个标记被称为Cross-Site RequestForgery (CSRF) 标记。必须使用这个标记来阻止页面的跨站读操作。 阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。 阻止跨站嵌入，确保你得资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守Conten-Type消息头。例如，如果你在&lt;script&gt;标签中嵌入HTML文档，浏览器仍将HTML解析为Javascript。Whenyour resource is not an entry point to your site, you can also use aCSRF token to prevent embedding. 跨源脚本API访问Javascript的APIs中，如 iframe.contentWindow, window.parent, window.open 和 window.opener 允许文档间直接相互引用。当两个文档的源不同时，这些引用方式将对 Window 和 Location对象的访问添加限制。可以使用window.postMessage 作为替代方案，提供跨域文档间的通讯。 窗口规范: http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-window. 允许以下对窗口属性的跨源访问： Methods window.blur window.close window.focus window.postMessage Attributes window.closed 只读. window.frames 只读. window.length 只读. window.location 读/写. window.opener 只读. window.parent 只读. window.self 只读. window.top 只读. window.window 只读. 某些浏览器允许访问比规范允许的更多属性。 位置Specification: http://www.whatwg.org/specs/web-apps/current-work/multipage/browsers.html#security-location. 允许以下对位置属性的跨源访问： Methods location.replace Attributes URLUtils.href 只写. 某些浏览器允许访问比规范允许的更多属性 跨源数据存储访问存储在浏览器中的数据，如localStorage和IndexedDB，以源进行分割。每个源都拥有自己单独的存储空间，一个源中的Javascript脚本不能对属于其它源的数据进行读写操作。 window.name属性可以用来临时存储数据，可以跨域访问。 Cookies使用不同的源定义方式。一个页面可以为本域和任何父域设置cookie，只要是父域不是公共后缀（public suffix）即可。Firefox和Chrome使用Public Suffix List决定一个域是否是一个公共后缀（public suffix）。不管使用哪个协议（HTTP/HTTPS）或端口号，浏览器都允许给定的域以及其任何子域名(sub-domains)来访问cookie。设置cookie时，你可以使用Domain，Path，Secure，和Http-Only标记来限定其访问性。读取cookie时，不会知晓它的出处。尽管使用安全的https连接，任何可见的cookie都是使用不安全的连接设置的。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"实现侧边栏固定 滚到底部后停止","slug":"实现侧边栏固定-滚到底部后停止","date":"2017-08-09T15:55:22.000Z","updated":"2018-08-11T15:24:45.704Z","comments":true,"path":"2017/08/09/实现侧边栏固定-滚到底部后停止/","link":"","permalink":"https://www.hojun.cn/2017/08/09/实现侧边栏固定-滚到底部后停止/","excerpt":"","text":"侧边栏固定？很简单的能想到是用position: fixed;实现。怎么实现下滑到底部footer页面停止固定效果呢。解决方案：在到达底部的时候取消fixed固定定位换absolute绝对定位代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;html&gt;&lt;body&gt; &lt;div style=\"position: relative; width: 200px; height: 2000px; border: 1px solid; display: inline-block;\"&gt; &lt;div class=\"left\" style=\" border: 0px solid; width: 200px; height: 600px; background: red;\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=\"width: 600px; height: 2000px; border: 1px solid; display: inline-block;\"&gt; &lt;/div&gt; &lt;div class=\"footer\" style=\"width: 100%; height: 200px; border: 1px solid;\"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script type=\"text/javascript\" src=\"js/jquery-2.1.4.min.js\"&gt;&lt;/script&gt;&lt;style type=\"text/css\"&gt; .fixed&#123; position: fixed; top:0px; &#125; .abs&#123; position: absolute; bottom:0px; &#125;&lt;/style&gt;&lt;script type=\"text/javascript\"&gt; $(document).ready(function()&#123; var loaded = true; var loaded2 = true; var top = $(\".left\").offset().top; var height = $(\".left\").outerHeight(true) + $(\".footer\").outerHeight(true); console.log(height); var down = $(document).height() - top - height; function Add_Data() &#123; var scrolla=$(window).scrollTop(); var cha=parseInt(top)-parseInt(scrolla); var chb=parseInt(down)-parseInt(scrolla); console.log(chb); if(loaded &amp;&amp; cha&lt;=0) &#123; $(\".left\").addClass(\"fixed\"); loaded=false; &#125; if(!loaded &amp;&amp; cha&gt;0) &#123; $(\".left\").removeClass(\"fixed\"); loaded=true; &#125; if(loaded2 &amp;&amp; chb&lt;=0) &#123; $(\".left\").removeClass(\"fixed\"); $(\".left\").addClass(\"abs\"); loaded2=false; &#125; if(!loaded2 &amp;&amp; chb&gt;0) &#123; $(\".left\").removeClass(\"abs\"); $(\".left\").addClass(\"fixed\"); loaded2=true; &#125; &#125; $(window).scroll(Add_Data); &#125;); &lt;/script&gt; &lt;/html&gt;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Mysql 5.7.19 For Windows 安装+修改密码","slug":"Mysql-5-7-19-For-Windows-安装-修改密码","date":"2017-08-09T15:50:45.000Z","updated":"2018-08-11T15:24:49.103Z","comments":true,"path":"2017/08/09/Mysql-5-7-19-For-Windows-安装-修改密码/","link":"","permalink":"https://www.hojun.cn/2017/08/09/Mysql-5-7-19-For-Windows-安装-修改密码/","excerpt":"","text":"新版Mysql5.7会为root@localhost用户创建一个随机密码，这个随机密码在不同系统上需要使用不同方式查找，否则无法登录mysql并修改初始密码。（我想吐槽这么坑人的功能是程序员还是产品经理的锅）今天安装了个mysql5.7版本，然后我居然不知道初始的登录密码？？？我都怀疑是不是自己亲手安装的。（5.7很皮…）接下来修改初始密码又踩了好多坑(我从未见过对用户如此不友好之数据库)，网上搜了好多教程，试了各种方法。最后总结出一份简洁的方法。特此记录：安装包是mysql-5.7.19-win32.msi 第一步 》安装自定义安装到D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7 第二步 》添加my.ini文件安装成功后在安装目录下(D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7)添加my.ini文件12345[mysqld]port=3306basedir=D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\datadir=D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\dataskip-grant-tables 第三步 》初始化Mysql+修改密码以管理员身份运行cmd,cd到mysql的bin下执行12345678910111213141516171819202122232425262728293031323334D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7&gt;cd binD:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\bin&gt;mysqld.exe -installService successfully installed.D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\bin&gt;mysqld --initialize-insecureD:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\bin&gt;net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\bin&gt;mysql -u root -pEnter password:(注释：直接回车)Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 3Server version: 5.7.19 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.mysql&gt; use mysqlDatabase changedmysql&gt; update user set authentication_string = password('root'), password_expired = 'N', password_last_changed = now() where user = 'root';Query OK, 1 row affected, 1 warning (0.02 sec)Rows matched: 1 Changed: 1 Warnings: 1mysql&gt; exitBye 注：如果服务起不来，检查下有开启其他的mysql服务，导致端口被占用，比如mysql5.6 第四步 》重启服务，配置和修改生效修改my.ini文件1234[mysqld]port=3306basedir=D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\datadir=D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\data 再重启1234567891011121314151617181920212223D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\bin&gt;net stop mysqlMySQL 服务正在停止.MySQL 服务已成功停止。D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\bin&gt;net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。D:\\Program Files (x86)\\Mysql5.7\\MysqlServer5.7\\bin&gt;mysql -u root -pEnter password:(注释：输入root)Welcome to the MySQL monitor. Commands end with ; or \\g.Your MySQL connection id is 4Server version: 5.7.19 MySQL Community Server (GPL)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement.","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.hojun.cn/tags/mysql/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"chrome启动参数","slug":"chrome启动参数","date":"2017-07-30T15:28:16.000Z","updated":"2018-08-11T15:24:48.213Z","comments":true,"path":"2017/07/30/chrome启动参数/","link":"","permalink":"https://www.hojun.cn/2017/07/30/chrome启动参数/","excerpt":"","text":"","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"PHP根据url批量下载图片","slug":"PHP根据url批量下载图片","date":"2017-07-20T16:08:46.000Z","updated":"2018-08-11T15:24:49.248Z","comments":true,"path":"2017/07/21/PHP根据url批量下载图片/","link":"","permalink":"https://www.hojun.cn/2017/07/21/PHP根据url批量下载图片/","excerpt":"","text":"123456789101112&lt;?php$imgArr = array('https://wx1.sinaimg.cn/large/006bYVyvgy1fhoaywi4qaj307g037q2r.jpg','https://wx3.sinaimg.cn/large/006bYVyvgy1fhoaytokqnj308o02g3yd.jpg','https://wx4.sinaimg.cn/large/006bYVyvgy1fhf69hzfxej30ip09lmxs.jpg','https://wx3.sinaimg.cn/large/006bYVyvgy1fhf7a6r8ykj30jy0lcac0.jpg',);$count = count($imgArr);foreach ($imgArr as $key =&gt; $url) &#123; $content = file_get_contents($url); file_put_contents($key.'.jpg', $content);&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"利用ajax偷懒-批量操作","slug":"利用ajax偷懒-批量操作","date":"2017-07-19T15:47:25.000Z","updated":"2018-08-11T15:24:45.093Z","comments":true,"path":"2017/07/19/利用ajax偷懒-批量操作/","link":"","permalink":"https://www.hojun.cn/2017/07/19/利用ajax偷懒-批量操作/","excerpt":"","text":"批量查询等不举例了","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"mysql报字符集错误","slug":"mysql报字符集错误","date":"2017-07-18T12:14:09.000Z","updated":"2018-08-11T15:24:49.136Z","comments":true,"path":"2017/07/18/mysql报字符集错误/","link":"","permalink":"https://www.hojun.cn/2017/07/18/mysql报字符集错误/","excerpt":"","text":"今天碰到个这么个报错：1Illegal mix of collations (utf8_unicode_ci,IMPLICIT) and (utf8_general_ci,IMPLICIT) for operation '=' [ SQL语句 ] : 看报错信息好像是字符集不一致查看了下表 SHOW TABLE STATUS FROM 数据库名 LIKE ‘表名’;没问题，可能是字段字符不一样show full columns from 表名; 或者 show create table 表名;12345678CREATE TABLE `user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `user_phone` varchar(200) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '手机号', `user_pwd` varchar(50) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '登陆密码', `create_time` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '创建时间', `last_logtime` varchar(255) CHARACTER SET utf8 COLLATE utf8_unicode_ci DEFAULT NULL COMMENT '最后一次登录时间', PRIMARY KEY (`user_id`)) ENGINE=MyISAM AUTO_INCREMENT=32 DEFAULT CHARSET=utf8 发现原因 解决1ALTER TABLE user CONVERT TO CHARACTER SET utf8 COLLATE utf8_general_ci","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.hojun.cn/tags/mysql/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"js点击复制功能实现","slug":"js点击复制功能实现","date":"2017-07-17T14:06:13.000Z","updated":"2018-08-11T15:24:48.770Z","comments":true,"path":"2017/07/17/js点击复制功能实现/","link":"","permalink":"https://www.hojun.cn/2017/07/17/js点击复制功能实现/","excerpt":"","text":"今天实现了了下js复制功能参照https://developer.mozilla.org/zh-CN/docs/Web/API/Document/execCommand#命令 实现代码1234567891011121314151617181920212223242526272829303132333435&lt;meta charset=\"utf-8\"&gt;&lt;!-- 记得导入jquery --&gt;&lt;script src=\"http://cdn.static.runoob.com/libs/jquery/1.10.2/jquery.min.js\"&gt;&lt;a class=\"copy_url_a\" style=\"cursor: pointer;\"&gt;复制链接&lt;/a&gt;&lt;textarea style=\"opacity: 0; z-index: -1; position: absolute; left: 0px;\" class=\"copy_url_input\"&gt;http://www.baidu.co1m&lt;/textarea&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $('.copy_url_a').click(function()&#123; var textarea_url = $(this).siblings('.copy_url_input').get(0); console.log(textarea_url); var currentFocus = document.activeElement; textarea_url.select(); document.execCommand(\"copy\") currentFocus.focus(); alert(\"已复制好，可贴粘。\"); &#125;) &#125;)&lt;/script&gt; &lt;a class=\"copy_url_a\" style=\"cursor: pointer;\"&gt;复制链接&lt;/a&gt;&lt;input style=\"opacity: 0; z-index: -1; position: absolute; left: 0px;\" class=\"copy_url_input\" value=\"http://www.baidu.co2m\"&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $('.copy_url_a').click(function()&#123; var inputText = $(this).siblings('.copy_url_input').get(0); var currentFocus = document.activeElement; inputText.focus(); inputText.setSelectionRange(0, inputText.value.length); document.execCommand('copy'); currentFocus.focus(); &#125;) &#125;)&lt;/script&gt; 注意：Firefox不能document.execCommand(‘copy’, true);这样写 select方法 参考w3c select()方法用于选取密码域中的文本。 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function selText() &#123; document.getElementById('password1').select() &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input type=\"password\" id=\"password1\" value=\"thgrt456\" /&gt; &lt;input type=\"button\" onclick=\"selText()\" value=\"Select text\" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; select() 方法用于选择该元素中的文本。 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function selText() &#123; document.getElementById(\"txt1\").select() &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;textarea id=\"txt1\"&gt;Hello world....&lt;/textarea&gt; &lt;input type=\"button\" value=\"Select text\" onclick=\"selText()\"&gt; &lt;/body&gt;&lt;/html&gt; select()方法用于选取文本域中的内容。 12345678910111213141516&lt;html&gt; &lt;head&gt; &lt;script type=\"text/javascript\"&gt; function selText() &#123; document.getElementById(\"myText\").select() &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;input size=\"25\" type=\"text\" id=\"myText\" value=\"A cat played with a ball\"&gt; &lt;input type=\"button\" value=\"Select text\" onclick=\"selText()\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; setSelectionRange方法The HTMLInputElement.setSelectionRange()方法可以设置一个 input 元素中的文本选中内容的起始位置和结束位置。 在较新的浏览器中，你可以通过一个可选的参数来指定文本被被选中过程中的方向。比如通过点击和拖动从结束位置往起始位置选中一个字符串。 每次调用这个这个方法会更新HTMLInputElement.selectionStart, selectionEnd, 和 selectionDirection 这3条属性。 语法EDIT1inputElement.setSelectionRange(selectionStart, selectionEnd, [optional] selectionDirection); 参数 selectionStart 被选中的第一个字符的位置。 selectionEnd 被选中的最后一个字符的 下一个 位置。 selectionDirection (可选) 一个指明选择方向的字符串，有”forward”,”backward”和”none”3个可选值, 分别表示”从前往后”, “从后往前”和”选择方向未知或不重要”。 setSelectionRange方法当一个HTML文档切换到设计模式(designMode)时，文档对象暴露execCommand方法，该方法允许运行命令来操纵可编辑区域的内容。大多数命令影响文档的选择（粗体，斜体等），而其他命令插入新元素（添加链接）或影响整行（缩进）。当使用 contentEditable时，调用 execCommand() 将影响当前活动的可编辑元素。 语法EDIT1bool = document.execCommand(aCommandName, aShowDefaultUI, aValueArgument) 返回值一个 Boolean ，如果是 false 则表示操作不被支持或未被启用。 参数 aCommandName 一个 DOMString ，命令的名称。可用命令列表请参阅 命令 。 aShowDefaultUI 一个 Boolean 是否展示用户界面，一般为 false。Mozilla 没有实现。 aValueArgument 一些命令需要一些额外的参数值（如insertimage需要提供这个image的url）。默认为null。 命令 backColor 修改文档的背景颜色。在styleWithCss模式下，则只影响容器元素的背景颜色。这需要一个类型的字符串值作为参数传入。注意，IE浏览器用这个设置文字的背景颜色。 bold 开启或关闭选中文字或插入点的粗体字效果。IE浏览器使用 &lt;strong&gt;标签，而不是&lt;b&gt;标签。 contentReadOnly 通过传入一个布尔类型的参数来使能文档内容的可编辑性。(IE浏览器不支持) copy拷贝当前选中内容到剪贴板。启用这个功能的条件因浏览器不同而不同，而且不同时期，其启用条件也不尽相同。使用之前请检查浏览器兼容表，以确定是否可用。 createLink 将选中内容创建为一个锚链接。这个命令需要一个HREFURI字符串作为参数值传入。URI必须包含至少一个字符，例如一个空格。（浏览器会创建一个空链接） cut剪贴当前选中的文字并复制到剪贴板。启用这个功能的条件因浏览器不同而不同，而且不同时期，其启用条件也不尽相同。使用之前请检查浏览器兼容表，以确定是否可用。 decreaseFontSize 给选中文字加上 small 标签，或在选中点插入该标签。(IE浏览器不支持) delete 删除选中部分. enableInlineTableEditing 启用或禁用表格行和列插入和删除控件。(IE浏览器不支持) enableObjectResizing 启用或禁用图像和其他对象的大小可调整大小手柄。(IE浏览器不支持) fontName 在插入点或者选中文字部分修改字体名称. 需要提供一个字体名称字符串 (例如：”Arial”)作为参数。 fontSize 在插入点或者选中文字部分修改字体大小. 需要提供一个HTML字体尺寸 (1-7) 作为参数。 foreColor 在插入点或者选中文字部分修改字体颜色. 需要提供一个颜色值字符串作为参数。 formatBlock 添加一个HTML块式标签在包含当前选择的行, 如果已经存在了，更换包含该行的块元素 (在 Firefox中,BLOCKQUOTE 是一个例外 -它将包含任何包含块元素). 需要提供一个标签名称字符串作为参数。几乎所有的块样式标签都可以使用(例如.“H1”, “P”, “DL”, “BLOCKQUOTE”). (IE浏览器仅仅支持标题标签 H1 - H6, ADDRESS, 和PRE,使用时还必须包含标签分隔符 &lt; &gt;, 例如 “&lt;H1&gt;“.) forwardDelete 删除光标所在位置的字符。 和按下删除键一样。 heading 添加一个标题标签在光标处或者所选文字上。 需要提供标签名称字符串作为参数 (例如. “H1”, “H6”). (IE 和Safari不支持) hiliteColor 更改选择或插入点的背景颜色。需要一个颜色值字符串作为值参数传递。 UseCSS必须开启此功能。(IE浏览器不支持) increaseFontSize 在选择或插入点周围添加一个BIG标签。(IE浏览器不支持) indent 缩进选择或插入点所在的行， 在 Firefox 中, 如果选择多行，但是这些行存在不同级别的缩进, 只有缩进最少的行被缩进。 insertBrOnReturn 控制当按下Enter键时，是插入 br 标签还是把当前块元素变成两个。(IE浏览器不支持) insertHorizontalRule 在插入点插入一个水平线（删除选中的部分） insertHTML 在插入点插入一个HTML字符串（删除选中的部分）。需要一个个HTML字符串作为参数。(IE浏览器不支持) insertImage 在插入点插入一张图片（删除选中的部分）。需要一个image SRCURI作为参数。这个URI至少包含一个字符。空白字符也可以（IE会创建一个链接其值为null） insertOrderedList 在插入点或者选中文字上创建一个有序列表 insertUnorderedList 在插入点或者选中文字上创建一个无序列表。 insertParagraph 在选择或当前行周围插入一个段落。(IE会在插入点插入一个段落并删除选中的部分.) insertText 在光标插入位置插入文本内容或者覆盖所选的文本内容。 italic 在光标插入点开启或关闭斜体字。 (Internet Explorer 使用 EM 标签，而不是 I ) justifyCenter 对光标插入位置或者所选内容进行文字居中。 justifyFull 对光标插入位置或者所选内容进行文本对齐。 justifyLeft 对光标插入位置或者所选内容进行左对齐。 justifyRight 对光标插入位置或者所选内容进行右对齐。 outdent 对光标插入行或者所选行内容减少缩进量。 paste 在光标位置粘贴剪贴板的内容，如果有被选中的内容，会被替换。剪贴板功能必须在 user.js 配置文件中启用。参阅 [1]. redo 重做被撤销的操作。 removeFormat 对所选内容去除所有格式 selectAll 选中编辑区里的全部内容。 strikeThrough 在光标插入点开启或关闭删除线。 subscript 在光标插入点开启或关闭下角标。 superscript 在光标插入点开启或关闭上角标。 underline 在光标插入点开启或关闭下划线。 undo 撤销最近执行的命令。 unlink 去除所选的锚链接的标签 useCSS 切换使用 HTML tags 还是 CSS 来生成标记. 要求一个布尔值 true/false 作为参数。注:这个属性是逻辑上的倒退 (例如. use false to use CSS, true to useHTML).(IE不支持)该属性已经废弃，使用 styleWithCSS 代替。 styleWithCSS 用这个取代 useCSS 命令。 参数如预期的那样工作, i.e. truemodifies/generates 风格的标记属性, false 生成格式化元素。 例子123456789101112131415161718An example of how to use it on CodePen.快速实现复制到剪贴板：&lt;p&gt;点击复制后在右边textarea CTRL+V看一下&lt;/p&gt;&lt;input type=\"text\" id=\"inputText\" value=\"测试文本\"/&gt;&lt;input type=\"button\" id=\"btn\" value=\"复制\"/&gt;&lt;textarea rows=\"4\"&gt;&lt;/textarea&gt;&lt;script type=\"text/javascript\"&gt; var btn = document.getElementById('btn'); btn.addEventListener('click', function()&#123; var inputText = document.getElementById('inputText'); var currentFocus = document.activeElement; inputText.focus(); inputText.setSelectionRange(0, inputText.value.length); document.execCommand('copy', true); currentFocus.focus(); &#125;);&lt;/script&gt;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"解决父级元素不能被撑开","slug":"解决父级元素不能被撑开","date":"2017-07-12T15:10:32.000Z","updated":"2018-08-11T15:24:47.393Z","comments":true,"path":"2017/07/12/解决父级元素不能被撑开/","link":"","permalink":"https://www.hojun.cn/2017/07/12/解决父级元素不能被撑开/","excerpt":"","text":"今天在做静态页面的时候又碰见父级div元素heigh高度为0的情况，可是其下的子元素是有高度的。但是父元素没有被撑开。为啥？想到的第一个原因是box-sizing是border-box (w3c：为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。)改为 box-sizing: content-box;(w3c:在宽度和高度之外绘制元素的内边距和边框。)然后没啥用。想到这个问题之前也碰到过，可能是因为子元素浮动的原因。于是百度了一波清浮，找到了一篇教程http://www.divcss5.com/jiqiao/j406.shtml里面的问题和我遇见的完全一样，而且原因剖析的非常详细。于是把它记录下来： 一、浮动产生原因一般浮动是什么情况呢？一般是一个盒子里使用了CSS float浮动属性，导致父级对象盒子不能被撑开，这样CSS float浮动就产生了。 粗体本来两个黑色对象盒子是在红色盒子内，因为对两个黑色盒子使用了float浮动，所以两个黑色盒子产生了浮动，导致红色盒子不能撑开，这样浮动就产生了。 简单地说，浮动是因为使用了float:left或float:right或两者都是有了而产生的浮动。 二、浮动产生负作用1、背景不能显示由于浮动产生，如果对父级设置了（CSS background背景）CSS背景颜色或CSS背景图片，而父级不能被撑开，所以导致CSS背景不能显示。 2、边框不能撑开如果父级设置了CSS边框属性（css border），由于子级里使用了float属性，产生浮动，父级不能被撑开，导致边框不能随内容而被撑开。 3、margin padding设置值不能正确显示由于浮动导致父级子级之间设置了css padding、css margin属性的值不能正确表达。特别是上下边的padding和margin不能正确显示。 三、css解决浮动，清除浮动方法1、对父级设置适合CSS高度对父级设置适合高度样式清除浮动，这里对“.divcss5”设置一定高度即可，一般设置高度需要能确定内容高度才能设置。这里我们知道内容高度是100PX+上下边框为2px，这样具体父级高度为102px 小结，使用设置高度样式，清除浮动产生，前提是对象内容高度要能确定并能计算好。 2、clear:both清除浮动为了统一样式，我们新建一个样式选择器CSS命名为“.clear”，并且对应选择器样式为“clear:both”，然后我们在父级“”结束前加此div引入“class=”clear””样式。这样即可清除浮动。 这个css clear清除float产生浮动，可以不用对父级设置高度 也无需技术父级高度，方便适用，但会多加CSS和HTML标签。 3、父级div定义 overflow:hidden对父级CSS选择器加overflow:hidden样式，可以清除父级内使用float产生浮动。优点是可以很少CSS代码即可解决浮动产生。 为什么加入overflow:hidden即可清除浮动呢？那是因为overflow:hidden属性相当于是让父级紧贴内容，这样即可紧贴其对象内内容（包括使用float的div盒子），从而实现了清除浮动。Css overflow:hidden清除浮动方法DIVCSS5推荐使用。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"css","slug":"css","permalink":"https://www.hojun.cn/tags/css/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"逗比生活","slug":"逗比生活","date":"2017-07-10T15:38:10.000Z","updated":"2018-08-11T15:24:47.914Z","comments":true,"path":"2017/07/10/逗比生活/","link":"","permalink":"https://www.hojun.cn/2017/07/10/逗比生活/","excerpt":"","text":"1.this_is_my_secret_and_fuck_you_all2.由纪:”比起应该做的事，想做的事更重要。 “——《学园孤岛》 To Be Continued…","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"博客添加gitment评论","slug":"博客添加gitment评论","date":"2017-07-09T15:16:20.000Z","updated":"2018-08-11T15:24:45.504Z","comments":true,"path":"2017/07/09/博客添加gitment评论/","link":"","permalink":"https://www.hojun.cn/2017/07/09/博客添加gitment评论/","excerpt":"","text":"说起gitment全是泪啊~~~多说6月1号说拜拜，刚7月三号的时候换了网易云跟帖，今天早上就收到个坏消息：好吧，我再换参考gitment作者博客说明：https://imsun.net/posts/gitment-introduction/ 概括下使用说明 就两步就行 超简单1. 注册github OAuth Application在头像-&gt;setting下面得到owner、client_id、client_secret 注意填写：若是绑定个人域名就不能使用yourname.github.io作为Homepage URL和Authorization callback URL。gitment会报Error: Comments Not Initialized错误### 2. 引入 Gitment将下面的代码添加到你的页面：1234567891011121314&lt;div id=\"container\"&gt;&lt;/div&gt;&lt;link rel=\"stylesheet\" href=\"https://imsun.github.io/gitment/style/default.css\"&gt;&lt;script src=\"https://imsun.github.io/gitment/dist/gitment.browser.js\"&gt;&lt;/script&gt;&lt;script&gt;var gitment = new Gitment(&#123; id: '页面 ID', // 可选。默认为 location.href owner: '你的 GitHub ID', repo: '存储评论的 repo', oauth: &#123; client_id: '你的 client ID', client_secret: '你的 client secret', &#125;,&#125;)gitment.render('container')注意填写：参数错误会出现Error: Not Found报错 id可以直接删掉 repo只要填你的仓库名称就行，不用仓库的git或ssh。例如我的 repo: ‘honjun.github.io’, id=”container”和gitment.render(‘container’)最好改下，比如gitment-container以防id重复","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.hojun.cn/tags/hexo/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"按键精灵入门","slug":"按键精灵入门","date":"2017-07-07T15:16:37.000Z","updated":"2018-08-11T15:24:46.147Z","comments":true,"path":"2017/07/07/按键精灵入门/","link":"","permalink":"https://www.hojun.cn/2017/07/07/按键精灵入门/","excerpt":"","text":"一直想用按键精灵写一个脚本来提升自身的逼格。但是一直没多少时间学习它。抽空几个小时实战了一波模拟器上QQ登陆脚本的实现——超简单。工具： 夜神模拟器 按键精灵手机助手3.2 先简单的介绍下脚本流程 1.在手机桌面找到QQ的标，单击打开 2.在QQ界面找到登陆按钮，单击登录 3.在登陆界面找到QQ账号输入框，单击选择，输入账号 4.接着找到QQ密码输入宽，单击选择，输入密码 5.找到登陆按钮，点击登录 6.验证码。。。。目前能力无解（按键精灵初学小白一枚） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344//Dim 定义变量 array是多点的数据，具体怎么得到看说明Dim game = array(472,436,535,499,&quot;000000&quot;,&quot;0|0|000000,0|0|000000,0|0|000000,0|0|000000&quot;)Dim signIn = array(84,1148,291,1202,&quot;FFFFFF&quot;,&quot;10|1|FFFFFF,32|1|FFFFFF,44|5|FFFFFF,4|11|FFFFFF&quot;)//调用函数 找多点 找game那个点，即QQ图标Call 找多点(game, 1)//延迟3秒 等待3秒Delay 3000// 找登陆按钮 点击Call 找多点(signIn, 1)Delay 3000//找QQ账号输入框 单击Dim qqNo = array(38,274,125,308,&quot;D8D2D1&quot;,&quot;11|0|DBD6D6,26|-3|E0DAE3,33|8|DBD6D5,7|17|D7D2CF,29|17|D7D2CF&quot;)Call 找多点(qqNo, 1)//输入账号InputText &quot;123456789&quot;Delay 1000Dim qqMm = array(38,298,103,332,&quot;ECE9EF&quot;,&quot;5|0|ECE9EF,11|0|ECE9EF,33|-1|ECE9F0,42|11|ECE9F0,12|4|ECE9EF&quot;)//找QQ密码输入框 单击Call 找多点(qqMm, 1)//输入密码，以读取文件的方式InputText File.ReadLine(&quot;/sdcard/MobileAnjian/qqcount.txt&quot;, 1)Delay 1000//点击登录按钮Dim login = array(309,388,415,434,&quot;EFB522&quot;,&quot;19|-1|EFB522,35|4|F3CD6F,8|19|FFFFFF&quot;)Call 找多点(login, 1)//这是一个函数，找多点。模式=1是会单击找到的位置Function 找多点(数组, 模式) TracePrint &quot;dianjile&quot; 找多点 = False Dim arr,intX,intY arr = 数组 FindMultiColor arr(0), arr(1), arr(2), arr(3), arr(4), arr(5), 0, 0.9, intX, intY TracePrint intX&amp;intY If intX &gt; -1 Then 找多点 = True If 模式 = 1 Then Tap intX, intY TracePrint &quot;dianjile&quot; End If End IfEnd Function 以上代码关键就是如何获取多点的array数据 现在举个栗子我们来获取登陆这个按钮，因为颜色较浅，用一般的多点方法很容易检测失败，我们这里采用选择区域。第一补 打开抓抓第二步抓抓截屏获取到这个界面，接下来 1.点击选择区域 2.选择红色框那个范围，会在二值化得到3这样的结果 3.ctrl+滚轮 放大登录按钮 ，左键点击选点 选择文字的白色部分 配合ctrl+1/2/3/4/5/6得到6个点 4.点击开始检查，若返回-1，-1则表示。请重新操作步骤三。若返回一个位置（如345，789）则表示成功，点击复制完整脚本复制需要的array数据 3、4步骤的图如下：","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"搞事","slug":"搞事","permalink":"https://www.hojun.cn/tags/搞事/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"自定义菜单创建 —— 微信公众平台开发","slug":"自定义菜单创建 —— 微信公众平台开发","date":"2017-07-06T14:15:08.000Z","updated":"2018-08-11T15:24:47.326Z","comments":true,"path":"2017/07/06/自定义菜单创建 —— 微信公众平台开发/","link":"","permalink":"https://www.hojun.cn/2017/07/06/自定义菜单创建 —— 微信公众平台开发/","excerpt":"","text":"阅读文档自定义菜单窗口创建文档——传送门 注意：一级菜单不能超过3个。所以文档第二个例子要删掉几个一级菜单才可用。 自定义菜单最多包括3个一级菜单，每个一级菜单最多包含5个二级菜单。 一级菜单最多4个汉字，二级菜单最多7个汉字，多出来的部分将会以“…”代替。 创建自定义菜单后，菜单的刷新策略是，在用户进入公众号会话页或公众号profile页时，如果发现上一次拉取菜单的请求在5分钟以前，就会拉取一下菜单，如果菜单有更新，就会刷新客户端的菜单。测试时可以尝试取消关注公众账号后再次关注，则可以看到创建后的效果。 按钮json格式1234567891011121314151617181920212223242526272829&#123; \"button\":[ &#123; \"type\":\"click\", \"name\":\"今日歌曲\", \"key\":\"V1001_TODAY_MUSIC\" &#125;, &#123; \"name\":\"菜单\", \"sub_button\":[ &#123; \"type\":\"view\", \"name\":\"搜索\", \"url\":\"http://www.soso.com/\" &#125;, &#123; \"type\":\"miniprogram\", \"name\":\"wxa\", \"url\":\"http://mp.weixin.qq.com\", \"appid\":\"wx286b93c14bbf93aa\", \"pagepath\":\"pages/lunar/index\" &#125;, &#123; \"type\":\"click\", \"name\":\"赞一下我们\", \"key\":\"V1001_GOOD\" &#125;] &#125;]&#125; 参数 是否必须 说明 button 是 一级菜单数组，个数应为1~3个 sub_button 否 二级菜单数组，个数应为1~5个 type 是 菜单的响应动作类型，view表示网页类型，click表示点击类型，miniprogram表示小程序类型 name 是 菜单标题，不超过16个字节，子菜单不超过60个字节 key click等点击类型必须 菜单KEY值，用于消息接口推送，不超过128字节 url view、miniprogram类型必须 网页链接，用户点击菜单可打开链接，不超过1024字节。type为miniprogram时，不支持小程序的老版本客户端将打开本url。 media_id media_id类型和view_limited类型必须 调用新增永久素材接口返回的合法media_id appid miniprogram类型必须 小程序的appid（仅认证公众号可配置） pagepath miniprogram类型必须 小程序的页面路径 type类型： 1、click：点击推事件用户点击click类型按钮后，微信服务器会通过消息接口推送消息类型为event的结构给开发者（参考消息接口指南），并且带上按钮中开发者填写的key值，开发者可以通过自定义的key值与用户进行交互。2、view：跳转URL用户点击view类型按钮后，微信客户端将会打开开发者在按钮中填写的网页URL，可与网页授权获取用户基本信息接口结合，获得用户基本信息。3、scancode_push：扫码推事件用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后显示扫描结果（如果是URL，将进入URL），且会将扫码的结果传给开发者，开发者可以下发消息。4、scancode_waitmsg：扫码推事件且弹出“消息接收中”提示框用户点击按钮后，微信客户端将调起扫一扫工具，完成扫码操作后，将扫码的结果传给开发者，同时收起扫一扫工具，然后弹出“消息接收中”提示框，随后可能会收到开发者下发的消息。5、pic_sysphoto：弹出系统拍照发图用户点击按钮后，微信客户端将调起系统相机，完成拍照操作后，会将拍摄的相片发送给开发者，并推送事件给开发者，同时收起系统相机，随后可能会收到开发者下发的消息。6、pic_photo_or_album：弹出拍照或者相册发图用户点击按钮后，微信客户端将弹出选择器供用户选择“拍照”或者“从手机相册选择”。用户选择后即走其他两种流程。7、pic_weixin：弹出微信相册发图器用户点击按钮后，微信客户端将调起微信相册，完成选择操作后，将选择的相片发送给开发者的服务器，并推送事件给开发者，同时收起相册，随后可能会收到开发者下发的消息。8、location_select：弹出地理位置选择器用户点击按钮后，微信客户端将调起地理位置选择工具，完成选择操作后，将选择的地理位置发送给开发者的服务器，同时收起位置选择工具，随后可能会收到开发者下发的消息。9、media_id：下发消息（除文本消息）用户点击media_id类型按钮后，微信服务器会将开发者填写的永久素材id对应的素材下发给用户，永久素材类型可以是图片、音频、视频、图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。10、view_limited：跳转图文消息URL用户点击view_limited类型按钮后，微信客户端将打开开发者在按钮中填写的永久素材id对应的图文消息URL，永久素材类型只支持图文消息。请注意：永久素材id必须是在“素材管理/新增永久素材”接口上传后获得的合法id。 代码实现配置文件参照 消息加解密 —— 微信公众平台开发代码:使用方法 先在微信公众平台添加本地ip的白名单，然后本地访问localhost/tp/index.php/Wx/Admin/createMenu方法即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?phpnamespace Wx\\Controller;use Think\\Controller;class AdminController extends Controller &#123; private function getAccessToken() &#123; $appid = C('APPID'); $appsecret = C('APPSECRET'); $url = \"https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=$appid&amp;secret=$appsecret\"; $output = $this-&gt;https_request($url); $jsoninfo = json_decode($output, true); return $jsoninfo[\"access_token\"]; &#125; public function createMenu() &#123; $access_token = $this-&gt;getAccessToken(); $url = \"https://api.weixin.qq.com/cgi-bin/menu/create?access_token=\".$access_token; $jsonmenu = $this-&gt;getMenu(); $result = $this-&gt;https_request($url, $jsonmenu); var_dump($url); var_dump($result); &#125; private function https_request($url,$data = null)&#123; $curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $url); curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, false); if (!empty($data))&#123; curl_setopt($curl, CURLOPT_POST, true); curl_setopt($curl, CURLOPT_POSTFIELDS, $data); &#125; curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); $output = curl_exec($curl); curl_close($curl); return $output; &#125; private function getMenu() &#123; $jsonmenu = '&#123; \"button\":[ &#123; \"type\":\"click\", \"name\":\"今日歌曲\", \"key\":\"V1001_TODAY_MUSIC\" &#125;, &#123; \"name\":\"菜单\", \"sub_button\":[ &#123; \"type\":\"view\", \"name\":\"搜索\", \"url\":\"http://www.soso.com/\" &#125;, &#123; \"type\":\"miniprogram\", \"name\":\"wxa\", \"url\":\"http://mp.weixin.qq.com\", \"appid\":\"wx286b93c14bbf93aa\", \"pagepath\":\"pages/lunar/index\" &#125;, &#123; \"type\":\"click\", \"name\":\"赞一下我们\", \"key\":\"V1001_GOOD\" &#125;] &#125;] &#125;'; return $jsonmenu; &#125;&#125; 服务器端处理按钮事件的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155&lt;?phpnamespace Wx\\Controller;use Wx\\Controller\\AppBaseController;use Think\\Log;class IndexController extends Controller &#123; public function index() &#123; $echostr = I(\"get.echostr\"); if (empty($echostr)) &#123; $this-&gt;getWxCrypt(C('NEWENCODINGAESKEY')); $this-&gt;responseMsg(); &#125;else&#123; $this-&gt;valid(); &#125; &#125; //验证签名 private function valid() &#123; $echoStr = I(\"get.echostr\"); $signature = I(\"get.signature\"); $timestamp = I(\"get.timestamp\"); $nonce = I(\"get.nonce\"); $tmpArr = array(C('TOKEN'), $timestamp, $nonce); sort($tmpArr, SORT_STRING); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if($tmpStr == $signature)&#123; echo $echoStr; exit; &#125; &#125; //响应消息 private function responseMsg() &#123; $postData = $GLOBALS[\"HTTP_RAW_POST_DATA\"]; // $postData = file_get_contents(\"php://input\"); // 第三方收到公众号平台发送的消息 $msg = ''; $errCode = $this-&gt;wxCrypt-&gt;decryptMsg(I(\"get.msg_signature\"), I(\"get.timestamp\"), I(\"get.nonce\"), $postData, $msg); if ($errCode != 0) &#123; //尝试之前的encodingAESKey解密 $this-&gt;getWxCrypt(C('OLDENCODINGAESKEY')); $errCode = $this-&gt;wxCrypt-&gt;decryptMsg(I(\"get.msg_signature\"), I(\"get.timestamp\"), I(\"get.nonce\"), $postData, $msg); if ($errCode != 0) &#123; //解密失败 print(\"解密失败: \".$errCode . \"\\n\"); exit(); &#125; &#125; if (!empty($msg))&#123; $postObj = simplexml_load_string($msg, 'SimpleXMLElement', LIBXML_NOCDATA); $MsgType = trim($postObj-&gt;MsgType); //消息类型分离 switch ($MsgType) &#123; case \"text\": $result = $this-&gt;receiveText($postObj); break; case \"event\": $result = $this-&gt;receiveEvent($postObj); break; default: $result = \"unknown msg type: \".$MsgType; break; &#125; // $this-&gt;logger(\"T \\r\\n\".$result); echo $result; &#125;else &#123; echo \"\"; exit; &#125; &#125; //接收文本消息 private function receiveText($object) &#123; $keyword = trim($object-&gt;Content); $content = '这是文本消息'; $result = $this-&gt;transmitText($object, $content); return $result; &#125; //接收事件消息 private function receiveEvent($object) &#123; switch ($object-&gt;Event) &#123; case \"subscribe\": $content = \"welcome~\\n欢迎关注hojun微信公众号!\"; break; case \"CLICK\": switch ($object-&gt;EventKey) &#123; case \"V1001_TODAY_MUSIC\": $content = \"点击了今日歌曲\"; break; case \"V1001_GOOD\": $content = \"点击了赞一下我们\"; break; default: $content = \"点击菜单：\".$object-&gt;EventKey; break; &#125; break; default: $content = \"receive a new event: \".$object-&gt;Event; break; &#125; if (is_array($content))&#123; // $result = $this-&gt;transmitNews($object, $content); &#125;else&#123; $result = $this-&gt;transmitText($object, $content); &#125; return $result; &#125; //回复文本消息 private function transmitText($object, $content) &#123; if (!isset($content) || empty($content))&#123; return \"\"; &#125; $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content); $encryptMsg = ''; $errCode = $this-&gt;wxCrypt-&gt;encryptMsg($result, time(), $object-&gt;nonce, $encryptMsg); if ($errCode != 0) &#123; print(\"加密后: \" . $encryptMsg . \"\\n\"); &#125; return $encryptMsg; &#125; //获取WxCrypt对象 private function getWxCrypt($encodingAESKey) &#123; import('Vendor.Weixin.WXBizMsgCrypt'); $this-&gt;wxCrypt = new \\WXBizMsgCrypt(C('TOKEN'), $encodingAESKey, C('APPID')); &#125;&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"weixin","slug":"weixin","permalink":"https://www.hojun.cn/tags/weixin/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"消息加解密 —— 微信公众平台开发","slug":"消息加解密-——-微信公众平台开发","date":"2017-07-05T15:08:38.000Z","updated":"2018-08-11T15:24:46.514Z","comments":true,"path":"2017/07/05/消息加解密-——-微信公众平台开发/","link":"","permalink":"https://www.hojun.cn/2017/07/05/消息加解密-——-微信公众平台开发/","excerpt":"","text":"推荐 方倍工作室参照 http://www.cnblogs.com/txw1958/p/weixin-aes-encrypt-decrypt.html基于thinkphp3.2框架实现 第一步token验证 注意:上图的url地址对应index方法控制器代码：\\Wx\\Controller\\IndexController.class.php123456789101112131415161718192021222324252627282930&lt;?phpnamespace Wx\\Controller;use Think\\Controller;class IndexController extends Controller &#123; public function index() &#123; if (!isset($_GET['echostr'])) &#123; $this-&gt;getWxCrypt(); $this-&gt;responseMsg(); &#125;else&#123; $this-&gt;valid(); &#125; &#125; //验证签名 private function valid() &#123; $echoStr = I(\"get.echostr\"); $signature = I(\"get.signature\"); $timestamp = I(\"get.signature\"); $nonce = I(\"get.nonce\"); $tmpArr = array(C('TOKEN'), $timestamp, $nonce); sort($tmpArr, SORT_STRING); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if($tmpStr == $signature)&#123; echo $echoStr; exit; &#125; &#125;&#125;配置文件：\\Wx\\Conf\\config.php1234567&lt;?phpreturn array( //&apos;配置项&apos;=&gt;&apos;配置值&apos; // 加载扩展的微信配置文件 weixin.php &apos;LOAD_EXT_CONFIG&apos; =&gt; &apos;weixin&apos;,);\\Wx\\Conf\\weixin.php123456789&lt;?php//微信配置文件return array( &apos;TOKEN&apos; =&gt; &apos;你的token&apos;, &apos;APPID&apos; =&gt; &apos;你的APPID&apos;, &apos;APPSECRET&apos; =&gt; &apos;你的AppSecret&apos;, &apos;OLDENCODINGAESKEY&apos; =&gt; &apos;&apos;, &apos;NEWENCODINGAESKEY&apos; =&gt; &apos;你的EncodingAESKey&apos;,);验证成功即可提交配置## 第二步消息加解密控制器代码：注意：和之前代码有区别123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118&lt;?phpnamespace Wx\\Controller;use Wx\\Controller\\AppBaseController;class IndexController extends Controller &#123; protected $wxCrypt; public function index() &#123; $echostr = I(\"get.echostr\"); if (empty($echostr)) &#123; $this-&gt;getWxCrypt(C('NEWENCODINGAESKEY')); $this-&gt;responseMsg(); &#125;else&#123; $this-&gt;valid(); &#125; &#125; //验证签名 private function valid() &#123; $echoStr = I(\"get.echostr\"); $signature = I(\"get.signature\"); $timestamp = I(\"get.timestamp\"); $nonce = I(\"get.nonce\"); $tmpArr = array(C('TOKEN'), $timestamp, $nonce); sort($tmpArr, SORT_STRING); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if($tmpStr == $signature)&#123; echo $echoStr; exit; &#125; &#125; //响应消息 private function responseMsg() &#123; $postData = $GLOBALS[\"HTTP_RAW_POST_DATA\"]; // $postData = file_get_contents(\"php://input\"); // 第三方收到公众号平台发送的消息 $msg = ''; $errCode = $this-&gt;wxCrypt-&gt;decryptMsg(I(\"get.msg_signature\"), I(\"get.timestamp\"), I(\"get.nonce\"), $postData, $msg); if ($errCode != 0) &#123; //尝试之前的encodingAESKey解密 $this-&gt;getWxCrypt(C('OLDENCODINGAESKEY')); $errCode = $this-&gt;wxCrypt-&gt;decryptMsg(I(\"get.msg_signature\"), I(\"get.timestamp\"), I(\"get.nonce\"), $postData, $msg); if ($errCode != 0) &#123; //解密失败 print(\"解密失败: \".$errCode . \"\\n\"); exit(); &#125; &#125; if (!empty($msg))&#123; $postObj = simplexml_load_string($msg, 'SimpleXMLElement', LIBXML_NOCDATA); $MsgType = trim($postObj-&gt;MsgType); // if (($postObj-&gt;MsgType == \"event\") &amp;&amp; ($postObj-&gt;Event == \"subscribe\" || $postObj-&gt;Event == \"unsubscribe\"))&#123; //过滤关注和取消关注事件 // &#125;else&#123; // &#125; //消息类型分离 switch ($MsgType) &#123; case \"text\": $result = $this-&gt;receiveText($postObj); break; default: $result = \"unknown msg type: \".$MsgType; break; &#125; echo $result; &#125;else &#123; echo \"\"; exit; &#125; &#125; //接收文本消息 private function receiveText($object) &#123; $keyword = trim($object-&gt;Content); $content = \"这是个文本消息\"; $result = $this-&gt;transmitText($object, $content); return $result; &#125; //回复文本消息 private function transmitText($object, $content) &#123; if (!isset($content) || empty($content))&#123; return \"\"; &#125; $xmlTpl = \"&lt;xml&gt;&lt;ToUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/ToUserName&gt;&lt;FromUserName&gt;&lt;![CDATA[%s]]&gt;&lt;/FromUserName&gt;&lt;CreateTime&gt;%s&lt;/CreateTime&gt;&lt;MsgType&gt;&lt;![CDATA[text]]&gt;&lt;/MsgType&gt;&lt;Content&gt;&lt;![CDATA[%s]]&gt;&lt;/Content&gt;&lt;/xml&gt;\"; $result = sprintf($xmlTpl, $object-&gt;FromUserName, $object-&gt;ToUserName, time(), $content); $encryptMsg = ''; $errCode = $this-&gt;wxCrypt-&gt;encryptMsg($result, time(), $object-&gt;nonce, $encryptMsg); if ($errCode != 0) &#123; print(\"加密后: \" . $encryptMsg . \"\\n\"); &#125; return $encryptMsg; &#125; //获取WxCrypt对象 private function getWxCrypt($encodingAESKey) &#123; import('Vendor.Weixin.WXBizMsgCrypt'); $this-&gt;wxCrypt = new \\WXBizMsgCrypt(C('TOKEN'), $encodingAESKey, C('APPID')); &#125;&#125;注意：Vendor.Weixin.WXBizMsgCrypt是微信提供的加解密demo代码，自己集成到了tp的\\ThinkPHP\\Library\\Vendor\\Weixin\\下","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"weixin","slug":"weixin","permalink":"https://www.hojun.cn/tags/weixin/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"给博客添加https支持","slug":"给博客添加https支持","date":"2017-07-04T12:01:34.000Z","updated":"2018-08-11T15:24:46.937Z","comments":true,"path":"2017/07/04/给博客添加https支持/","link":"","permalink":"https://www.hojun.cn/2017/07/04/给博客添加https支持/","excerpt":"","text":"参照：https://zhuanlan.zhihu.com/p/22667528 前提要求: 个人域名 第一步注册cloudflare怎么注册？ 第二步AddSite传送门输入自己域名，一步一步往下走就行了。最后会出现并给你两个Nameservers地址，然后自己去域名提供商的地方去改(腾讯云在控制台有) 第三步开启小绿锁点击图标，SLL选择Full 第四步配置Page Rules点击上面那个Page Rules(漏斗)的小图片添加如下： OK，接下来就是等待小绿锁生效吧(时间比较长，明天在看吧)","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.hojun.cn/tags/blog/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"给博客添加网易云跟帖评论","slug":"给博客添加网易云跟帖评论","date":"2017-07-03T14:10:57.000Z","updated":"2018-08-11T15:24:47.114Z","comments":true,"path":"2017/07/03/给博客添加网易云跟帖评论/","link":"","permalink":"https://www.hojun.cn/2017/07/03/给博客添加网易云跟帖评论/","excerpt":"","text":"为啥使用网易云跟帖？多说不能用了，自己正好有个域名（注:网易云跟帖只能使用一级域名。[honjun.github.io这种是二级域名]） 第一步注册不告诉你 第二步填写站点信息 第三步获取代码 第四步使用代码在对应模板文件评论地方加上网易云跟帖的代码比如jsimple模板在\\themes\\jsimple\\layout_partial\\comments.ejs123456789101112&lt;% if (config.netease &amp;&amp; page.comments) &#123; %&gt; &lt;div id=\"cloud-tie-wrapper\" class=\"cloud-tie-wrapper\"&gt;&lt;/div&gt; &lt;script&gt; var cloudTieConfig = &#123; url: document.location.href, sourceId: \"\", productKey: \"&lt;%=config.netease %&gt;\", target: \"cloud-tie-wrapper\" &#125;; &lt;/script&gt; &lt;script src=\"https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js\"&gt;&lt;/script&gt;&lt;% &#125; %&gt; 为了方便，productKey写在hexo配置文件中12# 网易云跟帖netease: hahahahahahahahahahahaha 第四步优化css添加night版的css1234567891011121314151617181920212223242526272829303132333435.night-mode #yun-tie-sdk-wrap ,.night-mode #yun-tie-sdk-wrap .tie-title-bar .tie-title&#123; background: #373737; color: #b1b1b1;&#125;.night-mode #yun-tie-sdk-wrap .input-box &#123; border: solid 1px #3f3f3f;&#125;.night-mode #yun-tie-sdk-wrap .input-box.z-fcs&#123; border-color: #5f5f5f;&#125;.night-mode #yun-tie-sdk-wrap .tie-title-bar .active-wrap .tie-join-txt &#123; color: #b1b1b1;&#125;.night-mode #yun-tie-sdk-wrap .input-box .tie-submit-row &#123; position: relative; height: 40px; background-color: #3f3f3f;&#125;.night-mode #yun-tie-sdk-wrap .single-tie &#123; background-color: #3f3f3f; border-top: solid 1px #5f5f5f;&#125;.night-mode #yun-tie-sdk-wrap .single-tie:hover &#123; background-color: #5f5f5f;&#125;.night-mode #yun-tie-sdk-wrap .tie-tab-bar li.z-fcs &#123; border: solid 1px #5f5f5f; background-color: #3f3f3f;&#125;.night-mode #yun-tie-sdk-wrap .tie-tab-bar &#123; border-bottom: solid 1px #5f5f5f;&#125;.night-mode #yun-tie-sdk-wrap .no-more &#123; border-top: solid 1px #5f5f5f;&#125; 上面是pc版的，至于移动端 &gt;_&gt; 一个深坑。它html代码在跨域iframe中，当前域的css影响不到。博主这在试着用js解决这问题，目前只能先将就一下。by-17/7/3 To Be Continued","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.hojun.cn/tags/blog/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"给hexo的jsimple主题添加代码高亮","slug":"给hexo的jsimple主题添加代码高亮","date":"2017-07-02T15:13:33.000Z","updated":"2018-08-11T15:24:46.870Z","comments":true,"path":"2017/07/02/给hexo的jsimple主题添加代码高亮/","link":"","permalink":"https://www.hojun.cn/2017/07/02/给hexo的jsimple主题添加代码高亮/","excerpt":"","text":"周末在家无所事事，想起来博客代码块的高亮支持不是很好，于是根据作者推荐的hipaper去get。对比了Hipaper和Jsimple老半天有几点发现。 Jsimple使用ejs模板 Hipaper使用ejs模板，css采用stylus框架。&lt;之前只听说过less和sass,又涨姿势了~~~&gt; 在浏览器端f12审核元素发现两个模板生成的html元素有些区别。然后就花了大量时间去找hexo是怎么把代码块自动解析成对应的html代码的。后来在hexo群里求助得知由hexo自带highlight插件生成。这位热心的大神顺手帮我搞了高亮的css代码，之后也在jsimple仓库pr了代码。得到css后依据自己的博客进行些小改动，添加了night版。然后愉快的给博客添加了代码高亮。 注意配置文件这里：12345highlight: enable: true //开启高亮 line_number: true //显示行号 auto_detect: false tab_replace: 修改之后生效需要执行1234//清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo clean//重新生成hexo g 这里贴出代码仅供参考：自己改了些东西，不知道适不适用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321.markdown-body code,.markdown-body tt&#123; padding:0;padding-top:.2em;padding-bottom:.2em;margin:0;font-size:85%;background-color:rgba(0,0,0,0.04);border-radius:3px&#125;.markdown-body code::before,.markdown-body code::after,.markdown-body tt::before,.markdown-body tt::after&#123; letter-spacing:-0.2em;content:\"\\00a0\"&#125;.markdown-body code br,.markdown-body tt br&#123; display:none&#125;.markdown-body del code&#123; text-decoration:inherit&#125;.markdown-body pre&#123; word-wrap:normal&#125;.markdown-body pre&gt;code&#123; padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:transparent;border:0&#125;.markdown-body .highlight&#123; margin-bottom:16px&#125;.markdown-body .highlight pre&#123; margin-bottom:0;word-break:normal&#125;.markdown-body pre,.markdown-body .highlight &#123; background: #f8f8f8; margin: 15px 0; padding: 15px 20px; border-style: solid; border-color: #eef1f8; border-width: 1px 0; overflow: auto; color: #4d4d4c; line-height: 22.400000000000002px;&#125;.markdown-body .highlight .gutter pre,.markdown-body .gist .gist-file .gist-data .line-numbers &#123; color: #666; font-size: 0.85em;&#125;.markdown-body pre,.markdown-body code &#123; font-family: \"Source Code Pro\", Consolas, Monaco, Menlo, Consolas, monospace;&#125;.markdown-body code &#123; background: rgba(208,211,248,0.2); color: #333; padding: 0 0.3em;&#125;.markdown-body pre code &#123; background: none; text-shadow: none; padding: 0;&#125;.markdown-body .highlight pre &#123; border: none; margin: 0; padding: 0;&#125;.markdown-body .highlight table &#123; margin: 0; width: auto; border: none;&#125;.markdown-body .highlight td &#123; border: none; padding: 0;&#125;.markdown-body .highlight figcaption &#123; font-size: 0.85em; color: #8e908c; line-height: 1em; margin-bottom: 1em;&#125;.markdown-body .highlight figcaption:before,.markdown-body .highlight figcaption:after &#123; content: \"\"; display: table;&#125;.markdown-body .highlight figcaption:after &#123; clear: both;&#125;.markdown-body .highlight figcaption a &#123; float: right;&#125;.markdown-body .highlight .gutter pre &#123; text-align: right; padding-right: 20px;&#125;.markdown-body .highlight .line &#123; /*height: 22.400000000000002px;*/&#125;.markdown-body .highlight .line.marked &#123; background: #d6d6d6;&#125;.markdown-body .gist &#123; margin: 0 -20px; border-style: solid; border-color: #eef1f8; border-width: 1px 0; background: #f8f8f8; padding: 15px 20px 15px 0;&#125;.markdown-body .gist .gist-file &#123; border: none; font-family: \"Source Code Pro\", Consolas, Monaco, Menlo, Consolas, monospace; margin: 0;&#125;.markdown-body .gist .gist-file .gist-data &#123; background: none; border: none;&#125;.markdown-body .gist .gist-file .gist-data .line-numbers &#123; background: none; border: none; padding: 0 20px 0 0;&#125;.markdown-body .gist .gist-file .gist-data .line-data &#123; padding: 0 !important;&#125;.markdown-body .gist .gist-file .highlight &#123; margin: 0; padding: 0; border: none;&#125;.markdown-body .gist .gist-file .gist-meta &#123; background: #f8f8f8; color: #8e908c; font: 0.85em -apple-system, \"Arial\", BlinkMacSystemFont, \"Segoe UI\", \"Roboto\", \"Oxygen\", \"Ubuntu\", \"Cantarell\", \"Fira Sans\", \"Droid Sans\", \"Helvetica Neue\", sans-serif; text-shadow: 0 0; padding: 0; margin-top: 1em; margin-left: 20px;&#125;.markdown-body .gist .gist-file .gist-meta a &#123; color: color-link; font-weight: normal;&#125;.markdown-body .gist .gist-file .gist-meta a:hover &#123; text-decoration: underline;&#125;pre .comment,pre .title &#123; color: #8e908c; &#125;pre .variable,pre .attribute,pre .tag,pre .regexp,pre .ruby .constant,pre .xml .tag .title,pre .xml .pi,pre .xml .doctype,pre .html .doctype,pre .css .id,pre .css .class,pre .css .pseudo &#123; color: #c82829;&#125;pre .number,pre .preprocessor,pre .built_in,pre .literal,pre .params,pre .constant &#123; color: #fd971f;&#125;pre .class,pre .ruby .class .title,pre .css .rules .attribute &#123; color: #718c00;&#125;pre .string,pre .value,pre .inheritance,pre .header,pre .ruby .symbol,pre .xml .cdata &#123; color: #718c00;&#125;pre .css .hexcolor &#123; color: #3e999f;&#125;pre .function,pre .python .decorator,pre .python .title,pre .ruby .function .title,pre .ruby .title .keyword,pre .perl .sub,pre .javascript .title,pre .coffeescript .title &#123; color: #4271ae;&#125;pre .keyword,pre .javascript .function &#123; color: #8959a8;&#125;pre &#123; color: #525252;&#125;pre .function .keyword,pre .constant &#123; color: #0092db;&#125;pre .keyword,pre .attribute &#123; color: #f92672;&#125;pre .number,pre .literal &#123; color: #ae81ff;&#125;pre .tag,pre .tag .title,pre .change,pre .winutils,pre .flow,pre .lisp .title,pre .clojure .built_in,pre .nginx .title,pre .tex .special &#123; color: #2973b7;&#125;pre .symbol,pre .symbol .string,pre .value,pre .regexp &#123; color: #42b983;&#125;pre .title &#123; color: #a6e22e;&#125;pre .tag .value,pre .string,pre .subst,pre .haskell .type,pre .preprocessor,pre .ruby .class .parent,pre .built_in,pre .sql .aggregate,pre .django .template_tag,pre .django .variable,pre .smalltalk .class,pre .javadoc,pre .django .filter .argument,pre .smalltalk .localvars,pre .smalltalk .array,pre .attr_selector,pre .pseudo,pre .addition,pre .stream,pre .envvar,pre .apache .tag,pre .apache .cbracket,pre .tex .command,pre .prompt &#123; color: #42b983;&#125;pre .comment,pre .java .annotation,pre .python .decorator,pre .template_comment,pre .pi,pre .doctype,pre .shebang,pre .apache .sqbracket,pre .tex .formula &#123; color: #b3b3b3;&#125;pre .deletion &#123; color: #ba4545;&#125;pre .coffeescript .javascript,pre .javascript .xml,pre .tex .formula,pre .xml .javascript,pre .xml .vbscript,pre .xml .css,pre .xml .cdata &#123; opacity: 0.5;&#125;.night-mode .markdown-body h2&#123; border-color:#2f2f2f&#125;.night-mode .markdown-body hr&#123; background-color:#2f2f2f&#125;.night-mode .markdown-body,.night-mode .markdown-body p&#123; color:#999&#125;.night-mode .markdown-body a&#123; color:#3dbcf5&#125;.night-mode .markdown-body a:hover&#123; color:#4094c7&#125;.markdown-body figure,.markdown-body pre,.markdown-body code,.markdown-body tr,.markdown-body table,.markdown-body tbody,.markdown-body table td&#123; background-color:#f8f8f8;&#125;.night-mode figure,.night-mode pre,.night-mode code,.night-mode blockquote,.night-mode tr,.night-mode table,.night-mode tbody,.night-mode table td&#123; background-color:#555!important;border-color:#555!important;color:#fff!important;&#125;.night-mode blockquote&#123; border-color:#ddd!important;&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.hojun.cn/tags/blog/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"给博客添加个人域名","slug":"给博客添加自己的域名","date":"2017-07-01T13:45:49.000Z","updated":"2018-08-11T15:24:47.148Z","comments":true,"path":"2017/07/01/给博客添加自己的域名/","link":"","permalink":"https://www.hojun.cn/2017/07/01/给博客添加自己的域名/","excerpt":"","text":"1.购买域名本人是在腾讯云上买的域名传送门 2.域名解析登录后进入右上角管理中心选择域名服务-&gt;解析如图： 3.修改域名DNS注：需要修改域名DNS为：f1g1ns1.dnspod.net f1g1ns2.dnspod.net 立即修改 解析后需要等待一段时间才可生效（有快有慢） 4.添加CHAME文件最后在你的hexo博客目录里的themes目录下的source目录下添加一个CNAME文件，不带后缀，内容如下[写下你自己的域名]：1234//生成hexo g//pushhexo d","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.hojun.cn/tags/blog/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"php中功能强大的函数","slug":"php中功能强大的函数","date":"2017-06-30T12:50:44.000Z","updated":"2018-08-11T15:24:49.214Z","comments":true,"path":"2017/06/30/php中功能强大的函数/","link":"","permalink":"https://www.hojun.cn/2017/06/30/php中功能强大的函数/","excerpt":"","text":"To Be Continued。。。sprintf — Return a formatted stringsprintf ( string $format [, mixed $args [, mixed $... ]] )例子1234&lt;?php$format = 'The %2$s contains %1$d monkeys';echo sprintf($format, $num, $location);?&gt; chr — 返回指定的字符string chr ( int $ascii )返回相对应于 ascii 所指定的单个字符。此函数与 ord() 是互补的。例子12345$str = \"The string ends in escape: \";$str .= chr(27); /* 在 $str 后边增加换码符 *//* 通常这样更有用 */$str = sprintf(\"The string ends in escape: %c\", 27);?&gt; natsort — 用“自然排序”算法对数组排序bool natsort (array &amp;$array)本函数实现了一个和人们通常对字母数字字符串进行排序的方法一样的排序算法并保持原有键／值的关联，这被称为“自然排序”。本算法和通常的计算机字符串排序算法（用于 sort()）的区别见下面示例。 simplexml_load_string123456789101112131415161718192021222324//数组转XMLfunction arrayToXml($arr)&#123; $xml = \"&lt;xml&gt;\"; foreach ($arr as $key=&gt;$val) &#123; if (is_numeric($val))&#123; $xml.=\"&lt;\".$key.\"&gt;\".$val.\"&lt;/\".$key.\"&gt;\"; &#125;else&#123; $xml.=\"&lt;\".$key.\"&gt;&lt;![CDATA[\".$val.\"]]&gt;&lt;/\".$key.\"&gt;\"; &#125; &#125; $xml.=\"&lt;/xml&gt;\"; return $xml;&#125;//将XML转为arrayfunction xmlToArray($xml)&#123; //禁止引用外部xml实体 libxml_disable_entity_loader(true); $values = json_decode(json_encode(simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOCDATA)), true); return $values;&#125; curl1234567891011121314151617181920212223242526272829303132333435363738394041424344//curl实现Get和Post//Get方式实现public function curlByGet() &#123; $url = \"http://www.baidu.com\"; //初始化 $ch = curl_init(); //设置选项，包括URL curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_HEADER, false); //执行并获取HTML文档内容 $output = curl_exec($ch); //释放curl句柄 curl_close($ch); //打印获得的数据 print_r($output);&#125;//Post方式实现public function curlByPost() &#123; $url = \"http://www.baidu.com\"; $post_data = array (\"username\" =&gt; \"小明\",\"password\" =&gt; \"12345\"); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); // post数据 curl_setopt($ch, CURLOPT_POST, true); // post的变量 curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data); $output = curl_exec($ch); curl_close($ch); //打印获得的数据 print_r($output);&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.hojun.cn/tags/php/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"[转]正则表达式30分钟入门教程","slug":"转-正则表达式30分钟入门教程","date":"2017-06-29T14:07:36.000Z","updated":"2018-08-11T15:24:47.492Z","comments":true,"path":"2017/06/29/转-正则表达式30分钟入门教程/","link":"","permalink":"https://www.hojun.cn/2017/06/29/转-正则表达式30分钟入门教程/","excerpt":"","text":"","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"正则表达式小记","slug":"正则表达式小记","date":"2017-06-28T14:01:46.000Z","updated":"2018-08-11T15:24:46.314Z","comments":true,"path":"2017/06/28/正则表达式小记/","link":"","permalink":"https://www.hojun.cn/2017/06/28/正则表达式小记/","excerpt":"","text":"要求校验中文名校验银行卡号校验身份证号校验邮箱地址 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 判断是否为合法的中文名 * @param $name 名字 * @return bool */function isChineseName($name) &#123; if (preg_match('/^([\\xe4-\\xe9][\\x80-\\xbf]&#123;2&#125;)&#123;2,4&#125;$/', $name)) &#123; return true; &#125; else &#123; return false; &#125;&#125;/** * 判断是否为合法的银行卡号 * @param $banknum 银行卡号 * @return bool */function isBanknumByLuhm($banknum) &#123; $n = 0; for ($i = strlen($banknum); $i &gt;= 1; $i--) &#123; $index=$i-1; //偶数位 if ($i % 2==0) &#123; $n += $banknum&#123;$index&#125;; &#125; else &#123;//奇数位 $t = $banknum&#123;$index&#125; * 2; if ($t &gt; 9) &#123; $t = (int)($t/10)+ $t%10; &#125; $n += $t; &#125; &#125; return ($n % 10) == 0;&#125;/** * 判断是否为合法的身份证号码 * @param $idcard 身份证号 * @return bool */function isIdcard($idcard)&#123; if(strlen($idcard)==18)&#123; return $this-&gt;idcard_checksum18($idcard); &#125;elseif((strlen($idcard)==15))&#123; $idcard = $this-&gt;idcard_15to18($idcard); return $this-&gt;idcard_checksum18($idcard); &#125;else&#123; return false; &#125;&#125;// 计算身份证校验码，根据国家标准GB 11643-1999function idcard_verify_number($idcard_base) &#123; if(strlen($idcard_base)!=17)&#123; return false; &#125; //加权因子 $factor=array(7,9,10,5,8,4,2,1,6,3,7,9,10,5,8,4,2); //校验码对应值 $verify_number_list=array('1','0','X','9','8','7','6','5','4','3','2'); $checksum=0; for ($i=0; $i&lt;strlen($idcard_base); $i++) &#123; $checksum += substr($idcard_base, $i, 1) * $factor[$i]; &#125; $mod = $checksum % 11; $verify_number = $verify_number_list[$mod]; return $verify_number;&#125;// 将15位身份证升级到18位function idcard_15to18($idcard) &#123; if (strlen($idcard) != 15) &#123; return false; &#125; else &#123; // 如果身份证顺序码是996 997 998 999，这些是为百岁以上老人的特殊编码 if (array_search(substr($idcard,12,3), array('996','997','998','999')) !== false) &#123; $idcard = substr($idcard,0,6).'18'.substr($idcard,6,9); &#125;else&#123; $idcard = substr($idcard,0,6).'19'.substr($idcard,6,9); &#125; &#125; $idcard = $idcard.$this-&gt;idcard_verify_number($idcard); return $idcard;&#125;// 18位身份证校验码有效性检查function idcard_checksum18($idcard)&#123; if (strlen($idcard)!=18) &#123; return false; &#125; $idcard_base = substr($idcard,0,17); if ($this-&gt;idcard_verify_number($idcard_base) != strtoupper(substr($idcard,17,1))) &#123; return false; &#125; else &#123; return true; &#125;&#125; /** * 判断是否为合法的邮箱地址 * @param $email 邮箱地址 * @return bool */function isEmail($email) &#123; $pattern = \"/^([0-9A-Za-z\\\\-_\\\\.]+)@([0-9a-z]+\\\\.[a-z]&#123;2,3&#125;(\\\\.[a-z]&#123;2&#125;)?)$/i\"; if (preg_match($pattern, $email)) &#123; $reply = \"您输入的电子邮件地址合法&lt;br /&gt;&lt;br /&gt;\\n\"; $user_name = preg_replace($pattern ,\"$1\", $email); $domain_name = preg_replace($pattern ,\"$2\", $email); $reply .= \"用户名：\".$user_name.\"&lt;br /&gt;\\n\"; $reply .= \"域名：\".$domain_name.\"&lt;br /&gt;\\n\\n\"; return true; &#125; else &#123; $reply = \"您输入的电子邮件地址不合法\"; return false; &#125;&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"小测试题","slug":"小测试题","date":"2017-06-27T15:03:01.000Z","updated":"2018-08-11T15:24:45.738Z","comments":true,"path":"2017/06/27/小测试题/","link":"","permalink":"https://www.hojun.cn/2017/06/27/小测试题/","excerpt":"","text":"名称：图片上传简易处理描述：1、前端页面做一个上传图片的表单（不需要样式和其他功能），上传任意一张图片（不限大小，不限格式）；2、服务端php接收这张图片，然后进行以下三个操作1）将上传的这张原图保存到一个文件夹下；2）将上传的这张图片缩放到特定尺寸300px200px,并将缩放后的图片保存到文件夹下；（即图片的拉伸、缩放）；3）截取这张原图的中心300px200px区域，并将该区域保存成一张新图片放到文件夹下； 审核标准：前端上传一张任意图片，后端经过php接收处理后在对应的文件下生成三张图片，分别是原图、缩放的图、裁剪的图。 解决之道： imagecreatefromjpeg — 由文件或 URL 创建一个新图象。 imagecreatetruecolor — 新建一个真彩色图像 getimagesize — 取得图像大小 imagecopyresampled — 重采样拷贝部分图像并调整大小 imagejpeg — 输出图象到浏览器或文件。 详见php手册 上代码： index.html 123456789101112131415161718&lt;html lang=\"en\" style=\"overflow-x:visible;\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"keywords\" content=\"\"&gt; &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt; &lt;meta http-equiv=\"expires\" content=\"0\"&gt; &lt;/head&gt; &lt;body style=\"overflow-x:visible;\"&gt; &lt;form action=\"index.php\" enctype=\"multipart/form-data\" method=\"post\"&gt; &lt;label&gt;仅支持jpg格式图片&lt;/label&gt;&lt;br&gt; &lt;input type=\"file\" name=\"avatar\" accept=\"image/png,image/jpg,image/jpeg,imge/bmp,image/gif\"&gt; &lt;input type=\"submit\" value=\"提交\" name=\"\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; index.php12345678910111213141516171819202122232425262728293031&lt;?php$image = $_FILES['avatar'];if ($image['error'] == 4) &#123; echo \"请选择图片！\"; exit();&#125;if($image['error'] == UPLOAD_ERR_OK) &#123; $dest='static/img/'; if (!file_exists('static/img')) &#123; mkdir('static/img', 0777, true); &#125; // 保存完整图片 move_uploaded_file($image['tmp_name'], $dest.$image[\"name\"]); //保存缩放图 $src_image = imagecreatefromjpeg($dest.$image[\"name\"]); $dst_image = ImageCreateTrueColor(300, 200); $src_image_w = getimagesize($dest.$image[\"name\"])['0']; $src_image_h = getimagesize($dest.$image[\"name\"])['1']; imagecopyresampled($dst_image, $src_image, 0, 0, 0, 0, 300, 200, $src_image_w, $src_image_h); imagejpeg($dst_image, 'static/img/zoom_'.$image[\"name\"], 100); //保存截图 imagecopyresampled($dst_image, $src_image, 0, 0, $src_image_w/2-150, $src_image_h/2-100, 300, 200, 300, 200); imagejpeg($dst_image, 'static/img/center_'.$image[\"name\"], 100); //TODO保存图片路径到库 echo \"保存成功\";&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"php","slug":"php","permalink":"https://www.hojun.cn/tags/php/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"勿忘初心","slug":"勿忘初心","date":"2017-06-24T15:36:49.000Z","updated":"2018-08-11T15:24:45.403Z","comments":true,"path":"2017/06/24/勿忘初心/","link":"","permalink":"https://www.hojun.cn/2017/06/24/勿忘初心/","excerpt":"","text":"","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"},{"name":"情感","slug":"情感","permalink":"https://www.hojun.cn/tags/情感/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"关于此博客搭建","slug":"关于此博客搭建","date":"2017-06-18T15:39:18.000Z","updated":"2018-08-11T15:24:45.025Z","comments":true,"path":"2017/06/18/关于此博客搭建/","link":"","permalink":"https://www.hojun.cn/2017/06/18/关于此博客搭建/","excerpt":"","text":"第一步 环境参照简书这篇文章 20分钟教你使用hexo搭建github博客咳咳，对于小白好像挺烦的样子。需要git账号，本地电脑安装git,node.js,hexo等等。有机会再补上windows教程吧。不过和mac也差不了。 第二步 blog模板在HEXO官网Themes可以自己挑选喜欢的模板。该博客使用的模板为JSimple关于该模板使用注意 1.建议使用作者博客备份，在上面稍加修改地址：https://github.com/shuoit/blog 2.注意模板依赖 比如JSimple的依赖为1234567891011121314&quot;dependencies&quot;: &#123; &quot;hexo&quot;: &quot;^3.2.2&quot;, &quot;hexo-git-backup&quot;: &quot;^0.1.2&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.2.11&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;, &quot;hexo-server&quot;: &quot;^0.2.0&quot;, &quot;hexo-deployer-git&quot;: &quot;0.2.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-generator-json-content&quot;: &quot;^2.2.0&quot;&#125; 修改依赖后记得cmd到博客目录下1npm install","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"blog","slug":"blog","permalink":"https://www.hojun.cn/tags/blog/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"分享一些资源","slug":"分享一些资源","date":"2017-06-17T15:08:34.000Z","updated":"2018-08-11T15:24:45.070Z","comments":true,"path":"2017/06/17/分享一些资源/","link":"","permalink":"https://www.hojun.cn/2017/06/17/分享一些资源/","excerpt":"","text":"盘多多 网盘搜索神器 泰斗社区 一些U3D资源 17素材 css、js资源 开源中国-C在线工具 一些小工具 在线工具 一些小工具 ProcessOn 在线作图 设计导航 设计网站大全 第一ppt 免费的ppt模板下载 Open Access Library 学术搜索图书馆 teambition 团队协作工具 Font Awesome 一套绝佳的图标字体库和CSS框架 PassMark Software 电脑\\手机 CPU、显卡等排名","categories":[{"name":"资源","slug":"资源","permalink":"https://www.hojun.cn/categories/资源/"}],"tags":[{"name":"资源","slug":"资源","permalink":"https://www.hojun.cn/tags/资源/"}],"keywords":[{"name":"资源","slug":"资源","permalink":"https://www.hojun.cn/categories/资源/"}]},{"title":"摄像机跟随人物移动","slug":"摄像机跟随人物移动","date":"2017-06-16T15:48:13.000Z","updated":"2018-08-11T15:24:46.181Z","comments":true,"path":"2017/06/16/摄像机跟随人物移动/","link":"","permalink":"https://www.hojun.cn/2017/06/16/摄像机跟随人物移动/","excerpt":"","text":"Tip小技巧调整镜头：点击选中摄像机-&gt;GanmeObject-&gt;Align With View 解决方案：要摄像机跟随，其实就是在人物移动的时候即时更新摄像机和人物的位置偏移。即:摄像机.position = 人物.position + 人物和摄像机之间的位置偏移。 怎么得到位置偏移？ 用当前的 摄像机.position - 人物.position 得到 把摄像机拖入人物下。此时，摄像机的为人物的子物体，摄像机的position就是需要的位置偏移。注意：实际位置偏移 = 摄像机.position * 人物.Scale。 代码12345678910111213141516171819202122232425using System.Collections;using System.Collections.Generic;using UnityEngine;public class FollowTarget : MonoBehaviour &#123; //offset位置偏移，声明为public可以在unity中赋值 public Vector3 offset; //palyer表示要跟随的人物 private Transform player; // Use this for initialization void Start () &#123; //通过FindGameObjectWithTag方法得到人物。在Unity要给人物加上Player标签（Tag） player = GameObject.FindGameObjectWithTag(\"Player\").transform; &#125; // Update is called once per frame void Update () &#123; //实现摄像机跟随 transform.position = player.position + offset; &#125;&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://www.hojun.cn/tags/Unity/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"修复人物idle和run动画切换之间的延迟的Bug","slug":"修复人物idle和run动画切换之间的延迟的Bug","date":"2017-06-16T15:47:38.000Z","updated":"2018-08-11T15:24:51.316Z","comments":true,"path":"2017/06/16/修复人物idle和run动画切换之间的延迟的Bug/","link":"","permalink":"https://www.hojun.cn/2017/06/16/修复人物idle和run动画切换之间的延迟的Bug/","excerpt":"","text":"Bug描述：在动画切换的时候，idle动画不能灵敏的反应按键切换成run动画。导致快速 按下-&gt;释放 按键时，人物表现为idle动画平移效果。 解决之道 1.试着把切换动画的逻辑放到 FiexdUpdate 方法中。因为Update会在每次渲染新的一帧时，被调用。而FixedUpdate会在每个固定的时间间隔被调用，Update受当前渲染的物体和机器性能影响，有时快有时慢，帧率会变化，update被调用的时间间隔就发生变化。但是FixedUpdate则不受帧率的变化，它是以固定的时间间隔来被调用. 这个时间间隔怎么设置呢？：Edit-&gt;Project Setting-&gt;time下面的Fixed timestep。 尝试后发现和update没有明显的区别，反应还是不灵敏。2.于是仔细看了下Animator的参数：发现Has Exit Time被默认勾选上了。 查阅资料： Has Exit Time就是必须过度的时间，处于这个时间时，是不允许任何对动画的操作的。 找到原因，取消勾选。测试，动画切换灵敏流畅。","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"Unity","slug":"Unity","permalink":"https://www.hojun.cn/tags/Unity/"},{"name":"debug","slug":"debug","permalink":"https://www.hojun.cn/tags/debug/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"[转]睡眠与养生","slug":"转-睡眠与养生","date":"2017-06-11T14:58:16.000Z","updated":"2018-08-11T15:24:47.527Z","comments":true,"path":"2017/06/11/转-睡眠与养生/","link":"","permalink":"https://www.hojun.cn/2017/06/11/转-睡眠与养生/","excerpt":"","text":"By xishui一篇非常有名的文章，出处已不知道。 文章所说的未必全对，但是毕竟有可以借鉴之处；中医西医都有很多地方受到抨击，大家都是有判断能力的，自我感觉有道理的，不自觉的就向他讲的看齐了；扯淡的，看看笑笑就过了吧~ 一、睡眠的规则战国时名医文挚对齐威王说：“我的养生之道把睡眠放在头等位置，人和动物只有睡眠才生长，睡眠帮助脾胃消化食物，所以，所以睡眠是养生的第一大补，人一个晚上不睡觉，其损失一百天也难以恢复。” 晚21点到凌晨5点为有效睡眠时间。人是动物，和植物同属于生物，白天(凌晨5点到晚上21点)活动产生能量，晚上(21点到凌晨5点)开始进行细胞细胞分裂，把能量转化为新生的细胞，是人体细胞休养生息、推陈出新的时间，也是人随着地球旋转到背向太阳的一面。阴主静，是人睡眠的良辰，此时休息，才会有良好的身体和精神状态。这和睡觉多的婴儿长得胖、长得快，而爱闹觉的孩子发育不良是一样的道理。 睡觉是养生的一大功能，养就是用大量的健康细胞去取代腐败的细胞，如一夜睡不着就换不了新细胞。如果说白天消亡一百万个细胞，一晚上只补回来五十万个细胞，这时你的身体就会出现亏空，时间长了，人就糠了，像糠萝卜似的。为什么世上有百岁老人呢?因为他们每晚都在21点钟准时睡觉。 现实生活中，不少人有入睡难，睡眠质量不高的毛病。睡眠不好是一个综合性的问题，如肝火过盛，睡觉警觉;胃火过剩，睡觉不安;肝阴不足，睡觉劳累。 二、睡眠与疾病现代的生活习惯和生活方式给人们的身体带来了很多负面影响形成“四大病”：水果病、冰箱病、电视电脑病、熬夜病。肝脏有一特点：卧则回血，坐立向外供血。 子时(23：00—1：00)，23点胆经开了，如若不睡，大伤胆气。其实23点就是新的一天的开始，并不是0点 开始的，这是我们犯的误识。肝胆相表里，互为一家，由于十一脏腑皆取决于胆也，胆气一虚，全身脏腑功能下降，代谢力、免疫力纷纷下降，人体机能大大降低， 胆气支持中枢神经，胆气受伤易患各种精神疾病，比如抑郁症、精神分裂症、强迫症、躁动症等。子时胆要更换胆汁，胆经渐旺人如不卧，胆汁更替不利，过浓 而结晶成石，久之即得胆结石，如果把胆给摘了，一摘就胆怯了，全身的免疫力下降了50%以上，所以不能摘，要用它本系统的巨大潜能把它化掉。 丑时肝经最旺，丑时(1：00—3：00)不眠，肝无法解除掉有毒之物，产生新鲜血液，因藏血不利，面呈青色，久之易患各类肝病。现在有些人肝不太好，特别在欧洲平均4个 人就有一个大三阳或是小三阳，大都是因为违反自然规律过了子时不睡觉造成的。甲肝比较好治，乙肝就很难治。乙肝病毒携带者，是由于晚上经常不睡觉，人太虚 弱了，也就是说秩序太乱了，病毒已经到了细胞里了。也就是说乙肝的病毒已经到了细胞里面，但是现在它还没有能力造成肝炎，当人身体处于最薄弱的时候就形成 成肝炎，乙型肝炎就意味着将来40%——60%的肝硬化。聪明的人是应该了解天、地、人之间的关系，不聪明的人就是应该被淘汰的人。 垃圾睡眠给肝脏带来多大伤害？ 肝主疏泄，过子时不睡，可引起肝疏泄不利，肝气郁结，可见易怒，头痛头晕，眼红，眼痛，耳鸣，耳聋，胸肋胀痛，女性月经不调，便秘，也可引起肝气升发不足，人会目倦神疲，腰膝酸软，晕眩，失眠，惊悸，精神恍惚，重则会晕倒在大街上，不省人事。 肝有藏血、调节血液的功能，过子时不睡，会造成肝血不足，还会引起吐血、流鼻血、皮下出血、牙龈出血、眼底出血、耳出血等出血证状。 肝开窍于目，过子时不睡，易引起肝虚，则出现视力模糊、老花、夜盲、畏光、迎风流泪，等症状，还会形成青光眼、白内障、眼底动脉硬化、视网膜病变等眼疾。 肝主筋，其华在爪，过子时不睡觉，会引起肝血不足，就出现筋痛，麻木，屈伸困难，痉挛抽搐，易造成灰指甲，缺钙，髌骨软化，癫痫病，骨质疏松等症。 肝与心，过子时不睡觉，可引起肝血不足，由于心主一身之血脉，肝有储藏和调节血液的功能，会造成心脏供血不足，引起心慌、心颤等症状，严重的形成心脏病、高血压等心脑血管疾病。 肝与脾，过子时不睡觉，会引起肝胃不和，由于肝助脾胃消化，由于肝气太虚不能助脾胃消化，使人脾胃消化功能不好，表现为舌苔厚，长期以来会造成中气塌陷。 肝与肺，过子时不睡觉，无法滋阴潜阳，肝阴亏损，引起肝火过盛灼肺，出现干咳、或咳嗽、咳痰血等木火刑金的证状，易导致牛皮癣等各种皮肤病。 肝与肾，过子时不睡觉，肝虚导致肾亏，由于肝肾同源，容易造成生殖系统疾病、不育、骨病、牙病、脱发、糖尿病、肾衰竭等疾病。 三、睡眠的方法交通规则——你不懂就容易出事故。比如说，23点至凌晨3点为子丑时，胆肝经最活跃的时候，肝胆要回血，“躺下去回血，站起来供血”。如果你每晚22点钟左右躺下，静静得不要说话，到23点的时候，也就睡着了。肝胆开始回血，把有毒的血过滤掉，产生新鲜的血液，到一百岁也没有胆结石，也没有肝炎、囊肿一类的病。如果你天天熬夜到1点多，肝回不了血，有毒的血排不掉，新鲜的血生不成，胆又无法换胆汁，所以这些人容易得胆结石、囊肿、大三阳、小三阳各种病症。 在欧洲地区，平均四个人就有一个肝炎病毒携带者，这就叫不懂规则。睡前半小时最好不要讲话，睡觉的时候更不要说话，如一说话，肺经动，然后心经又动，(因为心肺共为上焦)人就容易进入兴奋状态，所以就很难入睡。 21：00—23：00为亥时。亥时三焦经旺，三焦通百脉。亥时入眠，百脉皆得濡养，故百岁老人得共同特点即21：00(亥时)之前入睡。女性若想长久的保持容颜娇好，应做到早睡早期。 睡觉要关窗，不能开风扇、不能开空调，人生病很多都与此有关，因为人在睡眠之中，气血流通缓慢，体温下降，人体会在表面形成一种阳 气层，这种阳气层它使人叫“鬼魅不侵”，什么意思呢，阳气足的人，不做恶梦，就是这种阳气，占了上风。开空调，开风扇，情况就不一样了，开窗户，窗户走的 是风，风入的是筋，如果开空调，也有风，风入筋，寒入骨，早上起来，身上发黄，脸发黄，脖子后面那条筋发硬，骨节酸痛，甚至有人就开始发烧，这就是风和寒 侵入到了筋和骨头里的缘故，这也就是气受伤了。如果说晚上睡觉不开窗，不开空调，不开风扇，连房门也关上，效果最好，如果热，把房门打开，把窗户关上，效 果就差了一点，但是他不至于第二天早上起来浑身乏力，后背僵硬. 有人把客厅的空调开开了，把卧室的门打开，和直接开空调睡觉是差不多的，开了空调以后，空调那个寒进了骨了，所以心里发冷，心在哪，心在脑髓，脑为髓之海，骨髓里有寒，那肯定心里就寒了，怎么办，补肾阳、补中气，什么时候补到心里不冷，烧就退了，寒走出去了。 睡觉要尽量早睡，睡得晚，伤了少阳之气，必然第二天是疲倦无力，要关上窗户，不开空调、电扇，保护阳气。 肝胆在下焦，如果胃出现问题的时候，他就会出现寝睡不安，一个是胃寒，如果这个人胃阳本来就不足，过多的喝绿茶，就会出现胃寒，胃寒的时候人是睡不好觉的，或者吃带泥沙之物过多，胃隐隐作寒，肯定是睡不好; 再一个是胃热，就是热气往上走，嘴里喘的都是热气，像这种情况也睡不好觉;再一个是胃燥，口干舌燥，胃里感觉到燥; 还有一个就是胃厚，气味的味，胃厚，这种情况就是吃了这种厚腻的味道，有人吃海鲜、吃鱼、吃炖鸡，味道好鲜美，吃多了，美味不可多用，这些东西在里面要稀释它，不稀释它，它在里面味太厚了，所以这个也睡不好觉; 再一个腹涨，腹是涨鼓鼓的，也睡不着，翻来覆去也睡不着;再一个是胃气太虚，冒冷汗，这也睡不好觉，这些原因都可能形成胃不宁，胃不宁就睡不好。 睡觉时要肢暖，四肢要暖，因为四肢是阳之本，这个大家都知道了，四肢不暖，肯定是肾阳不足，应该在睡觉之前把手脚捂暖，手脚和肚脐、背后的命门都要盖好。 睡眠法因人而异，下面介绍3种做法： 睡觉前简单的压腿，然后在床上自然盘坐，两手重叠放于腿上，自然呼吸，感觉全身毛孔随呼吸一张一合，若能流泪打哈欠效果最佳，到了想睡觉时倒下便睡。 仰卧，自然呼吸，感觉呼吸像春风，先融化大脚趾，然后是其他脚趾，接着脚、小腿、大腿逐渐融化。如还未醒着，再从头做。 入睡快的人可右侧卧，右手掌托右耳。右掌心为火，耳为水，二者形成水火即济，在人体中形成心肾相交。久之，养心滋肾。 睡眠一定要早起，即使在冬天，也不可超过6点起床，春夏秋季尽量在5点之前起床，因为人在寅时(3点—5点)肺 经旺的时候起床，能够使肺气得以舒展，以顺应阳气的舒长，来完成新陈代谢，肃降浊气，使肺气清，这样有助于养肺和顺应太阳的天势升起人体阳气，使人一天阳 气充足，否则，就好像发动机，过了这段好时机就很难发动人体阳气，人体阳气淤积在人体下部不能由命门向上发动升起，会形成淫气，严重损害人的身心健康。 早晨5点至7点是人体大肠经最旺的时候，人体需要把代谢的浊物排出体外，此时如果不起床，大肠得不到充分活动，无法很好的完成排浊功能，使浊物停留而形成毒素，危害人体血液和脏腑百骸。早晨7点到9点人体胃经最旺，9点到11点 人体脾经最旺，这时人的消化吸收运化的能力最好，如果这时还不起床，人体胃酸会严重腐蚀胃粘膜，人体在最佳吸收营养时间得不到营养，长期以来会患脾胃疾 病，造成营养不良、中气塌陷。所以千万不要赖床，赖床会造成头昏、疲惫不堪、睡眠不足的感觉，而应按时起床，历史上许多伟人都是有三四点钟起床的习惯，比 如华盛顿、拿破仑、康熙皇帝、曾国藩等。另外早起能增加工作效益，俗话说：“三天早起，一天工”。 现代医学证明，早睡早起的人精神压力较小，不易患精神类疾病。早晨不要太早出去锻炼，因为早晨在太阳没有出来之前，地下道的漳气、浊气正往上走(尤其是城市)，这些气对人体损伤是很严重的。 养身三大事，一睡眠，二便利，三饮食，其余起居、服装等皆是辅助。 三事中睡眠第一。然胃纳不和者，夜眠不安，故以通便利为第二。而饮食无节，饥饱过度者，肠胃必受伤，而营养日减。睡以安神为主，神 以心安为主，应配合年龄，壮年至多七小时至八小时，多睡则智昏头晕眼红胀，四肢疲软，童年必睡足八小时，或过九小时勿碍，老或病人至多六小时已足。 睡眠中不可忽视的疾病警告 应注意： 睡眠宜早，勿过十时，老年人以八点为正，勿过九点。凡交十一时，为阳生时，属肾，此时失眠，肾水必亏，心肾相连，水亏则火旺，最易伤神。千万勿以安眠药片助睡。枕上切忌思索计算未来事，睡时宜一切不思，鼻息调匀，自己静听其气，由粗而细，由细而微细而息。视此身如无物，或如糖入于水，化为乌有，自然睡着。如有思想，不能安着，切勿在枕上转侧思虑，此最耗神，可坐起一时再睡。如在午时，即上午十一点至一点，为阴生之时，属心，此时如不能睡，可静坐一刻钟，闭目养神，则心气强。凡有心脏病者切宜注意，每日于此二时注意，则元气日强，无心跳腹泄或小便频速之病。夏日起宜早，冬日起宜迟。居北方宜防寒气，如在粤桂等省，早起防山岚瘴气中病。食后勿仰天睡，早起如在寅时三点至五点，此时切忌郁怒，必损肺伤肝，万望注意。另外一篇类似的参考———————————在心理门诊经常接待因失眠而困扰不安的来访者，他们大都有个共同的特点：性格敏感、多疑、自信心不足、固执、犹豫不决、完美主义、爱担心焦虑。对偶尔的几次失眠造成的头疼、注意力涣散、记忆力下降等症状，总是感到忧心忡忡，耿耿于怀。他们每天上班都是无精打采，抱怨说：”唉！昨天晚上又没有睡好觉！今天简直没法工作！”到了晚上，他们总是想方设法地让自己”今天什么也别想，一定要睡个好觉！”但是，事与愿违，越想睡好觉，越睡不着，形成恶性循环。他们有的已经试过许多方法，吃药、练气功、听音乐、或者拼命克制自己的胡思乱想，结果都不奏效，而心理医生教给他们的方法与他们以往使用的方法大相径庭。 首先，在价值观上不要把睡眠看得非常重要。睡眠是让大脑和身体休息的最好方式，但体力劳动和锻炼也是让身心放松的另一最好方式，如果前一晚上没睡好，可以在早晨洗个热水澡，外出锻炼一下身体，精力一样充沛。而失眠患者往往认为睡眠是人生第一重要的事，整天想的就是怎样才能睡好觉，他不理解睡觉是为了保证健康，健康是为了工作，而工作并不是为了睡觉，也就是说：睡觉并不是人生的目标。另外，人每天只需要深度睡眠2-4个小时，其他是有梦睡眠，如果人真的一夜不睡，3天就可以让人的精神崩溃，5天就可以导致死亡，但有的人说好多年都没怎么睡觉，可是他思维仍很正常，所以他的失眠问题并不是想象得那么严重，人应该相信自己的生命力。 其次，睡眠也是人身体的自然反应，困了就想睡觉，不要人为地去控制它，越让自己别想了，自己就越发胡思乱想，停不下来，应该采取顺其自然的态度：想去吧，我今天不打算睡觉了！结果，当你不控制情绪和思维时，20分钟后自然而然地就会入睡了。对于害怕和焦虑情绪也是一样，有的人特别怕睡不着觉，有的总怕半夜醒来难以入睡，越怕就越清醒，又对自己的害怕感到紧张，结果形成恶性循环。正常人也会由于各种原因半夜醒来，不同的是，正常人并没有害怕和排斥的想法，不反省和讨厌自己，完全接受自己的自然状态，这样才能放松。 第三，许多失眠者总觉得自己晚上觉没有睡够，一有时间就要补觉，白天睡得越多，晚上就越睡不着，而且也没有心思去参加业余爱好活动。正确的做法应该是多参加户外的体力活动，劳其筋骨才能放松心情，尤其是睡觉前不要让大脑处于兴奋地思考状态，应做一些散步、爬楼梯、跳绳、洗衣服、拖地等简单枯燥乏味的体力活动，感到累了，困了再上床睡觉，然后以顺其自然的放松状态，进入睡眠。 重点强调一下睡眠时间,这个也是生活中人们容易不当那么一回事的事,,其实人体最佳的睡眠时间是晚上10-6点，这段时间不仅是人体进行正常排毒的时间，同时还是储存刚刚生发的血气的时间，要是这段时间没有休息好，就会引起身体的排毒不顺畅，造成身体的伤害。要是没有休息好，就会消耗掉身体刚刚生发的血气，甚至会消耗掉身体的储存能量，这时就会靠燃烧自己的肝火来支持正常的生命运动，长期下去，就会造成身体发展成为阴虚火重的情况。需要小心。 尤其是我们学生,容易形成夜猫子,第2天就是国宝了,10~11点是女生们因该注意的一个非常重要的时间,这段时间就是保养皮肤的最佳时间,有很多女孩子也就是在这个时间段类做面膜的还有一些譬如说吃苹果之类等等,我的话还没有说完,11~1点又是人体分泌胆汁的时候,这个人体也是极容易兴奋,大多数人容易睡不着,我也没有办法,呵呵!还是要早点睡!1~5点是血液新陈的旺盛期间,不睡也是容易老化的! 一项新的研究显示，连续多晚睡眠不足，即每天睡眠时间不足6小时，就会像连续两晚不睡觉一样对人体的精神造成伤害。 年轻人睡不着觉时大多有一些不良习惯：喜欢饮用咖啡、浓茶等兴奋饮料，喜欢躺在床上看书、看电视、听耳机，造成“时间一长就入睡，电视一关就醒来”的现象。长期养成的这种生活习惯，使这部分人群睡眠时间最少，平均每天6个小时的睡眠时间不到，而正常的睡眠时间应保证 临床早已证实，睡眠质量与心脑血管疾病相关。通过心理、躯体的综合治疗和自我调控，可提高睡眠质量。在7小时以上。 尽管很多人都明白睡眠不足对人体会产生不良影响，但在快节奏的现代生活中，人们为了开展各种活动，所能挤占的往往是睡眠时间。这种对睡眠不足危害的忽视其实隐藏着巨大的健康危机，请关注———缺乏睡眠到底有哪些危害？ 睡眠不足让人付出健康代价 科学技术现代化对人类生活方式的影响已经到了人类不得不反省的地步，它在改善人类生活质量的同时，也把一些无法回避的困扰带到生活方式中。随着夜间睡眠越来越多地被网络、电子邮件、深夜电视节目和现代生活的其他诱惑所替代，越来越多的科学证据表明，太少或没有规律的睡眠可能令人付出健康的代价。研究表明，睡眠不足或不规律除了让人们眼睛胀涩、嗜喝咖啡、在下午会议上打盹之外，还会增加多种重大疾病的患病风险，包括癌症、心脏病、糖尿病和肥胖症等。新的大型研究得到的最新数据再次证实，美国肥胖症盛行至少有部分原因是人均睡眠时间减少。对美国近万名成年人的全国采样分析发现，在32—49岁之间的人群中，夜间睡眠少于7小时者患肥胖症的风险高得多。 睡眠不足使患癌风险增加 此前已经有很多研究者发现了睡眠与其他疾病的类似关系，例如美国哈佛大学进行的护士健康研究发现，睡眠不足或不规律会令患结肠癌、乳腺癌、心脏病或糖尿病的风险增大。美国各地的其他研究组织随后找到了可能解释这种关系的因素，例如睡眠受到干扰会影响与这些疾病有关的人体内重要激素和蛋白质。有几项研究发现，熬夜工作的人尤其容易患乳腺癌和结肠癌，研究人员在为此寻找解释时发现，接受夜间灯光会降低褪黑激素的水平。褪黑激素被认为能降低受其他激素水平（如雌激素）影响导致癌症的风险。在科学家眼中，褪黑激素可抑制肿瘤细胞的生长———是一种抗癌物质。如果长时间暴露在夜间灯光下，产生的褪黑激素一般会减少，会增加患癌症的风险。 美国斯坦福大学科学家伊曼钮尔?米尔奥最近说：“该领域出现了大量研究，并发展迅速。人们开始认为很多疾病都与睡眠不足有关。”但不是所有人都同意这种看法，有专家指出，睡眠模式与健康问题之间最多只能说是勉强有关联，而且很容易用其他因素解释。其他研究者认为，要证实这种表面联系的真实性，要充分了解睡眠缺乏如何作用于健康，对此必须进行更多研究。但是越来越有力的证据表明，睡眠在很多疾病形成中都是一个重要因素。 尽管睡眠的很多问题，例如我们为什么要睡觉———仍然是不解之谜，但正在形成的理论是，睡眠不足或熬夜会扰乱体内的生物钟，令很多基本的身体功能不能保持同步。睡眠缺乏会干扰身体的各项生理功能，没有任何生理机能让人类适应这种行为。 为了健康必须保持充足睡眠 每个人所需的睡眠时间各不相同，有的人只要几个小时就能保持白天精力充沛，但有的人不睡满10个小时就打不起精神。专家说，多数人需要睡7—9小时，如果睡眠少于6或7小时，病魔缠身的风险就会增加。科学家早就知道睡眠疾病（例如睡眠时呼吸暂停、嗜睡症和长期失眠）可能导致严重的健康问题。但大型流行病学研究发现，睡眠时间最少的人死亡风险似乎也大大增加。这是首次有迹象表明，本来健康的人如果由于工作、家庭或生活方式的原因睡眠不足或改变睡眠规律，健康就可能受到影响。生理研究表明，睡眠缺乏可能令身体保持高度警戒状态，增加压力激素的分泌并令血压升高，这是心脏病和中风的重要风险因素。此外，缺乏睡眠的人血液中物质的浓度升高，这是体内有炎症的状态，最近也被发现是心脏病、中风、癌症和糖尿病的重要风险源。","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"生活","slug":"生活","permalink":"https://www.hojun.cn/tags/生活/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]},{"title":"BadUSB —— Teensy++2.0","slug":"BadUSB-——-Teensy-2-0","date":"2017-06-07T03:18:31.000Z","updated":"2018-08-11T15:24:48.115Z","comments":true,"path":"2017/06/07/BadUSB-——-Teensy-2-0/","link":"","permalink":"https://www.hojun.cn/2017/06/07/BadUSB-——-Teensy-2-0/","excerpt":"","text":"参考http://bbs.pediy.com/showthread.php?t=213719前几天发现了BadUSB这个好玩的东西，橡皮鸭和烧鹅都买不起就在某宝上买了个Teensy++2.0 1.下载Teensyduinohttps://www.pjrc.com/teensy/td_download.html 2.安装Arduino。我这里安装1.8.0https://pan.baidu.com/s/1b4jPX8#list/path=%2F&amp;parentPath=%2FArduino 3.安装Teensyduino注意红色框起来的是支持的Arduino版本。 4.可以插入Teensy++2.0开始搞事了 注意：1.汉化 file-&gt;preferences 选择language为简体中文 2.工具里面要选送份代码： 代码：1234567891011121314151617181920212223242526272829303132333435void setup()&#123; //初始化 Keyboard.begin();//开始键盘通信 delay(1000);//延时1000毫秒，不要太短，因为每天电脑的运行速度都不一样 Keyboard.press(KEY_CAPS_LOCK); //按下大写键 这里我们最好这样写 不然大多数电脑在中文输入的情况下就会出现问题 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 delay(500); Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 delay(500); Keyboard.press('r');//按下r键 delay(500); Keyboard.release(KEY_LEFT_GUI);//松掉win键 Keyboard.release('r');//松掉r键 //delay(500); Keyboard.println(\"cmd\");//输入cmd进入DOS delay(500); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.println(\"Hello Teensy++2.0\"); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.press(KEY_CAPS_LOCK); //按下大写键 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 我们再次关闭开启的大写键 delay(500); Keyboard.println(\"exit\"); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 Keyboard.end();//结束键盘通讯&#125; void loop()//循环，这里的代码&#123; //循环体 写入你要循环的代码&#125; 在附一段代码，在21点打开个txt12345678910111213141516171819202122232425262728293031323334353637void setup()&#123; //初始化 Keyboard.begin();//开始键盘通信 delay(1000);//延时1000毫秒，不要太短，因为每天电脑的运行速度都不一样 Keyboard.press(KEY_CAPS_LOCK); //按下大写键 这里我们最好这样写 不然大多数电脑在中文输入的情况下就会出现问题 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 delay(500); Keyboard.press(KEY_LEFT_GUI);//按下徽标键 也就是win键 delay(500); Keyboard.press('r');//按下r键 delay(500); Keyboard.release(KEY_LEFT_GUI);//松掉win键 Keyboard.release('r');//松掉r键 //delay(500); Keyboard.println(\"cmd\");//输入cmd进入DOS delay(500); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.println(\"D:\"); Keyboard.println(\"echo I'm back!&gt;a.txt\"); Keyboard.println(\"schtasks /create /tn \\\"hack\\\" /tr \\\"d:a.txt\\\" /sc once /st 21:12\"); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 delay(500); Keyboard.press(KEY_CAPS_LOCK); //按下大写键 Keyboard.release(KEY_CAPS_LOCK); //释放大写键 我们再次关闭开启的大写键 delay(500); Keyboard.println(\"exit\"); Keyboard.press(KEY_RETURN); //按下回车键 Keyboard.release(KEY_RETURN); //释放回车键 Keyboard.end();//结束键盘通讯&#125; void loop()//循环，这里的代码&#123; //循环体 写入你要循环的代码&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"搞事","slug":"搞事","permalink":"https://www.hojun.cn/tags/搞事/"},{"name":"硬件","slug":"硬件","permalink":"https://www.hojun.cn/tags/硬件/"},{"name":"hacker","slug":"hacker","permalink":"https://www.hojun.cn/tags/hacker/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"base64 DataUrl blod file canvas图片格式转换","slug":"base64-DataUrl-blod-file-canvas图片格式转换","date":"2017-06-07T03:15:47.000Z","updated":"2018-08-11T15:24:48.137Z","comments":true,"path":"2017/06/07/base64-DataUrl-blod-file-canvas图片格式转换/","link":"","permalink":"https://www.hojun.cn/2017/06/07/base64-DataUrl-blod-file-canvas图片格式转换/","excerpt":"","text":"//img元素转base64 元素应为 &lt;img src=&quot;xxx.jpg&quot;&gt;这种格式123456789function getBase64Image(img) &#123; var canvas = document.createElement(&quot;canvas&quot;); canvas.width = img.width; canvas.height = img.height; var ctx = canvas.getContext(&quot;2d&quot;); ctx.drawImage(img, 0, 0, img.width, img.height); var dataURL = canvas.toDataURL(&quot;image/jpeg&quot;); return dataURL // return dataURL.replace(&quot;data:image/png;base64,&quot;, &quot;&quot;); &#125; //把base64图片数据转成blod，通过formdata提交12345678910111213function dataURItoBlob(base64Data) &#123; var byteString; if (base64Data.split(&apos;,&apos;)[0].indexOf(&apos;base64&apos;) &gt;= 0) byteString = atob(base64Data.split(&apos;,&apos;)[1]); else byteString = unescape(base64Data.split(&apos;,&apos;)[1]); var mimeString = base64Data.split(&apos;,&apos;)[0].split(&apos;:&apos;)[1].split(&apos;;&apos;)[0]; var ia = new Uint8Array(byteString.length); for (var i = 0; i &lt; byteString.length; i++) &#123; ia[i] = byteString.charCodeAt(i); &#125; return new Blob([ia], &#123;type:mimeString&#125;);&#125; //file转base6412345678$(&quot;XXX&quot;).change(function() &#123; var img = $(this).siblings(&quot;img&quot;); var reader = new FileReader(); reader.readAsDataURL(this.files[0]); reader.onload = function (e) &#123; img.attr(&apos;src&apos;,this.result); &#125;&#125;); //file转url 此url是个blob url（blob:http://localhost/a8cb6497-9c33-4d8d-8b6d-04a90db64eba），可以实现预览。 123456789101112function getObjectURL(file) &#123; var url = null; if(window.createObjectURL != undefined) &#123; // basic url = window.createObjectURL(file); &#125; else if(window.URL != undefined) &#123; // mozilla(firefox) url = window.URL.createObjectURL(file); &#125; else if(window.webkitURL != undefined) &#123; // webkit or chrome url = window.webkitURL.createObjectURL(file); &#125; //console.log(url); return url; &#125; //blob:http://localhost/转base64这里使用了ajax，不知道还有什么实现方法123456789101112131415161718192021//getObjectURL 上一步用到的函数objUrl = getObjectURL(this.files[i]);var xhr = new XMLHttpRequest;xhr.responseType = &apos;blob&apos;;xhr.open(&apos;GET&apos;, blobUrl);xhr.send();xhr.onload = function() &#123; var recoveredBlob = xhr.response; //console.log(recoveredBlob) 结果为 Blob &#123;size: 6683, type: &quot;image/jpeg&quot;&#125; var reader = new FileReader; reader.readAsDataURL(recoveredBlob); reader.onload = function() &#123; var blobAsDataUrl = reader.result; //console.log(blobAsDataUrl) 结果为 base64 图片数据 &#125;;&#125;; // 把image 转换为 canvas对象12345678910111213function convertImageToCanvas()&#123; var image = document.getElementById(&quot;myImg&quot;); // 创建canvas DOM元素，并设置其宽高和图片一样 var canvas = document.createElement(&quot;myCanvas&quot;); canvas.width = image.width; canvas.height = image.height; // 坐标(0,0) 表示从此处开始绘制，相当于偏移。 var ctx = canvas.getContext(&quot;2d&quot;); image.onload = function()&#123; ctx.drawImage(image,0,0); &#125;;&#125; //从 canvas 提取图片 image12345678function convertCanvasToImage()&#123; var myCanvas = document.getElementById(&quot;myCanvas&quot;); var dataURL = myCanvas.toDataURL(&quot;image/png&quot;); var img=document.getElementById(&quot;tulip2&quot;); img.setAttribute(&apos;src&apos;, dataURL); console.log(dataURL);&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"canvas两张图片合成一张","slug":"canvas两张图片合成一张","date":"2017-06-07T02:48:51.000Z","updated":"2018-08-11T15:24:48.170Z","comments":true,"path":"2017/06/07/canvas两张图片合成一张/","link":"","permalink":"https://www.hojun.cn/2017/06/07/canvas两张图片合成一张/","excerpt":"","text":"碰见一个需求，把一张图片和用户的二维码图片合成一张参考w3cshool和一些资料实现需求demo.html1234567891011121314151617181920212223242526272829303132333435363738&lt;html&gt;&lt;body&gt;&lt;p&gt;要使用的图像：&lt;/p&gt;&lt;img id=\"tulip\" src=\"eg_tulip.jpg\" alt=\"The Tulip\" /&gt;&lt;p&gt;画布：&lt;/p&gt;&lt;canvas id=\"myCanvas\" width=\"500\" height=\"300\" style=\"border:1px solid #d3d3d3;background:#ffffff;\"&gt;Your browser does not support the HTML5 canvas tag.&lt;/canvas&gt;&lt;p&gt;合成的图像：&lt;/p&gt;&lt;img id=\"tulip2\" src=\"\" alt=\"The Tulip\" /&gt;&lt;script&gt; var c=document.getElementById(\"myCanvas\"); var ctx=c.getContext(\"2d\"); var img=document.getElementById(\"tulip\"); img.onload = function()&#123; ctx.drawImage(img,0,0); ctx.drawImage(img,100,100); convertCanvasToImage(); &#125;; //从 canvas 提取图片 image function convertCanvasToImage() &#123; var myCanvas = document.getElementById(\"myCanvas\"); var dataURL = myCanvas.toDataURL(\"image/png\"); var img=document.getElementById(\"tulip2\"); img.setAttribute('src', dataURL); console.log(dataURL); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 注意：若toDataURL方法报错 Failed to execute ‘toDataURL’ on ‘HTMLCanvasElement’: Tainted canvases may not be exported.原因：是由于文件所在的域和图片和页面所在域不同，出现跨域传输的问题。解决：1.把图片放到本地。2把demo文件放到服务器下","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"},{"name":"html5","slug":"html5","permalink":"https://www.hojun.cn/tags/html5/"},{"name":"canvas","slug":"canvas","permalink":"https://www.hojun.cn/tags/canvas/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"虚拟机安装ubuntu16.04.2","slug":"虚拟机安装ubuntu16-04-2","date":"2017-06-04T12:07:31.000Z","updated":"2018-08-11T15:24:47.359Z","comments":true,"path":"2017/06/04/虚拟机安装ubuntu16-04-2/","link":"","permalink":"https://www.hojun.cn/2017/06/04/虚拟机安装ubuntu16-04-2/","excerpt":"","text":"ubuntu镜像下载地址http://www.cnblogs.com/phpzhou/p/6288762.html VMware安装教程http://www.cnblogs.com/phpzhou/p/6288762.html注意 win10虚拟机最好使用VMware12.5.5最新版的 安装LNMP环境参照http://www.cnblogs.com/ddling/p/5906109.html参照http://www.cnblogs.com/phpzhou/p/6288762.html 注：若nginx服务启动重启报错，可以检查下配置文件是否ok 命令sudo nginx -t注：若访问localhost报403。1.是否给目录授权 命令 sudo chmod -R [目录]；2.检查路径下是否有index文件（index.html\\index.php等等） 安装sublime text 3参照http://www.cnblogs.com/hester/p/5617713.html安装package control1import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://www.hojun.cn/tags/mysql/"},{"name":"php","slug":"php","permalink":"https://www.hojun.cn/tags/php/"},{"name":"sublime","slug":"sublime","permalink":"https://www.hojun.cn/tags/sublime/"},{"name":"linux","slug":"linux","permalink":"https://www.hojun.cn/tags/linux/"},{"name":"nginx","slug":"nginx","permalink":"https://www.hojun.cn/tags/nginx/"},{"name":"vmware","slug":"vmware","permalink":"https://www.hojun.cn/tags/vmware/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://www.hojun.cn/tags/ubuntu/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"Jcrop截取头像上传","slug":"Jcrop截取头像上传","date":"2017-06-03T01:09:59.000Z","updated":"2018-08-11T15:24:48.738Z","comments":true,"path":"2017/06/03/Jcrop截取头像上传/","link":"","permalink":"https://www.hojun.cn/2017/06/03/Jcrop截取头像上传/","excerpt":"","text":"之前用Jcrop实现头像上传的功能的时候。有个缺点，是先把原始图片上传，再在页面上显示出来，供用户截取。这么以来不管用户是否保存修改头像的操作，都会执行一个上传操作并保存图片。改进：把上传的图片转成base64格式的图片显示在页面上，仅当用户截取头像点击保存的时候再执行上传操作。 效果：直接上代码index.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163&lt;html lang=\"en\" style=\"overflow-x:visible;\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" /&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"keywords\" content=\"\"&gt; &lt;meta http-equiv=\"pragma\" content=\"no-cache\"&gt; &lt;meta http-equiv=\"cache-control\" content=\"no-cache\"&gt; &lt;meta http-equiv=\"expires\" content=\"0\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./css/self_container.css\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./css/self_bootstrap.css\"&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"./css/jquery.Jcrop.min.css\"&gt; &lt;/head&gt; &lt;body style=\"overflow-x:visible;\"&gt; &lt;div class=\"self_container\"&gt; &lt;div class=\"content-wrapper\" style=\"min-height: 800px;\"&gt; &lt;div class=\"col-md-9\"&gt; &lt;div class=\"panel panel-default panel-col\"&gt; &lt;div class=\"panel-heading\"&gt; 头像设置&lt;/div&gt; &lt;div class=\"panel-body\"&gt; &lt;form id=form1 style=\"display: block\" enctype=\"multipart/form-data\" class=\"form-horizontal\" method=\"post\"&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-md-2 control-label\"&gt; &lt;b&gt; 当前头像&lt;/b&gt; &lt;/div&gt; &lt;div class=\"controls col-md-8 controls\"&gt; &lt;img src=\"./img/avatar.jpg\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-md-2 control-label\"&gt; &lt;/div&gt; &lt;div class=\"controls col-md-8 controls\"&gt; &lt;p class=\"help-block\"&gt; 仅支持上传JPG格式的文件。 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-md-2 control-label\"&gt; &lt;/div&gt; &lt;div class=\"controls col-md-8 controls\"&gt; &lt;a id=\"upload-picture-btn\" class=\"btn btn-primary webuploader-container\" &gt; &lt;div class=\"webuploader-pick\"&gt; 上传新头像&lt;/div&gt; &lt;div id=\"\" style=\"position: absolute; top: 6px; width: 70px; height: 20px; overflow: hidden; bottom: auto; right: auto;\"&gt; &lt;input id=\"avatar1\" type=\"file\" name=\"avatar\" class=\"webuploader-element-invisible\" accept=\"image/png,image/jpg,image/jpeg,imge/bmp,image/gif\"&gt; &lt;label style=\"opacity: 0; width: 100%; height: 100%; display: block; cursor: pointer; background: rgb(255, 255, 255);\"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;form id=\"form2\" style=\"display: none;\" action=\"\" method=\"post\"&gt; &lt;div class=\"form-group clearfix\"&gt; &lt;div class=\"col-md-offset-2 col-md-8 controls\"&gt; &lt;img id=\"cropbox\" class=\"img-responsive\" src=\"\" &gt; &lt;div class=\"help-block\"&gt; 提示：请选择图片裁剪区域。&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;div class=\"col-md-offset-2 col-md-8 controls\"&gt; &lt;a class=\"btn btn-fat btn-primary\" id=\"upload-avatar-btn\" data-url=\"/settings/avatar/crop\" data-goto-url=\"/settings/avatar\"&gt; 保存 &lt;input id=\"commit\" type=\"button\" value=\"保存\" style=\"position: absolute; left: 10px; width: 55px; height: 35px; top:0px; opacity: 0;\" /&gt; &lt;/a&gt; &lt;/div&gt; &lt;div class=\"col-md-offset-2 col-md-8 controls\"&gt; &lt;a id=\"upload-picture-btn\" class=\"btn btn-primary webuploader-container\" &gt; &lt;div class=\"webuploader-pick\"&gt; 重新选择图片&lt;/div&gt; &lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;input type=\"hidden\" id=\"x\" name=\"x\" /&gt; &lt;input type=\"hidden\" id=\"y\" name=\"y\" /&gt; &lt;input type=\"hidden\" id=\"w\" name=\"w\" /&gt; &lt;input type=\"hidden\" id=\"h\" name=\"h\" /&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"./js/jquery-2.2.3.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"./js/jquery.Jcrop.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; (function()&#123; $(\"#avatar1\").change(function() &#123; var img = $(\".img-responsive\"); var reader = new FileReader(); reader.readAsDataURL(this.files[0]); reader.onload = function (e) &#123; img.attr('src',this.result); $(\"#form1\").css('display','none'); $(\"#form2\").css('display','block'); $('.img-responsive').Jcrop(&#123; boxWidth:600, boxHeight:300, aspectRatio: 1, onSelect: updateCoords, &#125;); &#125; &#125;); $(\".webuploader-pick\").click(function() &#123; location.reload(); &#125;); &#125;)() $(\"#commit\").click(function()&#123; var avatarForm = document.getElementById('form2'); var formData = new FormData(avatarForm); $(\".img-responsive\").each(function()&#123; var blob = dataURItoBlob(this.src); // 上一步中的函数 formData.append(\"avatar\", blob, 'avatar.jpg'); &#125;); $.ajax(&#123; url: 'upload.php', type: 'post', processData: false, contentType: false, // dataType: 'json', data: formData, success: function(data)&#123; location.reload(); &#125;, error: function()&#123; alert(\"error\"); &#125; &#125;); &#125;) function dataURItoBlob(base64Data) &#123; var byteString; if (base64Data.split(',')[0].indexOf('base64') &gt;= 0) byteString = atob(base64Data.split(',')[1]); else byteString = unescape(base64Data.split(',')[1]); var mimeString = base64Data.split(',')[0].split(':')[1].split(';')[0]; var ia = new Uint8Array(byteString.length); for (var i = 0; i &lt; byteString.length; i++) &#123; ia[i] = byteString.charCodeAt(i); &#125; return new Blob([ia], &#123;type:mimeString&#125;); &#125; function updateCoords(c) &#123; $('#x').val(c.x); $('#y').val(c.y); $('#w').val(c.w); $('#h').val(c.h); &#125;; function checkCoords() &#123; if (parseInt($('#w').val())) return true; alert('Please select a crop region then press submit.'); return false; &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; upload.php1234567891011121314151617&lt;?php if ($_SERVER['REQUEST_METHOD']==\"POST\") &#123; // 保存图片 $image = $_FILES['avatar']; if($image['error'] == UPLOAD_ERR_OK)&#123; $dest='img/avatar_crop.jpg'; move_uploaded_file($image['tmp_name'],$dest); &#125; $targ_w = $targ_h = 160; $jpeg_quality = 90; $src = 'img/avatar_crop.jpg'; $img_r = imagecreatefromjpeg($src); $dst_r = ImageCreateTrueColor( $targ_w, $targ_h ); imagecopyresampled($dst_r, $img_r, 0, 0, $_POST['x'], $_POST['y'], $targ_w, $targ_h, $_POST['w'], $_POST['h']); imagejpeg($dst_r, 'img/avatar.jpg', $jpeg_quality); echo \"success\";&#125;","categories":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://www.hojun.cn/tags/jquery/"},{"name":"jcrop","slug":"jcrop","permalink":"https://www.hojun.cn/tags/jcrop/"},{"name":"前端","slug":"前端","permalink":"https://www.hojun.cn/tags/前端/"}],"keywords":[{"name":"技术","slug":"tech","permalink":"https://www.hojun.cn/categories/tech/"}]},{"title":"这是一个测试","slug":"这是一个测试","date":"2017-04-26T05:40:53.000Z","updated":"2018-08-11T15:24:47.792Z","comments":true,"path":"2017/04/26/这是一个测试/","link":"","permalink":"https://www.hojun.cn/2017/04/26/这是一个测试/","excerpt":"","text":"这是一个测试1234public function test()&#123; print(&quot;hello world&quot;)&#125;","categories":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}],"tags":[{"name":"测试","slug":"测试","permalink":"https://www.hojun.cn/tags/测试/"},{"name":"hojun","slug":"hojun","permalink":"https://www.hojun.cn/tags/hojun/"}],"keywords":[{"name":"生活","slug":"live","permalink":"https://www.hojun.cn/categories/live/"}]}]}