title: 《算法图解》之数组和链表的比较
author: hojun
avatar: /images/favicon.png
authorDesc: 一个好奇的人
categories: 技术
date: 2018-05-01 22:30:11
authorLink:
authorAbout:
tags:
 - 算法
 - 悦读
keywords: 数组和链表
description: 使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。所以在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。
photos:
---
## **数组&链表比较**
### **数组**

![](https://wx3.sinaimg.cn/large/006bYVyvgy1fqw7appbhcj30mz03m3yi.jpg)
使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。所以在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。这样，只要待办事项不超过10个，就无需转移。这是一个不错的权变措施，但你应该明白，它存在如下两个缺点。

 - 你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。
 - 待办事项超过10个后，你还得转移。

### **链表**
![](https://wx3.sinaimg.cn/large/006bYVyvgy1fqw7aupy8aj30dw02ydfq.jpg)
链表中的元素可存储在内存的任何地方。链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。使用链表时，根本就不需要移动元素。这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。

使用链表时，根本就不需要移动元素。这还可避免另一个问题。假设你与五位朋友去看一部很火的电影。你们六人想坐在一起，但看电影的人较多，没有六个在一起的座位。使用数组时有时就会遇到这样的情况。假设你要为数组分配10 000个位置，内存中有10 000个位置，但不都靠在一起。在这种情况下，你将无法为该数组分配内存！链表相当于说“我们分开来坐”，因此，只要有足够的内存空间，就能为链表分配内存。

### **链表的优势在插入元素方面，那数组的优势又是什么呢？** 
在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。

数组与此不同：你知道其中每个元素的地址。（因为是按顺序存储的）只需执行简单的数学运算就知道。需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。


**附加：log的理解**
一般对于对数log的解释都是这样的：如果a的x次方等于N（a>0，且a不等于1），那么数x叫做以a为底N的对数（logarithm），记作x=logaN。其中，a叫做对数的底数，N叫做真数。
很抽象有木有！
《算法图解》中这样解释：log10100相当于问“将多少个10相乘的结果为100”。答案是两个：10 × 10 = 100。因此，log10100 = 2