title: 《实战ES2015》之箭头函数
author: hojun
avatar: /images/favicon.png
authorDesc: 一个好奇的人
categories: 技术
comments: true
date: 2018-07-18 18:53:30
authorLink:
authorAbout:
series: 《实战ES2015》
tags:
 - 悦读
 - js
 - es5
keywords: ES5
description: 箭头函数，顾名思义便是使用箭头(=>)进行定义的函数，属于匿名函数(AnonymousFunction)一类。
photos:
 - https://wx2.sinaimg.cn/small/006bYVyvgy1ftc1xvhj97j30me0gcmyh.jpg
---
![](https://wx2.sinaimg.cn/large/006bYVyvgy1ftc1xvhj97j30me0gcmyh.jpg)
箭头函数，顾名思义便是使用箭头(=>)进行定义的函数，属于匿名函数(AnonymousFunction)一类。当然了，它也可以作为定义式函数使用，但我们并不推荐这样做，随后会详细解释。

## 使用语法
箭头函数有四种使用语法
### 单一参数的单行箭头函数
```js
//Syntax: arg => statement
const fn = foo => `${foo} world` //意思相当于return `foo + 'world'`
```
这是箭头函数最简洁的形式，常见于用作简单的处理函数，如过滤。
```js
let array = ['a', 'bc', 'def', 'ghij']
array = array.filter(item => item.lengh >= 2) //=>bc, def, ghij
```
### 多参数的单箭头函数
```js
//Syntax: (arg1, arg2) => statement
const fn = (foo, bar) => foo + bar
```
在大多数情况下，函数都不会只有一个参数传入，在箭头函数中，多参数的语法跟普通函数一样，以括号来包裹参数列。这种形式常见于数组的处理，如排序。
```js
let array = ['a', 'bc', 'def', 'ghij']
array = array.sort((a, b) => a.length < b.length) //["ghij", "def", "bc", "a"]

var arr = [10, 5, 43, 25, 1000, 1]
console.log(arr.sort((a, b) => a > b)) //[1, 5, 10, 25, 40, 1000]
```
### 多行箭头函数
```js
//Syntax: arg => { ... }
//单一参数
foo => {
    return `${foo} world`
}
```
```js
//Syntax: (arg1, arg2) => { ... }
//多参数
(foo + bar) => {
    return foo + bat
}
```
### 无参数箭头函数
如果一个箭头函数无参数传入，则需要用一对空的括号来表示空的参数列表。
```js
//Syntax: () => statement
const greent = () => 'Hello World!'
```
以上都是被支持的箭头函数表达式，其最大的好处便是简洁明了，省略了function关键字，而使用 => 代替。相对于传统的function语句，箭头函数在简单的函数使用中更为简介直观。

## this穿透

事实上，箭头函数在ES2015标准中，并不只是作为一种简单的语法糖出现。就如同它在CoffeeScript中的定义一般，是用于将函数内部的this延伸至上一层作用域中，即上一层的上下文会穿透到内层的箭头函数中，我们可以以一段代码来简单解释。
```js
const obj = {
    hello: 'world',
    foo() {
        //this
        const bar = () => this.hello
        return bar
    }
}

window.hello = 'ES6'
window.bar = obj.foo()
window.bar() //=>'world'
```

因为箭头函数绑定上下文的特性，故不能随意在顶层作用域使用箭头函数，以防出现下面的错误。
```js
//假设当前运行环境为浏览器在，则顶层上下文为window
const obj = {
  msg: 'pong',
  ping: () => this.msg
}

obj.ping() //=>undefined
var msg = 'bang!'
obj.ping() //=>bang
```

同样的，在箭头函数中也没有arguments、callee甚至caller等对象。
```js
const fn = () => {
  console.log(arguments[0])
}
fn(1, 2) //=>ReferenceErroe: arguments is not defined
```
如果有使用anguments的需求，可以使用后续参数来取得参数列表。
```js
const fn = (...args) => {
  console.log(args[0])
}

fn(1, 2, 3) //=> 1
```
## 编写语法注意事项

### 请不要对单行的函数体做任何换行
```js
const fn = x
=> x * 2 //SyntaxError
const fn = x => x * 2 //OK
```
### 参数列表的右括弧、箭头需要保持在同一行内。
```js
const fn (x, y)
=> {
  return x * y
} // SyntaxError
const fn (x, y) => {
  return x * y
} // OK
```
若要使用单行箭头函数直接返回一个对象字面量，请使用一个括号包裹该对面字面量，而不是直接使用大括号，否则ECMAScript解析引擎会将其解析为一个多行箭头函数。
```js
const ids = [1, 2, 3]
const users = ids.map(id => {id: id})
//=> [undefined, undefined, undefined]

const users = ids.map(id => ({id: id}))
//=> [{id: 1}, {id: 2}, {id: 3}]
```